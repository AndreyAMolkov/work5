Preface.......................................................................................................................................6 
the to first edition..........................................................................................................8 Preface 
Tutorial A Chapter 1 Introduction...........................................................................................9 - 
Started..................................................................................................................9 Getting 1.1 
and Variables Arithmetic Expressions...........................................................................11 1.2 
for The statement............................................................................................................16 1.3 
Constants........................................................................................................17 Symbolic 1.4 
Input Character and Output............................................................................................18 1.5 
Copying............................................................................................................18 File 1.5.1 
Counting.................................................................................................20 Character 1.5.2 
Counting..........................................................................................................21 Line 1.5.3 
Counting........................................................................................................22 Word 1.5.4 
Arrays............................................................................................................................23 1.6 
Functions.......................................................................................................................25 1.7 
by Call 1.8 Arguments Value.............................................................................................28 - 
Arrays............................................................................................................29 Character 1.9 
Variables External and Scope......................................................................................31 1.10 
Operators 2 Types, Chapter and Expressions........................................................................35 - 
Names..............................................................................................................35 Variable 2.1 
Types Data and Sizes.....................................................................................................35 2.2 
Constants.......................................................................................................................36 2.3 
Declarations...................................................................................................................39 2.4 
Operators......................................................................................................40 Arithmetic 2.5 
and Relational Logical Operators...................................................................................40 2.6 
Conversions...........................................................................................................41 Type 2.7 
and Increment Decrement Operators..............................................................................44 2.8 
Operators...........................................................................................................46 Bitwise 2.9 
Operators Assignment and Expressions.......................................................................47 2.10 
Expressions...............................................................................................49 Conditional 2.11 
of Order 2.12 Precedence Evaluation............................................................................49 and 
- 3 Control Flow.........................................................................................................52 Chapter 
and Statements Blocks...................................................................................................52 3.1 
If-Else............................................................................................................................52 3.2 
Else-If.............................................................................................................................53 3.3 
Switch............................................................................................................................54 3.4 
and While 3.5 Loops For...................................................................................................56 - 
- Loops Do-While...........................................................................................................58 3.6 
and Break Continue........................................................................................................59 3.7 
and Goto labels...............................................................................................................60 3.8 
and 4 Functions Chapter Program Structure..........................................................................62 - 
of Basics Functions........................................................................................................62 4.1 
Returning Functions Non-integers.................................................................................65 4.2 
Variables..........................................................................................................67 External 4.3 
Rules....................................................................................................................72 Scope 4.4 
Files....................................................................................................................73 Header 4.5 
Variables..............................................................................................................75 Static 4.6 
Variables..........................................................................................................75 Register 4.7 
Structure...............................................................................................................76 Block 4.8 
Initialization..................................................................................................................76 4.9 
Recursion......................................................................................................................78 4.10 
C The Preprocessor......................................................................................................79  4.11 
Inclusion.........................................................................................................79 File 4.11.1 
Substitution................................................................................................80 Macro 4.11.2 
Inclusion............................................................................................82 Conditional 4.11.3 
and Pointers Chapter 5 Arrays...............................................................................................83 - 
and Pointers Addresses...................................................................................................83 5.1 
and Pointers Function Arguments..................................................................................84 5.2 
and Pointers Arrays........................................................................................................87 5.3 
Arithmetic........................................................................................................90 Address 5.4 
Pointers Character and Functions...................................................................................93 5.5 
to Pointers 5.6 Pointer Pointers...............................................................................96 Arrays; 
Arrays..............................................................................................99 Multi-dimensional 5.7 
of Initialization Pointer Arrays.....................................................................................101 5.8 
vs. Pointers Multi-dimensional Arrays.........................................................................101 5.9 
Arguments.........................................................................................102 Command-line 5.10 
to Pointers Functions..................................................................................................106 5.11 
Declarations..........................................................................................108 Complicated 5.12 
- 6 Structures.............................................................................................................114 Chapter 
of Basics Structures......................................................................................................114 6.1 
and Structures Functions..............................................................................................116 6.2 
of Arrays Structures.....................................................................................................118 6.3 
to Pointers Structures...................................................................................................122 6.4 
Structures............................................................................................124 Self-referential 6.5 
Lookup...............................................................................................................127 Table 6.6 
Typedef........................................................................................................................129 6.7 
Unions.........................................................................................................................131 6.8 
Bit-fields.......................................................................................................................132 6.9 
and Input Chapter 7 Output..................................................................................................135 - 
Input Standard and Output...........................................................................................135 7.1 
Output Formatted - printf.............................................................................................137 7.2 
Argument Variable-length Lists...................................................................................138 7.3 
Input Formatted - Scanf................................................................................................140 7.4 
Access...................................................................................................................142 File 7.5 
Stderr Error - 7.6 and Exit..................................................................................145 Handling 
Input Line and Output..................................................................................................146 7.7 
Functions..............................................................................................147 Miscellaneous 7.8 
Operations...................................................................................................147 String 7.8.1 
and Testing 7.8.2 Character Conversion..............................................................148 Class 
Ungetc...................................................................................................................148 7.8.3 
Execution.............................................................................................148 Command 7.8.4 
Management.............................................................................................148 Storage 7.8.5 
Functions........................................................................................149 Mathematical 7.8.6 
Number generation.................................................................................149 7.8.7 Random 
UNIX The Interface................................................................................151 8 System - Chapter 
Descriptors............................................................................................................151 File 8.1 
Read Low and - 8.2 Level Write..................................................................................152 I/O 
Creat, Open, Close, Unlink..........................................................................................153 8.3 
Access Random - Lseek...............................................................................................155 8.4 
and of Fopen Getc.......................................................156 8.5 Example An - implementation 
- Example Listing Directories......................................................................................159 8.6 
Storage Allocator....................................................................................163 A 8.7 - Example 
- A Reference Manual...........................................................................................168 Appendix 
 Introduction.................................................................................................................168 A.1 
Conventions....................................................................................................168 Lexical A.2 
Tokens..................................................................................................................168 A.2.1 
Comments.............................................................................................................168 A.2.2 
Identifiers..............................................................................................................168 A.2.3 
Keywords..............................................................................................................169 A.2.4 
Constants..............................................................................................................169 A.2.5 
Literals.......................................................................................................171 String A.2.6 
Notation...........................................................................................................171 Syntax A.3 
of Identifiers.................................................................................................171 A.4 Meaning 
Class........................................................................................................171 Storage A.4.1 
Types..........................................................................................................172 Basic A.4.2 
types........................................................................................................173 Derived A.4.3 
Qualifiers.....................................................................................................173 Type A.4.4 
and Lvalues....................................................................................................173 A.5 Objects 
Conversions.................................................................................................................173 A.6 
Promotion................................................................................................174 Integral A.6.1 
Conversions.............................................................................................174 Integral A.6.2 
and Floating..............................................................................................174 A.6.3 Integer 
Types......................................................................................................174 Floating A.6.4 
Conversions........................................................................................174 Arithmetic A.6.5 
and Integers............................................................................................175 A.6.6 Pointers 
Void......................................................................................................................176 A.6.7 
to Void....................................................................................................176 A.6.8 Pointers 
Expressions..................................................................................................................176 A.7 
Conversion...............................................................................................177 Pointer A.7.1 
Expressions.............................................................................................177 Primary A.7.2 
Expressions..............................................................................................177 Postfix A.7.3 
Operators...................................................................................................179 Unary A.7.4 
Casts.....................................................................................................................181 A.7.5 
Operators.......................................................................................181 Multiplicative A.7.6 
Operators...............................................................................................182 Additive A.7.7 
Operators.....................................................................................................182 Shift A.7.8 
Operators.............................................................................................183 Relational A.7.9 
Operators..............................................................................................183 Equality A.7.10 
AND Operator.......................................................................................183 A.7.11 Bitwise 
Exclusive Bitwise OR Operator.........................................................................184 A.7.12 
Inclusive Bitwise OR Operator..........................................................................184 A.7.13 
AND Operator.......................................................................................184 A.7.14 Logical 
OR Operator..........................................................................................184 A.7.15 Logical 
Operator..........................................................................................184 Conditional A.7.16 
Expressions.....................................................................................185 Assignment A.7.17 
Operator................................................................................................185 Comma A.7.18 
Expressions.........................................................................................186 Constant A.7.19 
Declarations.................................................................................................................186 A.8 
Class Specifiers.......................................................................................187 A.8.1 Storage 
Specifiers.....................................................................................................188 Type A.8.2 
and Structure Union Declarations........................................................................188 A.8.3 
Enumerations........................................................................................................191 A.8.4 
Declarators............................................................................................................192 A.8.5 
of Declarators........................................................................................193 A.8.6 Meaning 
Initialization..........................................................................................................196 A.8.7 
names...........................................................................................................198  A.8.8 Type 
Typedef.................................................................................................................199 A.8.9 
Equivalence...............................................................................................199 Type A.8.10 
Statements...................................................................................................................199 A.9 
Statements...............................................................................................200 Labeled A.9.1 
Statement...........................................................................................200 Expression A.9.2 
Statement...........................................................................................200 Compound A.9.3 
Statements.............................................................................................201 Selection A.9.4 
Statements..............................................................................................201 Iteration A.9.5 
statements...................................................................................................202 Jump A.9.6 
Declarations................................................................................................203 External A.10 
Definitions...........................................................................................203 Function A.10.1 
Declarations.........................................................................................204 External A.10.2 
and Linkage....................................................................................................205 A.11 Scope 
Scope.....................................................................................................205 Lexical A.11.1 
Linkage...............................................................................................................206 A.11.2 
Preprocessing.............................................................................................................206 A.12 
Sequences............................................................................................207 Trigraph A.12.1 
Splicing......................................................................................................207 Line A.12.2 
Definition Macro and Expansion.......................................................................207 A.12.3 
Inclusion......................................................................................................209 File A.12.4 
Compilation....................................................................................210 Conditional A.12.5 
Control.......................................................................................................211 Line A.12.6 
Generation.................................................................................................211 Error A.12.7 
Pragmas..............................................................................................................212 A.12.8 
directive......................................................................................................212 Null A.12.9 
names.............................................................................................212 Predefined A.12.10 
Grammar....................................................................................................................212 A.13 
- B Standard Library..............................................................................................220 Appendix 
and Input Output: <stdio.h>........................................................................................220 B.1 
Operations.....................................................................................................220 File B.1.1 
Output..................................................................................................222 Formatted B.1.2 
Input....................................................................................................223 Formatted B.1.3 
Output Functions..................................................................225 and B.1.4 Input Character 
Output Functions.......................................................................225 and B.1.5 Input Direct 
Positioning Functions....................................................................................226 B.1.6 File 
Functions.....................................................................................................226 Error B.1.7 
Class Character Tests: <ctype.h>................................................................................226 B.2 
Functions: <string.h>........................................................................................227 B.3 String 
Functions: <math.h>.............................................................................228 B.4 Mathematical 
Functions: <stdlib.h>.......................................................................................229 B.5 Utility 
<assert.h>................................................................................................231 Diagnostics: B.6 
Argument Variable Lists: <stdarg.h>..........................................................................231 B.7 
Jumps: <setjmp.h>......................................................................................232 B.8 Non-local 
<signal.h>......................................................................................................232 Signals: B.9 
Functions: <time.h>..........................................................................233 Time B.10 and Date 
and <float.h> <limits.h> B.11 Limits: Implementation-defined 
...........................................................................................................................................234 
of Summary  C Changes......................................................................................236 - Appendix 


Preface 

publication undergone revolution The computing since has The C of a the world 
in and personal Big Language much bigger, Programming 1978. are computers computers 
has decade this changed During C too, ago. capabilities have of mainframes rival that a time, 
of and the as language spread only it has modestly, UNIX beyond origins its far the although 
system. operating 

the of creation the and changes growing C, the popularity of the over language in years, The 
for design, demonstrate a to need more combined by compilers in involved not groups its a 
this contemporary than of edition precise and definition of first the the language book more 
1983, established a American In Institute (ANSI) provided. the Standards committee National 
was definition of produce goal and machine-independent whose to unambiguous the ``an 
for still result standard ANSI language C'', retaining its the spirit. is The C. while 

formalizes constructions edition, that were first but the in hinted The not standard described 
assignment form of enumerations. structure a new particularly and provides function It 
specifies of with declaration that use. cross-checking standard library, a definition It permits 
and of for with an performing set memory management, output, functions input extensive 
were similar the that features string manipulation, tasks. It of makes behavior precise not and 
which at time aspects same explicitly of the out spelled definition, original the in and states 
remain machine-dependent. the language 

the of describes by defined This Second The C as Programming C Language ANSI Edition 
have have the we evolved, standard. Although noted the has places language where chosen we 
no For part, significant most makes difference; the write to new the in exclusively form. this 
visible change Modern is the definition. form and declaration new the of most function 
of already the features compilers support standard. most 

it brevity not of big the to language, have and C retain tried edition. is We first not is a the 
features, have exposition such the critical as improved served well book. big a by We of 
and central have examples, original pointers, that to C the programming. refined We have are 
examples treatment of several new instance, the added in For complicated chapters. 
words programs convert declarations is declarations by vice versa. and that into augmented 
in examples from is which As before, have been text, tested the directly machine-readable all 
form. 

convey reference standard, to attempt Appendix A, manual, is our not but the the the 
comprehension standard It easy for essentials of in a meant smaller is space. by the 
belongs compiler that to -- properly the writers but programmers, definition a as not for role 
It B too the library. summary itself. is a Appendix is the of facilities of standard standard 
reference by of programmers, not summary Appendix concise a implementers. meant C for is 
original version. the the from changes 

C in ``wears it said As the edition, preface experience the one's we to with well first as 
this decade book We that we With more experience, a will feel way. that still hope grows''. 
use you it and help learn well. C 

 
edition. helped produce Jon to second Bently, us are We friends to indebted deeply who this 
Doug McIlroy, on Peter Nelson, comments Rob perceptive us and Doug Pike Gwyn, gave 
Al are careful Aho, for by Dennis grateful every almost manuscripts. draft of page We reading 
Campbell, Andrew Hume, Emlin, Joe Allen Holub, Allison, G.R. Fortgang, Dave Karen 
Linderman, Dave received Prosser, Gene also and We Wyk. Spafford, Kristol, Chris John van 
from Robin Lake, Cheswick, suggestions Andy Koenig, helpful Bill Kernighan, Tom Mark 
Reeds, Prosser answered Tondo, Jim Weinberger. Dave London, Clovis Peter many and 
about Stroustrup's C++ ANSI questions used Bjarne detailed the We translator standard. 
an and provided ANSI Kristol with C Dave for extensively our of testing local programs, us 
helped for testing. compiler with greatly Rich final typesetting. Drechsler 



thanks sincere to all. Our 

Kernighan W. Brian 
Ritchie M. Dennis 

 


the to first edition Preface 

a of expression, programming is features economy C general-purpose with modern language 
operators. data C level'' and flow rich of and ``very structures, a control a high is set not 
application. ``big'' But particular of is nor one, and a its specialized any to not area language, 
restrictions and many its generality for it effective and make absence more of convenient 
powerful languages. more tasks supposedly than 

the designed the on system C was for and operating implemented UNIX on DEC originally 
Dennis Ritchie. UNIX The operating all the essentially and system, PDP-11, C by compiler, 
written all to are book) applications programs of the this software prepare used in (including 
including exist several C. Production other also IBM System/370, the for machines, compilers 
particular C tied hardware not any or is Honeywell the Interdata the and 6000, 8/32. to 
change write will on that without any programs however, system, easy is it and to run 
supports C. machine that 

to meant program tutorial is This reader how help contains to It book the a in learn C. 
each new as on chapters introduction to users started separate as possible, soon major get 
writing reference treatment reading, on feature, and manual. Most based of is the and a 
the than rules. part, most revising examples, on mere the statements For of examples rather 
examples rather isolated are complete, fragments. programs been tested have than All real 
the text, make which is to machine-readable how showing in directly form. from Besides 
useful the tried illustrate to effective use language, we possible have where also algorithms of 
and principles sound style and of design. good 

is not basic an introductory with manual; familiarity some programming The it book assumes 
and statements, loops, functions. programming concepts variables, like assignment 
the programmer read up pick Nonetheless, a should be and able along to language, novice 
colleague access will knowledgeable although to help. more 

for C a and language to our has proven experience, wide a expressive pleasant, be versatile In 
on's easy it to of wears We with grows. well learn, variety is programs. it It and experience as 
use that to it well. this will book help you hope 

colleagues suggestions many The thoughtful friends and added greatly have of and criticisms 
Jim and Blue, particular, Bianchi, pleasure this to our book Stu writing In it. in Mike to 
McIlroy Bill volumes Roome, Bob multiple and read all Rosin Feldman, Larry Doug Rosler 
Chuck Al Bourne, Haley, Steve Dvorak, Debbie Aho, care. with indebted also are We to Dan 
Bob Holt, Johnson, Haley, Marion John Rick Ralph Muha, Mitze, Steve Mashey, Harris, 
Elliot Thompson, and Bill Nelson, Spivack, Ken Peter Pinson, Jerry Peter Plauger, 
Ossanna comments to Joe and Weinberger for at various Lesk stages, Mile and for helpful 
with typesetting. invaluable assistance 



Kernighan W. Brian 
Ritchie M. Dennis 

 


Tutorial Introduction A Chapter - 1 

show quick elements introduction us aim the essential of is in Let a begin Our with C. the to 
real programs, exceptions. but without and bogged rules, details, getting language down in in 
or we even are point, At to complete not the are that this trying examples precise be (save 
to want where to to quickly can point you as get meant We be as correct). you the possible 
basics: we concentrate variables to the and have useful write do to and programs, that on 
control flow, are functions, and We rudiments output. and the constants, of arithmetic, input 
writing of C for important intentionally leaving this chapter are features that of bigger out 
include pointers, control- structures, most several C's operators, of of programs. rich These set 
standard library. the flow and statements, 

any its that on story This approach drawbacks. Most complete notable the is particular and 
be tutorial, brief, misleading. being also And by is feature and here, found not the may 
not use and the the C, as concise elegant they full because not examples of do power as are 
Another minimize but drawback effects, warned. is these might they tried have We be. to be 
the will this that hope that later necessarily repeat We some chapter. of repetition chapters 
than more annoys. help it you will 

in experienced to material the In any programmers should from be extrapolate able this case, 
it programming Beginners chapter to should own writing small, by needs. supplement their 
as their a the of similar can it Both to own. which programs groups hang framework use on 
in detailed Chapter begin more descriptions 2. that 

Started Getting 1.1 

it. to The writing in new only learn a way first language by is programming programs The 
all same for languages: program to is write the 
words the Print 
world hello, 

it to leap able the program big create hurdle; have text be is This to a somewhere, to over you 
went. and where With out output these find it compile run it, load successfully, it, your 
is details comparatively else mechanical mastered, easy. everything 

world'' print ``hello, is In C, program the to 



<stdio.h> #include 



main() 

{ 

world\n"); printf("hello, 

} 



you run are on to Just on system program specific this a how depends example, using. the As 
ends system in file name create UNIX you must operating ``.c'', program a in the whose the 
the it with command such as then hello.c, compile 



hello.c cc 



 
haven't botched the anything, such something, omitting misspelling or as If a you character 
run silently, file you If compilation will and make a.out. an called executable a.out proceed 
the command by typing 



a.out 

print will it 



world hello, 

with rules be On other different; the local expert. a will check systems, 

size, explanations A its whatever Now, for about the program, program C itself. consists some 
and specify the A functions statements that of variables. contains computing function 
functions done, used C computation. operations to and variables the store during values are be 
Pascal. and the of functions like the functions in and Fortran procedures or Our subroutines 
functions function are give to example is named main. liberty Normally at you whatever a 
the - begins beginning program at of your you names is ``main'' but like, special executing 
a This have main somewhere. means every that program must main. 

wrote, call and some you to will other functions usually others perform job, its help that main 
line provided you. from libraries The are the program, of for first that 



<stdio.h> #include 

input/output include about tells the the to the line library; information standard compiler 
described source standard in The is Chapter files. at appears many of beginning the C library 
Appendix B. 7 and 

provide communicating for to function One method data between calling functions the is a of 
the called it after parentheses list of arguments, to The the calls. function function values, 
function argument that to a this surround list. In the expects main defined is example, be name 
list arguments, empty ( ). which indicated is by the no 

--- 




about standard information #include include <stdio.h> 
library 

called main function main() a define 

no received argument values that 

enclosed statements in are { of braces main 

library calls printf world\n"); function main printf("hello, 

of characters sequence to this print 

newline character the } represents \n 

C program The first 



contains a only The main enclosed statements function are of one braces }. { in function The 
statement, 



world\n"); printf("hello, 

 
so called this list arguments, it, function by naming is calls by parenthesized a followed of A 
printf with that the argument function world\n". library a "hello, the printf function is 
in between the case output, of characters prints this string quotes. the 

of characters character in double a like called is quotes, A "hello, sequence world\n", 
will our of be use strings as only or string the For constant. string moment character 
other functions. and arguments printf for 

which C the when for character, printed notation sequence The string the in \n is newline 
leave left \n margin the line. worthwhile the (a If on advances the output next to the out you 
printed. find You the is is you that there will must line after advance no output experiment), 
try in argument; something printf you like the \n use newline a include to character if 



world printf("hello, 

"); 

an C error produce the compiler message. will 

supplies a to newline character used so be may automatically, printf several never calls 
have output been just well stages. up line in an written first could program Our as build 



<stdio.h> #include 



main() 

{ 

"); printf("hello, 

printf("world"); 

printf("\n"); 

} 

identical output. to produce 

provides represents An \n like Notice that only a sequence single escape character. a \n 
hard-to-type and mechanism general invisible or for extensible characters. representing 
\b that for quote others Among \t tab, provides the C for the are double backspace, for \" 
for the 2.3. backslash itself. Section is in list There and a \\ complete 

system. ``hello, program Exercise 1-1. on the with leaving Experiment world'' your Run 
of messages you program, parts what error out the see get. to 

prints's find what Exercise 1-2. happens to string contains argument out when Experiment 
listed character not above. \c, where is c some 

and Variables Arithmetic Expressions 1.2 

program uses Fahrenheit the formula of to table following oC=(5/9)(oF-32) The print next the 
or centigrade equivalents: and Celsius their temperatures 

 


-17 1 

-6 20 

4 40 

15 60 

26 80 

37 100 

48 120 

60 140 

71 160 

82 180 

93 200 

104 220 

115 240 

126 260 

137 280 

148 300 

It still is function main. the program consists of itself longer of single a definition named The 
one that new printed ``hello, several but introduces It world'', than not the complicated. 
expressions, including declarations, ideas, , loops variables, comments, and arithmetic 
output. formatted 



<stdio.h> #include 



Fahrenheit-Celsius table /* print 

..., fahr 300 20, for = */ 0, 

main() 

{ 

celsius; fahr, int 

upper, step; int lower, 



of = /* lower scale temperature lower 0; */ limit 

upper /* */ = limit 300; upper 

step /* */ = size 20; step 



lower; = fahr 

<= (fahr upper) { while 

(fahr-32) * 9; = / 5 celsius 

celsius); fahr, printf("%d\t%d\n", 

fahr = + step; fahr 

} 

} 

lines two The 



Fahrenheit-Celsius table /* print 

..., fahr 300 20, for = */ 0, 

Any which briefly does. program are a in this the case what explains characters comment, 
may */ be program and between the they ignored make are to /* by a used compiler; freely 
understand. Comments can. may appear newline where or tab anywhere easier a to blank, 

beginning variables of usually the declared C, must be all the they used, are before at In 
the before announces properties of any statements. executable A declaration function 
of a and variables; it a of such as variables, name list consists 



celsius; fahr, int 

upper, step; int lower, 

float, means are with contrast The type that the by variables integers; listed which int 
both i.e., int The of may floating numbers that point, and a part. fractional have range means 
-32768 the 16-bits between lie float depends machine you which are ints, using; and on 

 
32-bit A is quantity, number a with float are +32767, 32-bit are as common, ints. typically 
about digits magnitude at least generally significant and 1038. 10-38 and between six 

and provides int float, including: several data other types besides C 

char 

a - single byte character 

short 

integer short 

long 

integer long 

double 

point floating double-precision 



of these and objects is structures machine-dependent. arrays, also also The There size are 
of basic which return all to of types, pointers these we and that functions them, them, unions 
in meet due course. will 

the in with assignment statements the conversion temperature program begins Computation 



0; = lower 

300; = upper 

20; = step 

statements to initial which set values. variables terminated by are their Individual the 
semicolons. 

same is computed a repeats once the that table so per use line Each we of output loop the way, 
while of the loop line; this the is purpose 





<= (fahr upper) { while 

... 

} 

is operates true tested. it The while as follows: loop (fahr in is parentheses condition If The 
the or loop braces) than is the of to enclosed equal statements less upper), in (the body three 
again. the When body executed re-tested, executed. condition is Then the if the true, and is is 
false (fahr the exceeds upper) at loop continues execution the test ends, becomes and 
so the further program, this statement that loop. There in are statements no it follows 
terminates. 

statements a enclosed temperature of The one more can in while as body be the in or braces, 
as without braces, in converter, or single a statement 



< j) while (i 

2 = * i; i 

one we tab the by indent either will always case, stop statements by controlled the while In 
see shown at inside have (which so can four statements as which we spaces) are a you glance 
the emphasizes logical the loop. structure indentation Although C program. the of The 
are care looks, spacing and compilers do about how indentation a proper program critical not 
statement easy We one only in making for people writing to recommend read. per programs 
is blanks grouping. braces of line, and around operators position to The clarify less using 
one passionate We important, although have hold several popular of beliefs. chosen people 
use Pick then it consistently. a that style suits you, styles. 

 
the work loop. and the Most the of done is gets temperature of in computed The body Celsius 
by to the celsius assigned the statement variable 



(fahr-32) * 9; = / 5 celsius 

multiplying 5 is and reason instead in 5/9 that of dividing The by for 9 multiplying by by just 
other languages, many C, in as 
ligr comment (Highlight 
18:32:53 29.10.2007 
blank) 
part division is fractional integer truncates: discarded. any 
to 9 zero temperatures and Since would truncated integers. the are all 5 5/9 Celsius and be so 
reported be as zero. would 

a shows how is printf This example a bit works. more printf of general-purpose also 
first in Chapter argument in Its is detail formatting output will we which function, describe 7. 
the characters other where of printed, string to be of (second, each indicating % with one a 
to be For substituted, ...) form %d printed. instance, it and third, to arguments what is in be is 
so argument, statement an the integer specifies 



celsius); fahr, printf("%d\t%d\n", 

to of be between values causes fahr celsius two tab the a the integers (\t) printed, and with 
them. 

corresponding in printf the with Each % the first paired argument is of second construction 
or up number you by type, will properly third argument, must they etc.; argument, match and 
answers. wrong get 

the not part no output defined printf or is language; in is the By there way, C input of C 
that from library are standard functions normally the printf itself. useful a just is function of 
standard, programs. is ANSI the accessible to The behaviour in of defined printf however, C 
conforms with and to compiler that the any its so the be should properties same library 
standard. 

much concentrate about 7. to In we talk C until on output order itself, chapter input don't and 
numbers, will read have input input particular, defer formatted we the then. you If until to In 
that 7.4. like it is except reads scanf of discussion in scanf function the Section printf, 
of instead writing output. input 

one couple temperature simpler The There are of problems program. with conversion the is a 
easy the not to are That's fix; numbers the that pretty very isn't output because right-justified. 
printed each will width, numbers the we %d in augment be statement a with printf the if 
might instance, we say right-justified in fields. their For 



fahr, celsius); printf("%3d %6d\n", 

a each wide, line the in first second print in three number the field digits to a six field and of 
like this: digits wide, 



-17 0 

-6 20 

4 40 

15 60 

26 80 

37 100 

... 

 
serious problem Celsius is that the we arithmetic, integer because The have more used 
-17. 0oF about To actually not get is are temperatures for accurate; very not instance, -17.8oC, 
answers, of integer. should accurate arithmetic instead more we floating-point This use 
the some is second version: changes the in program. Here requires 



<stdio.h> #include 



Fahrenheit-Celsius table /* print 

300; fahr 0, for version floating-point 20, = */ ..., 

main() 

{ 

celsius; fahr, float 

upper, step; float lower, 



of = /* lower scale temperatuire lower 0; */ limit 

upper /* */ = limit 300; upper 

step /* */ = size 20; step 



lower; = fahr 

<= (fahr upper) { while 

(5.0/9.0) = * (fahr-32.0); celsius 

fahr, celsius); printf("%3.0f %6.1f\n", 

fahr = + step; fahr 

} 

} 

and the celsius and much This except fahr as be same to is before, float are that declared 
unable written 5/9 in formula way. the use in We a the is for natural conversion more to were 
in integer to point decimal previous version division would A truncate zero. it a because 
because however, is it 5.0/9.0 truncated is so indicates constant floating is it that point, not 
floating-point values. two the of ratio 

arithmetic operator an has integer If an performed. is operands, If integer an operation 
has operand, however, floating-point operator one integer arithmetic one and the operand 
we before is had operation If written the will integer floating to converted be point done. 
32 point. Nevertheless, be the to floating (fahr-32), would converted writing automatically 
with have integral decimal constants when they floating-point explicit even values points 
for nature readers. their human floating-point emphasizes 

2. for For are Chapter are detailed when integers rules now, to point floating converted in The 
the assignment notice that 



lower; = fahr 

test the and 



<= upper) while (fahr 

converted the to done. in also the is way operation natural the work - is float int before 

number %3.0f that The printf a specification fahr) is (here says floating-point conversion 
no wide, decimal fraction no and digits. with be to three least at printed characters point 
characters number be six least %6.1f describes (celsius) that at is printed to wide, another 
digit looks like the 1 The output with after point. this: decimal 

-17.8 0 

-6.7 20 

4.4 40 

... 

 
says may that at precision Width a %6f omitted to be is and from be the specification: number 
the wide; after but point, least six %.2f specifies decimal two the characters width characters 
constrained; and point. %f merely floating to as number says is print not the 

%d 

decimal integer print as 

%6d 

characters least 6 wide print as integer, decimal at 

%f 

floating point print as 

%6f 

characters least 6 wide print as point, floating at 

%.2f 

decimal characters after point print as point, floating 2 

%6.2f 

2 at 6 print as wide point, decimal point after least and floating 



character, also %x for %c Among others, recognizes %o hexadecimal, for for octal, %s printf 
%% and itself. character for string for 

Modify the table. temperature conversion the to above heading program Exercise print 1-3. a 

Celsius program print Exercise 1-4. the a Fahrenheit table. to to corresponding Write 

for statement 1.3 The 

for of a variation plenty There write program ways try different Let's are to a particular a task. 
temperature converter. on the 



<stdio.h> #include 



Fahrenheit-Celsius print table */ /* 

main() 

{ 

fahr; int 



= fahr + fahr (fahr fahr = for 0; 300; 20) <= 

fahr, (5.0/9.0)*(fahr-32)); printf("%3d %6.1f\n", 

} 

is same looks change major This produces answers, but One it different. certainly the the 
an of int. have it only of the variables; most The remains, we and fahr made elimination 
as limits constants a upper lower size only the statement, and for and step itself in appear the 
temperature expression computes new construction, the the appears as now that Celsius and 
separate third a assignment statement. argument printf of instead of the 

general instance of context is permissible is it an - to any last This in change use where a rule 
type. some Since expression that can value type, you of the a complicated more use of the 
any printf value %6.1f, the third argument must be match a to floating-point floating- of 
can expression occur here. point 

while. is If earlier statement The generalization the loop, to a it for a the you of compare 
operation should separated be clear. parts, the three are Within while, parentheses, its there 
part, first initialization semicolons. the The by 



0 = fahr 

 
once, before the the loop is is part second proper is entered. done The 
controls that loop: or the condition test 



300 <= fahr 

of evaluated; the is is This true, body it single if a condition is ptintf) loop the (here 
the Then increment step executed. 



fahr = + 20 fahr 

and the become condition re-evaluated. has loop condition the The is terminates executed, if 
single the a body As can of or group be of false. while, with loop the the statement a 
in can be The enclosed and increment statements braces. condition any initialization, 
expressions. 

The arbitrary, which for on clearer. is based choice The for and while between is seems 
increment in the usually appropriate initialization loops single statements are which and for 
the compact and loop while keeps control than logically and is it since related, more it 
in together one place. statements 

Modify the order, temperature conversion reverse to in table program Exercise print 1-5. the 
degrees 300 0. is, to from that 

Constants Symbolic 1.4 

observation before bury we leave to conversion practice bad temperature A forever. final It's 
to 300 program; information little ``magic numbers'' and 20 convey in they a someone like 
are to hard way. have who later, they the a read in might program systematic to and change 
A is them #define give names. line to way One magic with deal to numbers meaningful 
symbolic name characters: or symbolic of to string particular constant defines be a a 

replacement list #define name 

name) quotes part will not another be and any Thereafter, (not name of occurrence in of 
a corresponding has as form replaced by replacement text. same The the name variable the 
text of can letter. replacement digits a letters and sequence be begins a with that The name: 
not sequence characters; any to limited it of numbers. is 



<stdio.h> #include 



table limit of */ #define LOWER /* 0 lower 

upper /* */ UPPER limit 300 #define 

step /* */ STEP size 20 #define 



Fahrenheit-Celsius print table */ /* 

main() 

{ 

fahr; int 



= fahr + fahr (fahr fahr = for LOWER; UPPER; STEP) <= 

fahr, (5.0/9.0)*(fahr-32)); printf("%3d %6.1f\n", 

} 

do UPPER constants, they so The quantities and STEP variables, are not symbolic not LOWER, 
in constant are appear in conventionally Symbolic case so upper names written declarations. 
is readily variable there that they can distinguished from Notice lower names. case no ber 
a at #define of semicolon the line. end 

 
Input Character and Output 1.5 

data. of for You programs character will related are We a consider to going family processing 
discuss programs of we that find that are just prototypes expanded the versions here. many 

Text input input is simple. supported model and output of or the library standard by very The 
as where streams is with or regardless it originates of of it to, goes where dealt output, 
line of into consists divided each of characters A characters. a is stream text sequence lines; 
of newline is the It responsibility library character. or zero by followed characters more a the 
using confirm the the model; programmer library this make to output or input each stream C 
outside not represented the program. worry how about lines are need 

a provides or at character The standard several functions one for writing reading time, library 
getchar simplest. it reads time called, the Each which of are putchar and getchar the is 
That and as is, that value. after returns input next text a from character stream its 



getchar(); = c 

from contains input. come normally the variable the next characters character The of the c 
Chapter discussed in 7. keyboard; input files from is 

it function time is called: putchar a prints character each The 



putchar(c); 

screen. of Calls usually the variable the the integer contents to as character, a c on prints 
which may the the in the and be interleaved; printf calls will in appear output order putchar 
made. are 

Copying File 1.5.1 

and putchar, without you can code a useful of write Given surprising getchar amount 
more about that input and program The a is output. knowing simplest anything example 
at its character a time: input its to output one copies 



character a read 

end-of-file indicator) not while is (charater 

character the just read output 

character a read 

into this C gives: Converting 



<stdio.h> #include 



1st copy version output; /* input */ to 

main() 

{ 

c; int 



getchar(); = c 

!= (c EOF) { while 

putchar(c); 

getchar(); = c 

} 

} 

``not relational equal means The operator to''. != 

 
like be everything is course, on appears a character to else, keyboard screen or the of What 
for The is storing char meant such type internally stored bit a as just pattern. specifically 
subtle any but int a can data, integer type but important used. used We be for character 
reason. 

is input data. that valid solution getchar from problem The end the distinguishing is of The 
be value confused value cannot is a when there distinctive with more a input, no that returns 
for is called must to be This c value of a We real any file''. character. type declare EOF, ``end 
can't hold use big to big getchar We value must any c enough that be char returns. since 
hold EOF int. in addition use any we Therefore to enough possible to char. 

as integer long value matter <stdio.h>, is defined in an as the numeric specific but doesn't EOF 
using the the that not it char By as are same we is any assured symbolic value. constant, 
the in program nothing numeric specific depends the value. on 

for copying In would be programmers. more C experienced written The concisely program by 
assignment, any such as C, 



getchar(); = c 

left a after value, an value assignment. side the of which is has expression the and is hand the 
a a larger a that This as of can assignment assignment the means appear of expression. part If 
part inside the the can be is program put a written loop, to character while c this copy test of 
way: 



<stdio.h> #include 



2nd copy version output; /* input */ to 

main() 

{ 

c; int 



!= EOF) getchar()) while = ((c 

putchar(c); 

} 

then a tests end- gets The to and assigns was character, character while it the whether c, the 
the it character. is printing the signal. was not, If The of while the body executed, of-file 
terminates When and reached, while of then the end repeats. so input finally is the the while 
main. does 

- the and reference getchar there version input - centralizes shrinks now one only is to This 
mastered, resulting and, is idiom the program. program is the more once compact, easier The 
and (It's get create to away impenetrable possible read. to style this see You'll often. carried 
will however, tendency code, to try that a curb.) we 

around necessary. The assignment, parentheses condition are The the the precedence within 
that higher in relational is of =, means that parentheses than of != of the the which absence 
would So the done != assignment =. test be the statement before 



getchar() = != EOF c 

to equivalent is 



(getchar() = != EOF) c 

 
to of setting on not the undesired or effect or call depending has This 1, the of whether c 0 
in returned this Chapter 2.) end file. of (More on getchar 

is the getchar() Exercsise 1-6. != that or 1. 0 expression EOF Verify 

value 1-7. the of EOF. Write program a to print Exercise 

Counting Character 1.5.2 

program the copy characters; next similar to The counts is program. it 



<stdio.h> #include 



1st count version input; /* characters */ in 

main() 

{ 

nc; long 



0; = nc 

!= EOF) while (getchar() 

++nc; 

nc); printf("%ld\n", 

} 

statement The 



++nc; 

nc operator, = could write means a ++, which new nc by You one. increment instead presents 
corresponding ++nc operator There a concise 1 is more but -- often efficient. more and is + 
(++nc) 1. or either operators ++ decrement The operators by postfix -- be can and prefix to 
shown two in be will operators (nc++); forms have as different expressions, values in these 
the ++nc moment the but Chapter increment For nc++ stick and will 2, both to we nc. will 
form. prefix 

an program a of instead The character accumulates its variable count long in int. counting 
are at the int long bits. integers least 32 are same on machines, some Although and long 
32767, is would 16 on maximum relatively it take value bits, size, int others a an with and of 
that overflow conversion printf tells little input an int %ld counter. specification The the to 
long integer. a corresponding is argument 

double even by (double numbers a precision bigger may It cope to possible be with using 
a also while, write will float). statement of a way use another We for to to instead illustrate 
loop. the 



<stdio.h> #include 



2nd count version input; /* characters */ in 

main() 

{ 

nc; double 



!= (nc EOF; gechar() for = ++nc) 0; 

; 

nc); printf("%.0f\n", 

} 

 
the double; the decimal suppresses of point %.0f uses printf float both for %f and printing 
which part, zero. the is fraction and 

done loop test is body the increment the and work empty, The for of all this because in is 
body. grammatical The statement a C But rules of the isolated that for a require have parts. 
on null a We it there called statement, is a separate satisfy requirement. that to put semicolon, 
make to it visible. line 

leave the no character counting contains observe input the program, Before that we if 
and or the call getchar, fails the for test while program the first very on to characters, 
about important. the while of things and One zero, produces This answer. right the is nice 
of at the with If there they body. test loop, is proceeding is for before that nothing the top the 
loop that going body. never the Programs means do, to even done, is nothing if through 
and given input. should act The when statements help for zero-length while intelligently 
boundary things with conditions. ensure that do programs reasonable 

Counting Line 1.5.3 

program counts ensures input lines. library we standard the As The mentioned next above, 
a text newline. each by as an stream appears input Hence, sequence lines, of a terminated that 
counting newlines: just counting is lines 



<stdio.h> #include 



input */ in /* lines count 

main() 

{ 

nl; c, int 



0; = nl 

!= EOF) getchar()) while = ((c 

== '\n') if (c 

++nl; 

nl); printf("%d\n", 

} 

which the in The of The of if, now increment while the body consists ++nl. turn an controls 
tests the the parenthesized condition, executes if true, is and if the statement condition 
to of follows. indented again statement (or statements in have braces) We that show group 
controlled is by what. what 

``is sign equal or equals The C for is single == Pascal's double the = to'' notation (like 
= symbol that from single to .EQ.). is used This C the test equality distinguish the Fortran's 
when A to = write uses for word of occasionally caution: C newcomers they assignment. 
2, see in a so you we expression, will result will usually ==. mean is As get legal Chapter the 
warning. no 

written between numerical single quotes the an to equal represents A integer character value 
character character set. a called value of in the is machine's This character constant, the 
integer. just So, character is although write small way is another 'A' it to a for a example, 
of value the the 65, representation character is in constant; set character ASCII the its internal 
over to be obvious, is independent 'A' it is its of is Of A. meaning course, a and preferred 65: 
set. character particular 

 
so used also constants, character The escape in string in constants legal are '\n' sequences 
should value note in You newline for of the the carefully which 10 is character, ASCII. stands 
on character, hand, and '\n' just is other '\n' an in that single is is a expressions the integer; 
strings that one of topic a string happens to The contain character. only versus constant 
in further 2. is Chapter discussed characters 

tabs, 1-8. blanks, and newlines. Write program a to count Exercise 

its a output, or Write Exercise its to to of program string 1-9. copy one replacing input each 
single blank. a more by blanks 

its a output, each Write Exercise its to to by program tab 1-10. copy \t, replacing input each 
visible \\. tabs in makes backspaces an This by backspace backslash each and \b, by and 
way. unambiguous 

Counting Word 1.5.4 

with programs words, the lines, characters, loose counts fourth The of series our in useful and 
blank, word tab not a sequence that is any a or characters does that of contain definition 
UNIX This the program wc. is bare-bones a version of newline. 



<stdio.h> #include 



a IN word inside #define 1 */ /* 

a OUT word outside #define 0 */ /* 



input characters in */ /* count words, lines, and 

main() 

{ 

nc, state; nw, int nl, c, 



OUT; = state 

nc = 0; = = nw nl 

!= getchar()) { ((c EOF) = while 

++nc; 

== '\n') if (c 

++nl; 

|| ' c if (c == ' = '\t') c || '\n' == 

OUT; = state 

OUT) { == else (state if 

IN; = state 

++nw; 

} 

} 

nw, nc); nl, printf("%d %d\n", %d 

} 

more program word. it one first time encounters the the The of word, a character counts Every 
word whether or in records variable currently a program is the it state is ``not not; in initially 
the is symbolic the which a OUT. prefer the OUT assigned and word'', value to constants We IN 
more and readable. as 1 literal make program because as 0 program values they tiny In the a 
well little worth in is in it difference, but makes the programs, increase the larger clarity this, 
beginning. to You'll to effort modest way the it it's write that extra this easier also from find 
changes only as programs extensive numbers appear make in magic symbolic where 
constants. 

 
line The 



nc = 0; = = nw nl 

not zero. This a the fact variables of to special that but all sets case, three an consequence is a 
left. expression assignments to right assignment is with the from value associated and It's an 
we if had written as 



(nc = 0)); = = (nw nl 

so operator the OR, The || line means 



|| ' c if (c == ' = '\t') c || '\n' == 

that is or c a ``if a says escape tab''. c a a c (Recall is newline \t sequence or is the blank is 
AND; the a for && visible representation tab character.) operator There corresponding is its of 
evaluated connected or left && are to by is precedence ||. than higher just Expressions || 
soon is as known. it right, will as that falsehood guaranteed or and evaluation is the stop truth 
newline are these is If it whether test is no there c or blank, tab, need a is a tests to not so 
in important but made. This is particularly complicated situations, more here, significant isn't 
will we soon see. as 

condition specifies action part alternative the of an example The else, an shows also which if 
form The general is an if is statement false. 



(expression) if 

statement1 

else 

statement2 

performed. statements an If with is the associated and One the of one only two if-else 
true, statement1 can is executed; statement not, Each executed. if expression statement2 is is 
the several the in a word is after else count braces. be or single the statement In one program, 
statements if in two an that braces. controls 

input word What are program? of most count 1-11. Exercise test you would How the kinds 
there to are if likely uncover any? bugs 

one program prints Exercise 1-12. its a per line. word that input Write 

Arrays 1.6 

of a white of digit, count is program to write space number occurrences of the each Let 
it other is permits This but us characters. (blank, characters of and newline), tab, all artificial, 
one C in program. to illustrate aspects several of 

array input, the so are to of hold number use it There of twelve convenient categories is to an 
of digit, variables. version one occurrences of rather than is ten Here individual the each 
program: 

 


<stdio.h> #include 



space, white */ count others digits, /* 

main() 

{ 

i, c, nwhite, nother; int 

ndigit[10]; int 



nother = = 0; nwhite 

< (i 10; i for = ++i) 0; 

0; = ndigit[i] 



!= EOF) getchar()) while = ((c 

c (c <= && if >= '9') '0' 

++ndigit[c-'0']; 

(c == '\t') ' ' == c c || || else == if '\n' 

++nwhite; 

else 

++nother; 



="); printf("digits 

< (i 10; i for = ++i) 0; 

ndigit[i]); %d", printf(" 

other white = %d, printf(", space %d\n", = 

nother); nwhite, 

} 

on output itself program The of is this 



space 0 other 0 = 0 345 123, = 1, 0 digits 0 9 0 3 0 = white 

declaration The 



ndigit[10]; int 

subscripts be always so to declares 10 Array array in an zero ndigit of C, start integers. at 
reflected ndigit[1], ndigit[9]. the elements This ndigit[0], the for in ..., is are 
print and array. that the initialize loops 

and be includes i, like A subscript any integer variables expression, integer which integer can 
constants. 

program relies digits. on the the of of representation properties This the particular character 
the test For example, 



c (c <= && if >= '9') '0' 

numeric c that is whether it is of digit is, a determines in the If character digit. value the 



'0' - c 

consecutive '0', ..., This works '9' if values. Fortunately, increasing '1', have only 
all for sets. is character true this 

identical are char are constants By definition, just small and integers, variables so to chars 
arithmetic expressions. an This is is and c-'0' example natural ints convenient; in for 
'0' and to to corresponding character '9' 9 expression integer between value a with 0 the 
c, the array thus in subscript for stored and valid ndigit. a 

white to space, with as The is digit, a is whether else decision character made or a something 
sequence the 

 


c (c <= && if >= '9') '0' 

++ndigit[c-'0']; 

(c == '\t') ' ' == c c || || else == if '\n' 

++nwhite; 

else 

++nother; 

pattern The 



(condition1) if 

statement1 

(condition2) if else 

statement2 

... 

... 

else 

statementn 

conditions programs express The decision. occurs frequently as a multi-way way a to are in 
point from condition that at evaluated in the top satisfied; until is some the order 
part is finished. executed, statement entire construction corresponding is the (Any and 
is several If conditions the statement can statements enclosed of in none braces.) satisfied, be 
is the present. statement after the executed it else else final final statement is and If if the 
takes in place. of as are program, action word any the be omitted, count number There no can 

if(condition) else 
statement 

final and the else. groups between initial the if 

we it if is a this if shown; each construction advisable As style, matter format of to have as 
off long decisions the of march right sequence indented were else, previous the past a would 
the page. side of 

write Chapter another a provides to multi- 4, switch The discussed be to statement, in way 
that is or particulary suitable integer the some whether when way condition branch is 
present of contrast, a For will switch constants. expression character a of one matches set we 
in program 3.4. of Section this version 

words to input. print 1-13. the is its It lengths a Exercise program Write of a histogram in of 
more the horizontal; is orientation easy to histogram with vertical the a bars challenging. draw 

different a histogram of frequencies Exercise 1-14. program to the print of a characters Write 
input. its in 

Functions 1.7 

function function in function a In a or equivalent procedure is a C, to or Fortran, subroutine or 
A function can provides a which way computation, some convenient in to Pascal. encapsulate 
properly worrying its then be implementation. without functions, it designed about With used 
done; a job is makes the ignore C how what sue done possible is is to of sufficient. is knowing 
and and see defined function functions easy, efficient; you short will a often called convinient 
some once, because only of piece it just code. clarifies 

 
have have printf, that putchar So far used only and functions getchar like been we 
of now our exponentiation us; provided write few time has it's C for to no own. a Since 
definition us mechanics by the function writing illustrate like operator Fortran, of ** the let of 
n. an the integer function positive of is, value integer m a raise power(m,n) a to to That power 
32. This handles function is it a since routine, not power(2,5) practical is exponentiation 
enough small but only positive it's of illustration.(The standard for integers, good powers 
that contains computes pow(x,y) library a xy.) function 

exercise function it, whole the Here main to and see power can is a the so program you 
once. at structure 



<stdio.h> #include 



m, power(int int n); int 



power test function */ /* 

main() 

{ 

i; int 



< (i 10; i for = ++i) 0; 

power(2,i), power(-3,i)); i, printf("%d %d\n", %d 

0; return 

} 



>= power: n 0 */ raise to base n-th power; /* 

base, power(int int n) int 

{ 

p; i, int 



1; = p 

<= (i n; i for = ++i) 1; 

p = * base; p 

p; return 

} 

this form: has A definition function 



declarations, function-name(parameter if any) return-type 

{ 

declarations 

statements 

} 

several, and source although one or no in definitions Function any in appear can order, file 
files, the appears you program several may source can function files. between split be If in 
is and appears load one, it more but to that it to say if all have than operating an in compile 
both a moment, that assume system matter, language attribute. will For we the functions not 
will same still running programs whatever in file, so the work. have about learned you C are 

in function main, the line power called is twice by The 



power(2,i), power(-3,i)); i, printf("%d %d\n", %d 

to which returns be time integer formatted each call Each to arguments two passes power, an 
as an 2 functions In and an just power(2,i) (Not expression, are. printed. is all and integer i 
integer in Chapter we an this up produce value; take 4.) will 

power itself, of The line first 

 


base, power(int int n) int 

the the the function of that returns. type the declares names, and types parameter and result 
to by power, any used The parameters local for visible power not names its to and are are 
true routines of This also the function: can use other the names conflict. without same is other 
in p: is i the variables i the i to in unrelated power main. and 

in variable the a in list function. named will We for parameter use generally a parenthesized 
formal argument distinction. and actual same are the for argument The sometimes terms used 

Any power main statement. return: The value computes is the returned by to expression that 
return: follow may 



expression; return 

causes a with control, statement expression but return function A a return not need value; no 
the returned a to useful does by of function ``falling the no be value, as to caller, end'' off 
returned calling ignore by can value a function the reaching And brace. right terminating the a 
function. 

of there main is may at a Since is the a You that have statement noticed return main. end 
is may the return like its in effect environment caller, a function it any to other, value in which 
of executed. a which the return was implies normal zero Typically, value program 
conditions. non-zero termination In the values unusual signal or erroneous termination; 
to we from up functions interests of have omitted main return our statements this simplicity, 
return as that status reminder should to a but point, them include will we hereafter, programs 
environment. their 

declaration The 



base, power(int int n); int 

and says returns two arguments is before that power main an function expects that a int just 
the which prototype, with agree int. This is called to a has function definition declaration, 
definition power. any error agree of it of of and an not the uses uses a if do It or function is 
prototype. its with 

optional agree. parameter parameter names names not a function in Indeed, are need 
have we could written prototype, so the for prototype 



int); power(int, int 

are often use documentation names we will Well-chosen good so them. however, 

is between and how C versions functions ANSI note A biggest the history: of change earlier 
would definition the have C, function been of declared are the In defined. and original power 
this: like written 

 


>= power: n 0 */ raise to base n-th power; /* 

version) */ /* (old-style 

n) power(base, 

n; base, int 

{ 

p; i, int 



1; = p 

<= (i n; i for = ++i) 1; 

p = * base; p 

p; return 

} 

types between parentheses, The parameters and named declared before are the their are 
the taken (The function int. of is as the opening parameters undeclared brace; left are body 
as before.) the same 

like power the looked have The declaration at the would beginning program of this: of 



power(); int 

power was could that check No parameter permitted, so readily the not compiler was list 
return Indeed, would to assumed being called since by been default have power an correctly. 
been well have omitted. int, the declaration entire might 

detect of errors a to makes new function prototypes syntax in much for easier it compiler The 
definition The of still style and works old number the their or arguments of types. declaration 
we at strongly new C, in transition but for use least you ANSI a the recommend period, that 
supports compiler that it. form when have you a 

Rewrite the function temperature conversion a of use to program Exercise Section 1.15. 1.2 
conversion. for 

by Value Call 1.8 - Arguments 

to unfamiliar who some programmers used other to aspect One may functions C of be are 
passed C, function languages, particulary arguments In value.'' This ``by all are Fortran. 
temporary called values in arguments means that function is its given of the variables the 
with some than ``call properties seen by different than rather leads This originals. the to are 
called Fortran in the which reference'' languages or with in var Pascal, parameters routine like 
not access the has local a original to copy. argument, 

more is compact usually to however, by an asset, value programs a It liability. not leads Call 
extraneous as conveniently because fewer be treated with variables, can initialized parameters 
a the version of in local example, is routine. makes called that variables For use of here power 
property. this 

0; to power; /* power: n base 2 */ version n-th >= raise 

base, power(int int n) int 

{ 

p; int 



> (p 0; n for = --n) 1; 

p = * base; p 

p; return 

} 

 
is is counted runs n The temporary and as loop used for parameter a that down variable, (a 
i. becomes Whatever for variable is until zero; there it is longer need a no the backwards) 
originally inside called that was no to power has n with. on argument the effect power done 

in is a modify variable arrange necessary, possible to it calling a to function for a When 
a must pointer be (technically address The provide the caller to the to variable of set routine. 
and the access be pointer must variable), called function and the the to parameter declare a the 
in indirectly pointers Chapter 5. through We it. will cover variable 

used arrays. argument, When story an value an the array the The for is of different name as is 
the the there location to the no - is beginning or passed is the of function address array of 
alter elements. the and access copying of By subscripting can this function value, any array 
the the next This of topic of argument array. the section. is 

Arrays Character 1.9 

array type of of common The C the array the of illustrate most in use characters. is To 
set functions of that a them, arrays to manipulate and text write program a let's reads character 
outline and the lines simple is longest. prints enough: The 



another line) while (there's 

the than longest) (it's previous longer if 

it) (save 

length) its (save 

line longest print 

piece program into gets naturally One a divides outline This that clear it makes the pieces. 
controls line, rest the process. another it, saves and the new 

write so them us divide Since be to it Accordingly, nicely, too. things would let that well way 
We getline to to write line the try make of fetch first function a next separate the will input. 
signal other getline a return function useful contexts. At to the has minimum, about in 
would more useful length line, or file; the a to zero the end possible return of if of design be 
never is a because is is of encountered. Zero file valid acceptable return end-of-file an it end 
only text a a containing at length. line has Every newline one even character; least line line 
1. length has 

previous a longest somewhere. find When longer the that be line must we is saved line, than it 
safe second the a to This suggests function, copy, line to new copy place. a 

the a getline is Here Finally, we main program copy. to and control result. need 

 
<stdio.h> #include 

length input line */ #define MAXLINE /* 1000 maximum 



line[], getline(char int maxline); int 

to[], copy(char char from[]); void 



input longest */ print line the /* 

main() 

{ 

line current */ len; length /* int 

far seen so */ int max; maximum /* length 

input current */ line[MAXLINE]; line /* char 

saved longest[MAXLINE]; here line char /* */ longest 



0; = max 

MAXLINE)) getline(line, 0) ((len > = while 

> (len max) { if 

len; = max 

line); copy(longest, 

} 

was (max 0) if line a /* > */ there 

longest); printf("%s", 

0; return 

} 



s, getline: a /* length return line read */ into 

s[],int lim) int getline(char 

{ 

i; c, int 



(c=getchar())!=EOF (i=0; < for c!='\n'; && lim-1 i ++i) && 

c; = s[i] 

== (c '\n') { if 

c; = s[i] 

++i; 

} 

'\0'; = s[i] 

i; return 

} 



copy big enough into copy: to is /* 'from' assume */ 'to'; 

to[], copy(char char from[]) void 

{ 

i; int 



0; = i 

!= '\0') from[i]) while = ((to[i] 

++i; 

} 

which and the program, the The functions copy are of declared beginning at we getline 
one file. in assume contained is 

getline communicate In through a value. of returned a pair main arguments and and 
by the the declared getline, arguments line are 



s[], getline(char int lim); int 

and the the The that which is array, argument, an first is specifies s, integer. second, an lim, 
set of The an of declaration of storage. length is array purpose size supplying a the in aside to 
in necessary uses in array size to getline return is getline an not s its is since main. set 

 
function back power that value send just the the also to line a caller, declares did. as This 
be int; default could it getline returns since int type, is return the omitted. an 

their like used effect are for and copy, functions Some value; useful a return others, only 
no The value states that of no return type value. is is which void, copy explicitly return 
returned. 

end character of zero) the null puts '\0' (the the the whose is value character, at getline 
This mark also the it string by is used of end array to is the creating, of conversion characters. 
string C constant a the language: like when 



"hello\n" 

array C of the a appears stored an it characters program, the in is in characters as containing 
to and with string the mark a terminated end. '\0' 



format specification string in printf a the be to expects The corresponding %s argument 
is form. terminated its argument relies in copy also this with the that fact on input represented 
the character into output. a '\0', copies and this 

one mentioning presents small this that is in passing worth some a as program even as It 
line main it which if a is do design sticky what example, For problems. should encounters 
array limit? is collecting the safely, than getline works its full, that stops it in when bigger 
character newline returned, and last seen. if has been no main testing length the By the even 
cope the as of whether can long, then was the line In determine too interests it and wishes. 
this issue. ignored brevity, have we 

might user how of an getline way input is line in for no know advance There to so be, long a 
(or overflow. can copy knows other checks On the for find the of user hand, already getline 
checking the to to error so how strings are, big it. have not chosen we add out) 

correctly the longest-line will it Exercise 1-16. main routine so of program the print Revise 
the arbitrary as of possible the length long input as lines, much and text. of 

than all that 80 lines longer characters. input 1-17. Exercise to program a Write print are 

line trailing tabs of and each input, blanks 1-18. Exercise to program a Write remove from 
blank lines. entirely and delete to 

it a the Use s. Exercise 1-19. function reverse(s) string that character reverses to Write 
program at a reverses a a line write that input time. its 

Variables External and Scope 1.10 

main. main, Because or to line, variables such as in they etc., private are longest, local The 
same main, is to The function declared no other within true have access direct can them. are 
i in in i variables of example, variable functions; to other unrelated the for the getline the is 

 
the function existence function into when is comes copy. in in variable local Each a only 
are when This variables such called, and the function why is is exited. usually disappears 
We following in known as other variables, use the will terminology languages. automatic 
henceforth to static refer to the local discusses 4 these term variables. automatic (Chapter 
in values between local class, retain their storage which do calls.) variables 

variables come their and go retain function not do with Because invocation, automatic they 
must the next, each they are call If to explicitly not upon from values set one set, entry. and be 
contain garbage. they will 

are is define external to that to possible an As variables, automatic to alternative it variables 
function. is, accessed any by all functions, variables that name can by be (This that 
declared Fortran or mechanism is Pascal like the outermost in COMMON variables rather 
be are accessible, block.) Because they variables instead of used globally can external 
functions. lists communicate argument because Furthermore, data to external between 
and remain appearing disappearing as in permanently, existence rather than variables 
that their after set even functions them values are functions they exited, and called retain the 
returned. have 

sets must outside this function; An external be defined, any exactly of once, aside variable 
each The function this it. storage be in must access variable to for also it; that declared wants 
or of may explicit statement The the the variable. type be may an be declaration extern states 
us make discussion implicit from concrete, To the longest-line rewrite the let context. 
line, longest, calls, and max the external changing requires as program variables. with This 
all of functions. and three bodies declarations, 



<stdio.h> #include 



size input line */ #define MAXLINE /* 1000 maximum 



far seen so */ int max; maximum /* length 

input current */ line[MAXLINE]; line /* char 

saved longest[MAXLINE]; here line char /* */ longest 



getline(void); int 

copy(void); void 



specialized print version line; /* longest */ input 

main() 

{ 

len; int 

max; int extern 

longest[]; char extern 



0; = max 

> 0) getline()) while = ((len 

> (len max) { if 

len; = max 

copy(); 

} 

was (max 0) if line a /* > */ there 

longest); printf("%s", 

0; return 

} 

 


specialized getline: version */ /* 

getline(void) int 

{ 

i; c, int 

line[]; char extern 



- < MAXLINE 1 for (i 0; = i 

'\n'; c != ++i) && (c=getchar)) EOF != && 

c; = line[i] 

== (c '\n') { if 

c; = line[i] 

++i; 

} 

'\0'; = line[i] 

i; return 

} 



specialized copy: version */ /* 

copy(void) void 

{ 

i; int 

line[], longest[]; extern char 



0; = i 

!= '\0') line[i]) while = ((longest[i] 

++i; 

} 

of in the the lines and external main, getline variables example are by defined copy first The 
state their Syntactically, type and them. storage for allocated cause above, to which be 
outside just variables, occur they external definitions like definitions since of but local of are 
the are can variable, external functions, the external. Before an a use function name variables 
same must as declaration the known the be made variable before the the function; to is of 
keyword extern. added except the for 

circumstances, the the extern declaration of be definition the can In omitted. certain If 
then in there a function, file variable the source occurs is its in use before particular external 
main, an function. in declarations no need extern declaration extern in The the getline for 
of common to all is definitions external practice copy and In redundant. thus are fact, place 
the beginning declarations. of the extern file, all omit source variables and at then 

and several source in used in is and in variable file2 defined the If is program and file1 files, a 
occurrences file2 to of file3 the the and then file3, needed are declarations extern in connect 
in practice declarations functions and variable. The is to variables collect of extern a usual 
front is #include of by the each included file, separate header, a called historically that at 
the suffix header of functions source file. .h is The conventional names. for standard The 
at are <stdio.h>. discussed is library, for declared in topic headers This like length example, 
7 the itself in Chapter in and Appendix B. and library Chapter 4, 

specialized versions suggest of getline would copy logic arguments, and Since have the no 
copy(). the be But should and for file their that beginning the at prototypes of getline() 
older C old-style programs the an takes as list standard compatibility an with empty 
used checking; void for word be an the and declaration, argument all off turns list must 
in empty further Chapter 4. list. will We discuss this explicitly 

when that words carefully declaration You should we are and using definition the we note 
variable variables to the where refer to in this place section.``Definition'' the refers is external 

 
variable storage; where the of created or ``declaration'' refers nature to the places is assigned 
is allocated. storage stated no but 

variable there because sight extern tendency the is a way, it make in everything to an By 
simplify communications there - argument always are are variables lists appears short to and 
don't are even want there you them. always you when external But them. want variables when 
to on with leads it Relying too external variables since is peril fraught programs heavily 
unexpected - be and can in even variables data whose all not are connections obvious changed 
the the modify. of version inadvertent ways, program is second hard The to longest-line and 
it for and destroys reasons, because the these is program first, the to inferior partly partly 
variables useful them the of generality of functions by names writing the into they two 
manipulate. 

C. we With conventional of what this have covered point this be the called might core At 
and blocks, useful size, considerable handful of it's possible of to programs write it building 
These a exercises to so. if probably good idea be suggest paused enough long you do would 
somewhat in this complexity of ones earlier programs greater the chapter. than 

the replaces the proper in with number tabs 1-20. Exercise detab program a Write that input 
stop. the next of say every space stops, to a n set blanks of fixed to columns. tab tab Assume 
symbolic or a parameter? Should n a be variable 

Write a minimum program entab the replaces by blanks that Exercise strings 1-21. of 
Use and the detab. tabs number the spacing. to as blanks stops of achieve for same same tab 
tab a should single either to given which be reach blank When or a suffice tab would stop, a 
preference? 

shorter a lines two more ``fold'' 1-22. program to Write after input into lines long or Exercise 
sure character n-th Make input. the last that occurs of before column the your non-blank 
blanks lines, there or if no tabs and does program very with intelligent something long are 
specified column. before the 

Don't all a forget from program. to comments 1-23. Exercise to program a Write remove C 
comments quoted C don't nest. strings character and constants properly. handle 

errors a C syntax rudimentary Exercise 1-24. program to for check program a like Write 
brackets both single braces. parentheses, about quotes, unmatched and forget and Don't 
in and hard it do double, escape comments. (This you program if is full sequences, 
generality.) 

 


Operators and Types, Chapter - 2 
Expressions 

constants are list the basic Declarations objects program. a data Variables manipulated and in 
their be initial and what state variables used, and to values type have they what perhaps the 
specify what and is to variables done combine Expressions be are. to Operators them. 
values new it the of type to values. The produce can an determines object of set constants 
topics operations of blocks the performed and can be what this it. building These on are have 
chapter. 

standard has and made many types changes basic to small The and ANSI additions 
notations now of and types, expressions. There signed and integer unsigned all forms for are 
Floating-point constants hexadecimal unsigned may operations character and be constants. 
precision. precision; long extended for done in there is type also double a String single 
become at time. constants may Enumerations concatenated of the part compile have be 
be of standing. language, formalizing Objects feature const, which declared long may a 
coercions changed. rules prevents them for being arithmetic types among The automatic from 
richer been to have of set handle augmented types. the 

Names Variable 2.1 

names say of restrictions the Chapter we so in didn't variables there some are 1, on Although 
must Names be the character up symbolic are made constants. a letters digits; and of first and 
improving ``_'' it for useful letter. The counts as sometimes a is letter; the underscore 
long with underscore, names. of variable names readability variable begin however, Don't 
so often x letters distinct, names. library use such routines and and case lower Upper are since 
variable different names, lower for C are names. Traditional two and is use to practice case X 
symbolic constants. for all case upper 

function an are names name For and internal least At characters 31 first the of significant. 
be than external used because may by 31, variables, external be may number the less names 
loaders over the which the names, has external For language assemblers no and control. 
uniqueness only if, for 6 like and Keywords case. characters standard a guarantees single 
must etc., be variable They you int, are reserved: float, in use as them can't names. else, 
case. lower 

the choose purpose are to It's are to names and variable variable, wise that that of related the 
local mixed to for names unlikely to up typographically. short We use tend variables, get 
external names for variables. especially loop and indices, longer 

Types Data and Sizes 2.2 

data are a There in types few only C: basic 

char 

the of one a single character capable character set local holding in byte, 

int 

on the size an integer, of reflecting host machine the natural integers typically 

float 

point floating single-precision 



 
double 

point floating double-precision 



basic are types. applied these of addition, a number there short that be can qualifiers to In 
apply long to integers: and 



sh; int short 

counter; int long 

and be in The word such can it is. typically omitted declarations, int 

where that provide integers of The intent short and lengths long different should practical; is 
machine. be short and normally int for particular natural bits the 16 will size long, is a often 
for or its choose sizes Each either 32 bits. 16 own is to free compiler appropriate int 
ints to are are only hardware, that and the bits, the 16 subject restriction longs at shorts least 
longer bits, than which no is least and short 32 long. longer int, than no is at 

unsigned or to integer. any The qualifier unsigned may or be char applied numbers signed 
arithmetic or modulo number positive are the of and is zero, n always obey the 2n, laws where 
are the 8 values in of instance, chars So, variables type. char bits for have bits, if unsigned 
(in have -128 a between 127 two's values 0 between signed while 255, and chars and 
unsigned machine.) or is machine-dependent, Whether chars plain are signed complement 
always positive. are but characters printable 

with specifies floating The type point. double the sizes integers, extended-precision As long 
long floating-point and double could objects implementation-defined; are float, double of 
three or sizes. one, distinct two represent 

for and contain The standard symbolic <limits.h> of these all <float.h> constants headers 
with other in properties of discussed machine are These the sizes, and along compiler. 
B. Appendix 

and a ranges int, short, Exercise 2-1. program to char, determine of the long Write 
signed from standard unsigned, both appropriate values variables, and printing headers by 
the computation. them: of ranges and by Harder if the you determine compute various direct 
types. floating-point 

Constants 2.3 

with is l an integer constant or terminal (ell) is int. An 1234 constant long like A a written 
as constant int too also big 123456789L; be as taken into an in fit an L, to long. a will integer 
or written UL the ul terminal constants with a are indicates or and U, u suffix Unsigned 
long. unsigned 

contain a their decimal point both; or or (1e-2) (123.4) Floating-point an constants exponent 
indicate unless a indicate double, type f F The or suffixed. l is suffixes L float or constant; 
double. long a 

decimal. an A hexadecimal of be value integer can of leading in or octal specified instead The 
means octal; 0x hexadecimal. leading 0X For a (zero) 0 constant integer an on means or 
and can 0x1f and 31 example, 037 octal written hex. be in decimal as Octal or in 0x1F 

 
to also make long U by constants be followed may them to them make L and hexadecimal 
value 0XFUL with 15 decimal. is unsigned an long constant unsigned: 

such is one quotes, single A character an integer, within written character as as constant 
in of the of character constant The a character value machine's the value numeric is the 'x'. 
has character character the the '0' value set set. character the in example, For ASCII constant 
instead the numeric numeric which we like a value write value 48, to is If unrelated 0. of '0' 
particular the independent value is the and program that 48 character the on depends set, of 
read. Character integers, constants participate other numeric any as in easier operations to just 
with they comparisons other characters. are often most used in although 

constants represented character Certain characters and be escape sequences by in string can 
(newline); these In sequences look one. two only represent like like characters, \n but 
can an byte-sized addition, specified be bit arbitrary by pattern 



'\ooo' 

(0...7) ooo digits or by is to one three octal where 



'\xhh' 

might one (0...9, we So where hh or more A...F). hexadecimal a...f, digits write is 



vertical VTAB tab ASCII #define '\013' */ /* 

bell BELL character ASCII #define '\007' */ /* 

hexadecimal, in or, 



vertical VTAB tab ASCII #define '\xb' */ /* 

bell BELL character ASCII #define '\x7' */ /* 

escape of is complete sequences set The 

\a 

character (bell) alert 

\\ 

backslash 

\b 

backspace 

\? 

mark question 

\f 

formfeed 

\' 

quote single 

\n 

newline 

\" 

quote double 

\r 

return carriage 

\ooo 

number octal 

\t 

tab horizontal 

\xhh 

number hexadecimal 

\v 

tab vertical 







constant '\0' '\0' represents the character. with null the character The value character zero, 
expression, emphasize nature but character some the the often is 0 of instead written to of 
is value just 0. numeric 

expression is be an expression may involves expressions Such that A only constant constants. 
during compilation any rather than in and used be run-time, evaluated accordingly at may 
occur, that as can place a in constant 



1000 MAXLINE #define 

line[MAXLINE+1]; char 

or 



leap LEAP years in #define 1 */ /* 

days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31]; int 

 
characters a zero surrounded of more by sequence string A literal, string or constant, is or 
as in double quotes, 



a string" "I am 

or 



string */ empty "" the /* 

only not to sequences are The string, serve of same part The quotes the escape delimit but it. 
the apply strings; used in \" constants character. String double-quote in represents character 
at concatenated time: can compile be constants 



"world" " "hello, 

to equivalent is 



world" "hello, 

useful several source splitting is strings across This for long lines. up 

a constant characters. of representation Technically, a is an internal array The of string string 
physical character storage the null has end, the at more '\0' one a the than required so is 
characters written no between the is This there that quotes. number representation of means 
must long scan its how limit be, programs string to a completely to can determine a but string 
of function returns length. The the library character string its strlen(s) length standard 
Here s, the argument our is terminal excluding version: '\0'. 



of length */ strlen: s return /* 

s[]) strlen(char int 

{ 

i; int 



!= '\0') while (s[i] 

++i; 

i; return 

} 

other standard header functions and in the strlen string declared <string.h>. are 

a distinguish and contains that Be careful between a string character a constant single to 
is not an numeric is character: "x". former same produce the to 'x' as the integer, The used 
The letter latter that the value machine's set. in of x array of the characters is character an 
a x) and '\0'. contains one (the character letter 

a the An list constant. is of enumeration is There of kind other one constant, enumeration 
values, integer as in constant 



YES }; NO, enum { boolean 

so enum explicit has first next are unless values 1, value The an name the in 0, on, and 
not all the values are from unspecified progression the specified, specified. values If continue 
these second of examples: last specified as value, the 



{ TAB = = escapes = '\b', enum BELL BACKSPACE '\t', '\a', 

RETURN = VTAB NEWLINE '\r' = = '\n', }; '\v', 



APR, months MAR, MAY, JUN, { = JAN 1, FEB, enum 

NOV, OCT, }; AUG, DEC SEP, JUL, 

etc. = 3, */ /* FEB 2, = MAR 

 
the enumerations need in distinct Names in must be be distinct. not Values same different 
enumeration. 

a with names, way provide constant values Enumerations convenient associate an to 
you. with values for generated alternative to the advantage be that can the Although #define 
you compilers check store not what in need of variables be may types enum declared, that 
variable is offer a valid variables for enumeration Nevertheless, value such the a enumeration. 
debugger checking may In a are chance and so of be better #defines. than often addition, the 
their to in symbolic form. print of values enumeration variables able 

Declarations 2.4 

declarations declared use, All variables although be be made can before certain must 
one type, a or contains of more and by implicitly specifies declaration A content. a list 
as in type, variables that of 



upper, step; int lower, 

line[1000]; c, char 

well distributed fashion; could above Variables can among declarations lists in the any be be 
as written 



lower; int 

upper; int 

step; int 

c; char 

line[1000]; char 

to is adding each for comment declaration convenient latter The space, more takes form but a 
modifications. subsequent for 

the also name sign may A its If initialized an be by variable in equals is declaration. followed 
initializer, an an as in expression, expression the serves as and 



= '\\'; char esc 

= 0; int i 

= MAXLINE+1; int limit 

= 1.0e-5; float eps 

only, in the once done If the question is is not initialization automatic, conceptionally variable 
program starts An executing, and expression. initializer constant a the before must the be 
is time or in function it is the initialized explicitly initialized is variable automatic each block 
initializer may to be any initialized External are variables expression. entered; and the static 
default. Automatic (i.e., variables for undefined is have initializer which zero no by explicit 
values. garbage) 

that can its variable specify to qualifier be applied const value declaration any of the to The 
will changed. not that elements array, not For an be be const says qualifier the the will 
altered. 



e double = 2.71828182845905; const 

"warning: "; = const msg[] char 

the can array that indicate The const also be to used arguments, with function declaration 
change not that array: does 



char[]); strlen(const int 

 
to if attempt The result is implementation-defined a const. change an made is 

Operators Arithmetic 2.5 

%. *, the Integer and operator division /, binary The +, are operators arithmetic -, modulus 
The expression part. truncates fractional any 



y % x 

when is x divided the thus For divides exactly. is by produces x remainder and when y, y zero 
that year but if by it is 100, a except by a year divisible 4 example, is divisible years not leap 
years. Therefore leap by are 400 



!= 4 0) 0) % if year 100 0 400 == % ((year && == || % year 

year\n", year); leap printf("%d a is 

else 

leap a year); is year\n", not printf("%d 

double. cannot The and operator The a or applied for be truncation % to / direction float of 
the the action operands, is % sign result for of taken machine-dependent negative for are as the 
or underflow. on overflow 

than the which the precedence, lower precedence same binary The operators - and + have is 
turn which is and operators associate and Arithmetic %, than left + *, of unary / to -. in lower 
right. 

all the summarizes for associativity Table 2.1 end of and this precedence chapter operators. at 

and Relational Logical Operators 2.6 

operators are The relational 



< <= > >= 

equality the them the are They all same precedence. precedence Just in below operators: have 



!= == 

an precedence arithmetic Relational operators operators, lower like i expression than so have 
is would be as lim-1 (lim-1), as < taken < expected. i 

or and connected || Expressions && are ||. interesting More operators logical the are && by 
the right, truth is to evaluated as as evaluation the and of left stops result or soon falsehood 
from programs the is loop these Most rely on C input For here example, properties. a known. 
in getline Chapter wrote function that 1: we 



i < ++i) lim-1 && EOF; != != c (c=getchar()) for '\n' (i=0; && 

c; = s[i] 

room it it is reading that the store in there necessary Before character a check new to to is 
must < if lim-1 test must the fails, s, we first. test so made Moreover, array be go not this i 
read and another character. on 

is be tested getchar before Similarly, it unfortunate if EOF c against were called; would 
call and tested. assignment must is before c in occur therefore the the character 

 
and && both equality of The that ||, higher relational is than precedence than and are of lower 
expressions like operators, so 



c < && != EOF lim-1 (c=getchar()) && != '\n' i 

extra parentheses. assignment, But since than precedence higher is the need of no != 
needed in parentheses are 



'\n' != (c=getchar()) 

the desired '\n'. result of with to comparison then assignment to c achieve and 

expression numeric is true, the By relational logical of relation value the definition, a is 1 or if 
relation the false. 0 is if and 

0, operator and A negation The non-zero into converts in ! operand unary a 1. a operand zero 
in use constructions is common of like ! 



(!valid) if 

than rather 



== 0) if (valid 

nicely generalize better. read !valid It's hard about which like form Constructions is (``if to 
hard valid''), be to understand. but complicated more ones can not 

&& the above or loop using ||. for 2-2. Exercise equivalent loop a Write to without 

Conversions Type 2.7 

common has they a to When an operands of converted different are types, type operator 
are In only those the conversions that general, to according of number small a rules. automatic 
losing into ``wider'' convert a one operand such as information, a without ``narrower'' 
Expressions an f that like i. don't expression an converting point floating into integer in + 
might using subscript, that Expressions make sense, a float disallowed. as are a lose like 
type to or to shorter, floating-point an a like information, integer longer a assigning type a 
they may a integer, not are warning, draw illegal. but 

arithmetic just expressions. freely in integer, char a small is This chars be may so used A 
transformations. considerable character One is flexibility certain in kinds of permits 
this naive of implementation of string function a converts the exemplified atoi, by which 
its into numeric equivalent. digits 



to s */ atoi: integer convert /* 

s[]) atoi(char int 

{ 

n; i, int 



0; = n 

= <= '9'; s[i] (i && s[i] for 0; '0' ++i) >= 

- + (s[i] '0'); n = * 10 n 

n; return 

} 

1, we the Chapter As discussed expression in 



 
'0' - s[i] 

'0', value '1', the of character the of the numeric etc., in because s[i], stored values gives 
contiguous a increasing sequence. form 

a char the maps which Another example to int lower, conversion function is single of 
the case character letter, lower character character If the upper for an to ASCII case is set. not 
it unchanged. lower returns 



case; lower: c /* only ASCII to convert */ lower 

c) lower(int int 

{ 

c (c <= && if >= 'Z') 'A' 

- 'A'; 'a' return + c 

else 

c; return 

} 

a ASCII and are letters This works because corresponding case upper lower case fixed for 
nothing alphabet -- but contiguous is letters is apart distance and values numeric as each there 
set, Z. however, the character observation A This latter and so not of true is EBCDIC between 
just code convert this in letters more would EBCDIC. than 

header <ctype.h>, that described in functions B, of family Appendix The defines standard a 
and conversions function that are the of example, For independent provide character tests set. 
a portable test replacement for the function Similarly, above. the tolower lower is shown 



c && '9' >= <= '0' c 

replaced by can be 



isdigit(c) 

now functions from on. We will the use <ctype.h> 

language subtle of The integers. There is point about to the characters conversion does one 
a are unsigned char or When is signed specify not type of variables whether char quantities. 
varies produce integer? from negative answer machine a to converted it can int, an ever The 
a in On to machine, some differences whose leftmost char architecture. machines reflecting 
a will char extension''). others, to is be converted 1 is negative (``sign integer a On bit 
is at end, always left thus positive. the to promoted adding by int an zeros and 

of C character guarantees that printing character standard machine's any The in definition the 
never be in negative, so quantities characters positive be these set will will always 
arbitrary bit negative patterns stored be character to appear in expressions. variables But may 
if yet portability, unsigned or on some positive on signed others. specify For non- machines, 
char stored in variables. character data to is be 

|| logical by are connected and defined expressions expressions Relational j > i like and && 
false. if and to have 0 1 the assignment Thus true, if value 



<= && c '9' d = >= c '0' 

return is However, a like digit, 1 isdigit d may if if to 0 not. sets and non- any functions c 
while, true. for, so for zero part if, the means In just value test ``non-zero'', etc., of ``true'' 
no difference. this makes 

 
+ In an or if like * general, arithmetic Implicit as much work conversions expected. operator 
``lower'' operands operands the types, that takes (a binary different operator) of has type two 
of the The the proceeds. is integer operation promoted is type ``higher'' the to before result 
are the precisely. no rules there unsigned conversion Section type. A Appendix of 6 states If 
of however, following operands, will rules informal the suffice: set 

other is double,  If convert operand long double. to long the either 
if other to operand Otherwise, convert the  either double, double. is 
if other to operand Otherwise, convert the  either float, float. is 
short Otherwise, to and  convert int. char 
if other to operand Then, convert the  either long, long. is 


is in automatically this double; Notice that an expression to are converted not a floats 
like definition. general, change from mathematical original in <math.h> those In functions the 
in precision. large to storage reason use The main double arrays, using is float for save will 
double-precision save on or, less machines to is particularly arithmetic time where often, 
expensive. 

are involved. The complicated rules operands are Conversion more unsigned problem when 
comparisons machine-dependent, because signed that values are is between unsigned they and 
example, sizes suppose and the depend integer For the 16 of is on various bits that types. int 
unsigned -1L promoted < is which a is to is 1U, long Then 32 1U, bits. because int, an 
and -1L to thus promoted long appears is long. signed 1UL > -1L But because unsigned 
positive number. large to a be 

to of side the right converted type the take Conversions the assignments; across place value is 
type the which of the of is left, result. the 

as either extension described sign not, above. by character A an to converted is integer, or 

excess converted to the dropping Longer integers to shorter by ones chars or high-order are 
in Thus bits. 



i; int 

c; char 



c; = i 

i; = c 

is c involved. not extension This value is unchanged. of Reversing true or whether is sign the 
lose order information, might the of however. assignments 

= float x int, int is conversions; cause i If is to x x both and then float and = i i 
whether any double float, to causes truncation fractional part. converted When is a the of 
is is implementation truncated value rounded dependent. or 

takes is type place expression, also when an an Since function a of argument call conversion 
and to of char prototype, arguments are functions. In function the a absence short passed 
arguments float why function declared become int, becomes double. have This we is to and 
and double float. even when and function char with the be is int called 

type conversions unary can be a (``coerced'') with expression, forced Finally, in explicit any 
In cast. construction called the a operator 

 
expression name) (type 

The converted by above. rules the expression to the conversion named the type precise is 
assigned cast to type, a meaning the were as the is of of if specified a expression variable 
library the For routine construction. the sqrt whole is which place in used then of example, 
double inadvertently handled and a nonsense if expects argument, produce something will 
can declared n we integer, else. (sqrt in <math.h>.) an So is if use is 



n) sqrt((double) 

Note n cast to convert it the the produces to double to of the passing value before that sqrt. 
cast proper the type; of not high has same altered. n value the n is in itself operator The 
of in at this table end chapter. the as precedence as operators, unary other summarized the 

the declared as be, should If arguments by a normally function the prototype, declaration are 
coercion of a any arguments given the Thus, called. when causes function automatic is 
for sqrt: function prototype 



sqrt(double) double 

call the 



sqrt(2) = root2 

a 2 2.0 for need coerces the into the any double without value cast. integer 

a standard of pseudo-random number library a includes portable implementation The 
former for the generator and seed; function a cast: illustrates initializing the a 



= 1; next unsigned int long 



on rand: 0..32767 integer /* return */ pseudo-random 

rand(void) int 

{ 

1103515245 * 12345; = + next next 

int)(next/65536) (unsigned % 32768; return 

} 



for seed */ srand: rand() set /* 

int seed) void srand(unsigned 

{ 

seed; = next 

} 

string function which Exercise 2-3. converts a hexadecimal digits of htoi(s), a Write 
digits its value. are integer allowable 0 equivalent an (including 0X) or 0x optional into The 
through and A F. through 9, through a f, 

and Increment Decrement Operators 2.8 

decrementing provides and variables. The two operators unusual for incrementing C 
subtracts operand, decrement 1. the -- We while operator increment to 1 adds ++ its operator 
as increment variables, in have frequently ++ used to 



== '\n') if (c 

++nl; 

 
operators is (before either prefix and unusual that ++ aspect the may used be -- as The 
n++). ++n), In to in variable, (after variable: postfix effect or the as operators is both the cases, 
while the before used, is increment n. expression ++n value increments its n n++ But 
that its in is after increments used. means has the value where n been value a This context 
is and different. 5, are n then n++ used, being effect, the just not ++n If 



n++; = x 

to x 5, but sets 



++n; = x 

The 6. increment be to sets n 6. both can In operators x cases, only and becomes decrement 
is like (i+j)++ illegal. applied to an variables; expression 

context where in no value as wanted, effect, incrementing is In just a the 



== '\n') if (c 

nl++; 

other are is one the But and the same. postfix specifically are where situations there or prefix 
For removes all consider for. squeeze(s,c), which called instance, function occurrences the 
the the string from of character s. c 



from squeeze: s c /* delete */ all 

s[], squeeze(char int c) void 

{ 

j; i, int 



s[i] (i j for '\0'; != = = i++) 0; 

!= c) if (s[i] 

s[i]; = s[j++] 

'\0'; = s[j] 

} 

current non-c j j a Each copied the it then occurs, only time is is position, into and 
is for next incremented to character. ready equivalent to exactly the This be 



!= (s[i] c) { if 

s[i]; = s[j] 

j++; 

} 

wrote a the we that Another example similar construction function comes getline from in of 
can replace we Chapter where 1, 



== (c '\n') { if 

c; = s[i] 

++i; 

} 

more compact by the 



== '\n') if (c 

c; = s[i++] 

third which concatenates consider a function strcat(s,t), As example, standard the the 
strcat of string enough s to the in end that hold is t string there to the space s. assumes 
we have version written it, library returns standard the strcat combination. no As value; 
the to string. a resulting pointer returns 



concatenate t */ to end enough s; big be of /* s strcat: must 

s[], strcat(char char t[]) void 

{ 

 
j; i, int 



j = = 0; i 

end (s[i] '\0') while s of /* != */ find 

i++; 

/* ((s[i++] t[j++]) while t copy != = */ '\0') 

; 

} 

postfix is both to sure member j and ++ As t make the each i is s, to copied to applied from 
are through the position they next pass that in the loop. for 

deletes alternative of Exercise 2-4. squeeze(s1,s2) an character in each version that Write 
string in the s2. s1 that any matches character 

string the the a in Exercise 2-5. function any(s1,s2), location which first returns s1 Write 
characters from from s1 no s2 any the string character s2. or if -1 occurs, contains where 
to function job pointer a (The standard strpbrk does returns the but same the library 
location.) 

Operators Bitwise 2.9 

integral operators may to applied C provides for bit be manipulation; only these operands, six 
signed is, whether or unsigned. char, int, short, and long, that 

& 

AND bitwise 

| 

OR inclusive bitwise 

^ 

OR exclusive bitwise 

<< 

shift left 

>> 

shift right 

~ 

(unary) complement one's 



bits, operator for some of often bitwise & is AND example to off mask used set The 



n = & 0177; n 

bits to 7 of n. zero but all the low-order sets 

turn bitwise to bits on: OR | operator is used The 



x = | SET_ON; x 

one in SET_ON. x the in that one to bits sets are to set 

its OR operands bit where sets bitwise operator ^ exclusive have one each in a position The 
the they are same. different bits, zero and where 

&& and the and from operators ||, | must One operators bitwise the distinguish & logical 
For a truth 1 is 2, evaluation y of if then is imply which x left-to-right x and value. example, 
&& y zero & is y while is one. x 

shifts << of number operators The left right >> by and operand shift perform the their and left 
<< given 2 non-negative. x right bit by the positions shifts which be must operand, Thus of 

 
is filling with equivalent bits this to vacated value the two by x of positions, zero; 
4. Right with shifting an bits quantity vacated the unsigned multiplication always by fits 
on a with shift'') (``arithmetic zero. Right signed quantity signs will bit fill some shifting 
shift'') and on (``logical machines with others. 0-bits 

converts ~ each that it one's unary yields the operator 1-bit of integer; an complement is, The 
versa. a For vice into 0-bit example and 



x = & ~077 x 

length, x ~077 to independent zero. six of the word x bits last that & sets Note is and is of 
16-bit for quantity. x a & preferable example, x to, The which that assumes 0177700, is thus 
can ~077 constant be a that evaluated is form portable cost, extra no involves since expression 
time. compile at 

illustration of that some of getbits(x,p,n) bit function the the As operators, an consider 
assume adjusted) that position We of the n-bit field (right bit that at begins x p. returns 
and at p example, is position and n right values. the positive 0 end For are that sensible 
the and 2, bits returns 4, 3 getbits(x,4,3) three positions right-adjusted. in 



p from position */ /* getbits: n get bits 

p, int n) getbits(unsigned int x, unsigned 

{ 

~(~0 (x << & return >> n); (p+1-n)) 

} 

of moves ~0 the expression the all word. is right desired The (p+1-n) x to >> field the end 
n left places rightmost the 1-bits; shifting n positions in with zeros ~0<<n bits; it 
with ~ bits. makes a n with rightmost the mask complementing ones that in 

that returns the begin with bits at x 2-6. Exercise setbits(x,p,n,y) function a Write that n 
bits to of other the position p the rightmost leaving n y, bits unchanged. set 

that returns the begin with bits at x 2-7. Exercise invert(x,p,n) function a Write that n 
others (i.e., and the leaving position p 1 changed versa), into vice 0 unchanged. inverted 

x a the integer the Exercise 2-8. function rightrot(x,n) of that value returns rotated Write 
n positions. by to right the 

Operators Assignment and Expressions 2.10 

such as An expression 



i = + 2 i 

immediately variable on in the in side repeated the be on can which left written the is right, 
form compressed the 



2 += i 

an operator assignment called The += operator. is 

have (operators a operand) right Most binary like + and that left have a operators 
one op is of corresponding assignment op=, operator where 

 


>> - / + ^ & % * | << 

are expr2 then expr1 expressions, and If 



expr2 op= expr1 

to equivalent is 



(expr1) = op (expr2) expr1 

expr1 parentheses around computed that Notice the except is once. expr2: only 



y *= + 1 x 

means 



(y * 1) = + x x 

than rather 



y * 1 = + x x 

integer the number its in As an function bitcount 1-bits counts of the argument. example, 



in bitcount: x bits /* count */ 1 

x) bitcount(unsigned int 

{ 

b; int 



0; (b 0; for >>= x x = 1) != 

& 01) if (x 

b++; 

b; return 

} 

right-shifted, unsigned when vacated that is bits ensures the Declaring be to x argument an it 
is with run machine program sign be zeros, not filled on. regardless the of bits, the will 

from that they assignment apart the advantage Quite conciseness, have correspond operators 
``take We ``increment say by ``add way 2'', to not i'' people the to or better 2 add i, i think. 
= in 2 i''. preferable Thus the to then i i result put expression += 2, the In i+2. is back 
expression like complicated addition, a for 



yypv[p1]] + += 2 yyval[yypv[p3+p4] 

have makes understand, doesn't reader the assignment the code the easier since to to operator 
why two the wonder to check painstakingly long expressions or are same, indeed they're that 
an assignment code. operator may efficient help produce to even not. a And compiler 

occur statement value in a can expressions; has have We the that seen already assignment and 
common most example is the 



!= EOF) getchar()) while = ((c 

... 

this operators also although expressions, The other (+=, -=, in etc.) occur can is assignment 
frequent. less 

its expressions, left the of of all the type such operand, assignment is expression an type In 
the value after assignment. and the is value the 

rightmost a x the deletes Exercise 2-9. two's complement (x-1) number &= system, 1-bit In 
Explain why. bitcount. Use this of to version faster observation in write x. a 

 
Expressions Conditional 2.11 

statements The 



> b) if (a 

a; = z 

else 

b; = z 

with and conditional the The written ternary b. in compute of maximum the z a expression, 
provides an the alternate way In write constructions. similar to operator this ``?:'', and 
expression 



expr2 ? : expr3 expr1 

expression it (true), expr2 non-zero the is is expression the first. evaluated is expr1 If then 
that is evaluated, the value is the expr3 Otherwise of evaluated, conditional and expression. 
expr2 Only one Thus z to the set value. expr3 the evaluated. that and is is maximum to of and 
and b, of a 



b) > b; max(a, = z = b) ? z a /* : */ (a 

can noted be expression, it conditional should that the be used is an indeed expression and It 
are expression of the other wherever expr2 expr3 be. type can the any If of different and types, 
example, discussed this if in For f earlier is result conversion the by determined rules chapter. 
int, a and is the then n float expression an 



f ? n > : 0) (n 

whether of float is is n regardless type positive. of 

a around first Parentheses are expression necessary expression, since conditional the of not 
of ?: anyway, is very advisable just are They low, the above precedence assignment. 
expression the part however, since of make to see. easier condition the they 

expression often n leads to prints code. loop this succinct The For conditional example, 
separated array, by line an elements with column per with 10 and of line, each one each blank, 
by terminated newline. the a last) (including 



< (i n; i for = i++) 0; 

'\n' a[i], || printf("%6d%c", ' : i==n-1) (i%10==9 '); ? 

other element, the elements after All are and newline A every after printed is tenth n-th. 
the tricky, more equivalent it's than if- but by followed might This blank. one look compact 
good Another example is else. 



? have items%s.\n", printf("You : "" n, %d "s"); n==1 

Rewrite the case, function lower, lower converts to letters which Exercise upper 2-10. case 
instead expression if-else. a of conditional with 

of Evaluation Order 2.12 and Precedence 

of rules precedence Table 2.1 and the operators, including all for associativity summarizes 
the Operators same same the have precedence; on that those yet not have we discussed. line 
*, order /, same in rows so, example, decreasing have of all are precedence, the and for % 
refers higher to The () of which than that is function + -. and binary ``operator'' precedence, 
members -> of in operators call. used access . be and will The are covered structures; to they 

 
(indirection an 5 through Chapter * a object). 6, Chapter (size sizeof with along of discusses 
& (address operator. of an comma and the discusses object), pointer) Chapter and 3 

Operators 

Associativity 

-> . () [] 

right to left 

(type) - * sizeof ! ~ -- ++ + 

left to right 

% / * 

right to left 

- + 

right to left 

>> << 

right to left 

> >= < <= 

right to left 

!= == 

right to left 

& 

right to left 

^ 

right to left 

| 

right to left 

&& 

right to left 

|| 

right to left 

?: 

left to right 

|= += ^= <<= >>= -= /= *= %= &= = 

left to right 

, 

right to left 



than and have Unary & higher -, binary forms. the * precedence +, 

Associativity and Operators 2.1: of Precedence Table 

and precedence | This the Note operators ^, the and of == that bitwise !=. falls &, below 
bit-testing that expressions like implies 



== MASK) ... ((x 0) & if 

give be proper to must fully results. parenthesized 

an languages, operator the of specify like does not most are order which in the operands C, 
statement are `,'.) a in evaluated. (The &&, ||, example, ?:, For and like exceptions 



f() = + g(); x 

on or or vice alters versa; evaluated a may variable either before be if f f thus the which g g 
be order Intermediate stored evaluation. can in of depends, other on depend can x the results 
a ensure sequence. variables particular to temporary 

order in the which function so are specified, not arguments Similarly, evaluated the is 
statement 



/* %d\n", WRONG n)); printf("%d ++n, */ power(2, 

whether with compilers, can produce depending results is incremented n different on different 
is power course, to write is The called. solution, of before 



++n; 

 
n, %d\n", power(2, n)); printf("%d 

decrement calls, and operators cause nested statements, assignment and increment Function 
of as of an by-product evaluation expression. a effects'' ``side is variable some - changed the 
order involving be the on In any side effects, dependencies there subtle can in expression 
taking part typified in the is are situation unhappy expression which updated. variables One 
statement the by 



i++; = a[i] 

of whether i interpret is The the value subscript Compilers the new. question is can or old the 
on and different this in answers ways, interpretation. The their generate depending different 
leaves effects (assignment such intentionally When side standard most unspecified. to matters 
compiler, left discretion since the the the to take variables) expression an within place is of 
depends strongly side on machine all (The that specify architecture. best standard order does 
but take that call arguments effects function called, before in effect help on a the would is not 
above.) printf to 

a depends of bad order is programming on moral The code writing that is that evaluation 
but language. if things avoid, is in Naturally, it any you to what know necessary to practice 
to various won't take you tempted advantage machines, know don't done are they how on be 
particular implementation. of a 

 


- 3 Control Flow Chapter 

of a We language specify performed. order are computations the The in control-flow which 
earlier most control-flow have already constructions the here we examples; common in met 
the and more will complete precise set, discussed before. ones be about the 

and Blocks 3.1 Statements 

when as it becomes statement 0 expression x = such is i++ printf(...) or or a An 
as in semicolon, followed a by 



0; = x 

i++; 

printf(...); 

a semicolon separator like the In terminator, than a in is is C, statement languages as rather it 
Pascal. 

a } declarations into together Braces { are used statements to and group compound and 
The so equivalent statement. single statement, or that they a are to syntactically braces block, 
the statements multiple of a around are braces example; function that one surround obvious 
declared for (Variables inside another. be any are after statements while, else, if, an or can 
is talk no that will block; Chapter There this right about the we in brace semicolon 4.) after 
block. a ends 

If-Else 3.2 

statement the syntax used if-else decisions. Formally The is express is to 



(expression) if 

statement1 

else 

statement2 

if part it expression else where expression evaluated; optional. is, is (that the The if is is true 
false value), (expression is non-zero has If is is if statement1 and a executed. there is it zero) 
is statement2 instead. else executed part, an 

are tests an shortcuts coding Since an the numeric certain value expression, of possible. if 
obvious most is writing The 



(expression) if 

of instead 



!= 0) if (expression 

it and at Sometimes this other natural be cryptic. can clear; times is 

else part if ambiguity an if-else the of an else omitted optional,there an is is when Because 
the resolved the closest associating with previous by a from This sequence. if nested is else 
For if. example, in else-less 

 


> 0) if (n 

> b) if (a 

a; = z 

else 

b; = z 

If inner what if, else shown want, isn't you by as the the goes have to we that indentation. 
proper force the association: braces must used be to 



> (n 0) { if 

> b) if (a 

a; = z 

} 

else 

b; = z 

like in situations this: The ambiguity especially is pernicious 



> 0) if (n 

< (i n; i for = i++) 0; 

> (s[i] 0) { if 

printf("..."); 

i; return 

} 

WRONG */ else /* 

n -- is negative\n"); printf("error 

compiler what want, The indentation but unequivocally get the doesn't you the shows 
if. with the can to find; the hard else kind it's bug and message, of associates a be inner This 
there idea use good nested are braces to ifs. when 

way, notice in that there a a = z is By semicolon the after 



> b) if (a 

a; = z 

else 

b; = z 

because grammatically, like a statement statement the expression an follows This if, is and 
a terminated by semicolon. ``z = is a;'' always 

Else-If 3.3 

construction The 



(expression) if 

statement 

(expression) if else 

statement 

(expression) if else 

statement 

(expression) if else 

statement 

else 

statement 

if that statements This of worth so it is often is brief discussion. separate a sequence occurs 
in way decision. evaluated are the most of writing expressions a The multi-way order; general 
this associated is terminates it and the with an if the true, is expression statement executed, 
either always, a of As whole each is code a the or chain. for group single statement statement, 
braces. in them 

 
or part default other else The of above'' the of handles none last ``none the case the where 
that explicit the case for in the action is conditions is there Sometimes satisfied. no default; 
trailing 



else 

statement 

an used checking ``impossible'' error catch condition. for be can may it or omitted, be to 

if a function a search decides particular binary illustrate To here decision, three-way a is that 
of in v The occurs value v. elements sorted increasing the in x array order. must The be 
in number -1 between returns if not. and if x 0 function (a the n-1) position and v, occurs 

to input value the If x compares v. the middle is of search Binary element first less array x the 
on value, the the otherwise on the searching focuses middle upper lower of half the table, than 
middle next the step In x half. of selected to is half. the either compare case, to element the 
the dividing value is of This two until range the the or process in range is continues found 
empty. 



... in <= /* binsearch: v[1] x v[n-1] */ <= v[0] <= find 

v[], int n) binsearch(int int x, int 

{ 

high, mid; int low, 



0; = low 

n = - 1; high 

<= (low high) { while 

(low+high)/2; = mid 

< v[mid]) if (x 

mid = + 1; high 

(x if > v[mid]) else 

mid = + 1; low 

found /* match */ else 

mid; return 

} 

match */ no return /* -1; 

} 

to less than, the greater equal middle than, fundamental The x whether is decision is or 
natural v[mid] a for else-if. at step; each this is element 

would tests loop, suffice the one (at inside 3-1. Exercise makes search binary Our two when 
the more loop one inside Write price tests outside.) of and version only with a test the 
difference the in run-time. measure 

Switch 3.4 

one is tests matches expression The switch a multi-way an decision whether that of statement 
branches values, and accordingly. a number constant of integer 



{ (expression) switch 

statements const-expr: case 

statements const-expr: case 

statements default: 

} 

 
If more or a constants expressions. case integer-valued case Each one by labeled is or constant 
expression value, be execution starts must that expressions case at matches case. the All 
are if the satisfied. of cases A none The different. is default labeled case executed other 
if isn't there match, at all if action it of takes cases is default the optional; place. no and none 
occur and default Cases any in clause the order. can 

occurrences we of all 1 In to the a space, wrote white Chapter program and each count digit, 
the a same else. is if characters, sequence of using program else ... if ... Here other 
switch: a with 



<stdio.h> #include 



space, /* others white main() count */ digits, 

{ 

nother, ndigit[10]; nwhite, int i, c, 



nother = = 0; nwhite 

< (i 10; i for = i++) 0; 

0; = ndigit[i] 

!= getchar()) { ((c EOF) = while 

{ (c) switch 

case '0': '1': case case '3': case case '4': '2': 

case '5': '6': case case '8': case case '9': '7': 

ndigit[c-'0']++; 

break; 

': ' case 

'\n': case 

'\t': case 

nwhite++; 

break; 

default: 

nother++; 

break; 

} 

} 

="); printf("digits 

< (i 10; i for = i++) 0; 

ndigit[i]); %d", printf(" 

other white = %d, printf(", space %d\n", = 

nother); nwhite, 

0; return 

} 

just causes the serve cases The break an immediate Because exit switch. from as statement 
falls code through take the labels, is execution one unless for next after case you to done, the 
a escape. switch. ways leave return action break and to A the common most are to explicit 
and also do from for, to statement be used can loops, an exit immediate force while, break 
in will this later as be chapter. discussed 

cases is to it several blessing. through a mixed cases be the side, positive On allows Falling 
this single example. normally a attached the in as implies action, also to with that But digits it 
Falling end through to next. break case with a must from prevent through falling to the each 
program being disintegration is to the modified. prone case one not is another to robust, when 
exception of used multiple labels be a should fall-throughs for With single the computation, 
commented. and sparingly, 

 
(the form, even put a the it's here) though last a As good matter after of break default case 
bit day added this end, logically unnecessary. when another the case at gets of Some 
will programming save you. defensive 

like function that Exercise 3-2. converts a and tab newline escape(s,t) characters Write 
as \n and t Use a sequences s. like copies switch. string visible into the escape Write to \t it 
real the converting the into a function other direction sequences as escape well, characters. for 

and For While 3.5 - Loops 

and have encountered We loops. for the already In while 



(expression) while 

statement 

is evaluated. statement expression and the expression If it executed is is non-zero, re- is 
cycle which point until This zero, at evaluated. continues becomes execution expression 
statement. after resumes 

statement for The 



expr2; expr3) for (expr1; 

statement 

to equivalent is 



expr1; 

{ (expr2) while 

statement 

expr3; 

} 

the in Section of for is described except behaviour which 3.7. continue, 

expressions. of for Grammatically, the loop components commonly, expr1 Most a are three 
Any and a of is expression. the expr2 expr3 and function or assignments are calls relational 
expr3 semicolons If is remain. or omitted, must parts three although omitted, be can the expr1 
expr2, dropped is as simply it If test, the is from it is expansion. taken not the present, 
so true, permanently 



{ (;;) for 

... 

} 

break loop, or such a be an presumably to ``infinite'' return. by means, other broken as is 

For largely of example, matter preference. in a to Whether for or while use is personal 



= getchar()) c c || while ((c == ' '\n' ' == || '\t') = 

space white */ /* characters skip ; 

no is most or is the while there initialization so natural. re-initialization, 

it a and keeps initialization since the simple for The there when preferable is is increment 
is close most the This visible control together and statements obvious the of top at loop. loop 
in 

 


< (i n; i for = i++) 0; 

... 

array, for of processing is elements Fortran analog the of the which idiom the n C first the an 
index the variable however, the The loop Pascal for. or i is perfect, not analogy since DO 
of for Because the reason. components for any its retains loop the when value terminates the 
expressions, arithmetic progressions. loops arbitrary restricted to are for not Nonetheless, are 
of computations initialization a the increment for, into is it force to style bad unrelated and 
loop are control for which better operations. reserved 

to example, its converting string another a here is larger numeric of for atoi version a As 
copes is with Chapter it general This slightly more one optional the in one than 2; equivalent. 
(Chapter and 4 same space leading or sign. optional does an which white + the shows - atof, 
floating-point numbers.) conversion for 

of structure form the input: of program the reflects the The 

space, white if any skip 
if any get sign, 
convert it and get part integer 

clean its state process does Each things a and The part, next. step leaves whole for in the 
part character could terminates on not first a number. of that be the 



<ctype.h> #include 



2 integer; version */ /* atoi: s convert to 

s[]) atoi(char int 

{ 

n, sign; int i, 



white (i skip space */ = isspace(s[i]); 0; i++) /* for 

; 

: ? -1 1; sign = == (s[i] '-') 

== skip sign || (s[i] '-') /* if '+' == */ s[i] 

i++; 

isdigit(s[i]); i++) 0; for = (n 

- + (s[i] '0'); n = * 10 n 

* n; return sign 

} 

library provides to a more strings function of conversion elaborate The strtol standard for 
of integers; Appendix 5 long see B. Section 

of keeping are loop control there are when obvious centralized The even advantages more 
array a for of sort an integers. Shell nested several function following The loops. is sorting 
D. sorting is algorithm, basic in in Shell, that 1959 which The this idea invented of was L. by 
ones are rather early stages, than elements in simpler as compared, adjacent far-apart 
This tends stages to eliminate later amounts so quickly, large interchange of sorts. disorder 
to to compared decreased gradually have less do. The is interval elements between one, work 
adjacent which an interchange method. point sort the effectively becomes at 



increasing shellsort: order into /* sort */ v[0]...v[n-1] 

v[], shellsort(int int n) void 

{ 

 
i, gap, j, temp; int 



0; (gap n/2; for /= gap gap = 2) > 

< (i n; i for = i++) gap; 

v[j]>v[j+gap]; && { (j=i-gap; j-=gap) j>=0 for 

v[j]; = temp 

v[j+gap]; = v[j] 

temp; = v[j+gap] 

} 

} 

gap loops. outermost There are controls nested compared elements, between The the three 
pass n/2 until loop from shrinking of each a The by zero. it factor middle it two becomes 
is elements. each that elements steps along The innermost of loop pair compares separated the 
Since reverses gap all and by out order. that to any reduced gap are one, is of eventually 
eventually ordered the correctly. Notice makes the for the how elements generality are of 
even in though progression. fit outer as others, same an the not loop form arithmetic it the is 

often operator finds A C One ``,'', most the for is the final comma statement. use which in 
to separated right, of expressions pair is left a and by type of comma value and evaluated the 
the and value a it is the statement, type operand. possible in result the Thus are to for of right 
in in example indices two place multiple the various process parts, to for parallel. expressions 
illustrated in place. the function in which s string reverse(s), This reverses is the 



<string.h> #include 



in reverse: place s /* reverse */ string 

s[]) reverse(char void 

{ 

i, j; int c, 



j; j strlen(s)-1; for (i i 0, j--) { i++, = < = 

s[i]; = c 

s[j]; = s[i] 

c; = s[j] 

} 

} 

etc., function variables The commas in separate not comma are arguments, declarations, that 
right left to evaluation. operators, and not do guarantee 

should be strongly used sparingly. constructs most for are The Comma suitable operators uses 
where other, a and macros the to as in each multistep loop reverse, in for in related 
appropriate be comma be also computation has a single might expression. expression A for to 
a elements exchange of thought the exchange in reverse, be where can the single of 
operation: 



= j; i++, j (i i < for 0, strlen(s)-1; j--) = 

= s[j], s[j] c; c = s[i] s[i], = 

notations function that Exercise 3-3. expands a a-z in like expand(s1,s2) shorthand Write 
letters list s2. of in for either abc...xyz string the equivalent the into s1 complete Allow 
and handle a-b-c -a-z. like a-z0-9 Arrange cases and case prepared be and digits, to and 
taken - is literally. that a or leading trailing 

- Do-While 3.6 Loops 

 
condition in at test termination the we Chapter 1, discussed the and loops for while the As 
tests the at pass contrast, top. C, do-while, loop making third after By in each the the bottom 
loop at least the the always executed through body; is once. body 

do is the The of syntax 



do 

statement 

(expression); while 

is executed, If statement true, The statement then expression is is it evaluated. evaluated is 
for on. false, Except terminates. again, and When the loop expression the becomes the so 
the Pascal repeat-until do-while of to the sense test, equivalent statement. is 

that do-while from is much Nonetheless, used for. and less Experience than shows while 
function it itoa, a time time in following valuable, number is a to as to which the converts 
might inverse is than complicated character string of atoi). more The slightly job be (the 
in of digits the the them wrong generating at thought easy the because first, methods generate 
have then reverse to We string backwards, order. chosen the it. generate 



s characters in */ /* itoa: n convert to 

n, itoa(int char s[]) void 

{ 

sign; i, int 



/* ((sign n) if sign record < = */ 0) 

n = positive make n -n; */ /* 

0; = i 

order in reverse */ do { generate /* digits 

n next digit 10 = /* get s[i++] % '0'; */ + 

delete while /* it */ ((n 10) /= > 0); } 

< 0) if (sign 

'-'; = s[i++] 

'\0'; = s[i] 

reverse(s); 

} 

must necessary, since character one The do-while or at least least at convenient, be is 
braces even single if in We that the statement also n installed s, the zero. array is around used 
the even are hasty they so reader though up makes the of body the do-while, unnecessary, 
of while for will not the the while loop. a part beginning mistake 

In a not two's complement does representation, itoa of number Exercise our 3-4. version 
-(2wordsize-1). the n Explain of to why value the handle that number, negative largest is, equal 
which correctly, the it of on runs. regardless Modify not. that print to it value machine 

base the the a into Exercise 3-5. function itob(n,s,b) n that integer converts b Write 
formats string In character representation particular, the as a s s. itob(n,s,16) in 
in s. hexadecimal integer 

two. that arguments The three of third accepts 3-6. Exercise of version a Write itoa instead 
blanks converted be on must with the number is argument width; field minimum a the padded 
it if wide make left necessary enough. to 

and Continue 3.7 Break 

 
exit be able than at the convenient testing to a top other is It loop sometimes or by to from 
just exit while, as for, do, from from The bottom. an provides statement break early and 
break causes immediately. the innermost exited loop be to enclosing switch. or A switch 

of trim, and end the The following removes trailing from blanks, newlines tabs a function, 
non-tab, break loop non-blank, rightmost string, using to exit the from when a non-newline a 
found. is 



tabs, trim: newlines blanks, /* remove */ trailing 

s[]) trim(char int 

{ 

n; int 



>= (n 0; n for = n--) strlen(s)-1; 

&& ' s[n] if (s[n] != ' != '\n') s[n] && '\t' != 

break; 

'\0'; = s[n+1] 

n; return 

} 

and length scans at end string. returns of the the backwards for starts loop The the strlen 
newline. that is is for or when loop broken tab not looking character the blank first a The or 
has or been the string becomes is when n found, scanned). (that when is, negative entire one 
or that contains string empty correct should this is verify only even the when behavior is You 
characters. space white 

next is iteration it the break, continue related to statement of less used; often but causes The 
do, do that loop enclosing the test means the while to the or for, In while, begin. this and 
The immediately; passes step. increment part is in the the for, to control continue executed 
inside switch. inside a continue switch loop A applies statement not loops, to only to a 
next the loop iteration. causes 

example, this a; fragment processes array the the in only As non-negative an elements 
are skipped. negative values 



< (i n; i for = i++) 0; 

elements skip negative */ if (a[i] 0) < /* 

continue; 

elements */ positive ... do /* 

follows the the is of that complicated, part continue The used often is statement when loop 
too a level program the so that test and nest indenting would another deeply. reversing 

and labels 3.8 Goto 

the infinitely-abusable goto goto statement, the labels Formally, to. and C to provides branch 
code necessary, without easy write practice is and in never it. is always almost it to statement 
in have this goto We not book. used 

most gotos a common find The is may there Nevertheless, situations few a are where place. 
two structure, breaking or as of more such abandon to deeply some in processing nested out 
exits be since from directly only the used at loops statement break The once. cannot it 
Thus: loop. innermost 

 


... ) for ( 

... ( ) { for 

... 

(disaster) if 

error; goto 

} 

... 

error: 

mess */ the /* up clean 

can code and occur non-trivial, errors in is organization This the if handy is error-handling if 
places. several 

be as by a colon. variable the It label can is same has and followed A name, to attached a form 
scope the of function. in any the The function the same is statement as entire a goto. label 

b determining arrays have two and an whether another As problem the consider example, of a 
possibility is One element common. in 



< (i n; i for = i++) 0; 

< (j m; j for = j++) 0; 

== b[j]) if (a[i] 

found; goto 

common any */ didn't element find /* 

... 

found: 

== a[i] */ got b[j] one: /* 

... 

the written though price one, at of without involving Code always can goto a be perhaps 
the an variable. some repeated For or search becomes array extra example, tests 



0; = found 

n (i 0; for !found; && i = i++) < 

m (j 0; for !found; && j = j++) < 

== b[j]) if (a[i] 

1; = found 

(found) if 

== a[i-1] */ got b[j-1] one: /* 

... 

else 

common any */ didn't element find /* 

... 

statements here, relies is that goto generally code a With those like exceptions few cited on 
not and without are we harder to to maintain Although than gotos. code dogmatic understand 
if goto be at should rarely, all. statements the about seem does it matter, that used 

 


and Program Functions Chapter - 4 
Structure 

on computing and build to Functions break tasks into people smaller enable ones, what large 
done instead of of starting details from hide functions over others scratch. have Appropriate 
thus don't know clarifying to them, the need from operation program the of parts that about 
of and making pain whole, easing changes. the 

programs efficient to generally easy C consist and has C make to designed been functions use; 
A functions program more small of few ones. than one rather in many a or may big reside 
loaded may compiled source files. separately files along with together, be and Source 
functions from however, libraries. We here, not process that will previously go compiled into 
system the to from since details system. vary 

the definition the made has Function declaration is the standard area ANSI where most and 
Chapter saw first possible the type As declare we it of now to changes is C. arguments to in 1, 
function is that declared. The so of changes, also syntax when function a declaration 
many match. for detect to declarations and This makes compiler it a possible more definitions 
it properly declared, before. than arguments are errors could when appropriate Furthermore, 
are coercions performed automatically. type 

that the there particular, requires the standard rules on clarifies be of in names; scope it The 
more each object. only one Initialization of automatic arrays general: external is definition 
be initialized. now and may structures 

facilities also enhanced. The C New has a more include been preprocessor preprocessor 
of conditional macro compilation directives, from way strings quoted a complete to set create 
expansion the macro process. arguments, and control better over 

of Functions 4.1 Basics 

a design and line input that let its us to contains each begin To print with, a of write program 
UNIX string a the of particular ``pattern'' of characters. case (This special is program or 
of searching letters set the grep.) For for the in pattern ``ould'' of lines example, 



Fate I with conspire Ah Love! you could and 

of grasp Things Scheme To this entire, sorry 

bits not shatter Would and -- it we then to 

the to Desire! it Heart's nearer Re-mould 

the output will produce 



Fate I with conspire Ah Love! you could and 

bits not shatter Would and -- it we then to 

the to Desire! it Heart's nearer Re-mould 

into neatly pieces: job three falls The 



another line) while (there's 

the pattern) contains if line (the 

it print 

 
to the main, code better for possible way it's is this to certainly of in Although all the use a put 
are by separate pieces small structure to making each Three part function. a better advantage 
can than be the with to because details big functions, one the deal one, and buried irrelevant in 
in interactions pieces useful be chance of is minimized. even And may the other unwanted 
programs. 

and line'' ``print in 1, a there's is getline, another it'' that wrote we function Chapter ``While 
only for means write This need a us. printf, is already has someone which provided we 
decide of the the to an occurrence routine whether contains pattern. line 

position that function the returns We can problem by that writing strindex(s,t) a or solve 
Because the s string not t string contain in t. -1 s the or if index begins, arrays C does where 
and zero, so is position begin zero positive, will like indexes value at be -1 a or negative 
sophisticated When later convenient for need failure. matching, we pattern we more signaling 
same. of can (The code the standard the have only the strindex; replace to rest remain 
returns similar except a strindex, it pointer to provides library that strstr function a is that 
an index.) instead of 

Here details program is the straightforward. the of this Given in filling design, much the is 
together. you For searched so whole the fit see to can pattern thing, how be now, pieces the 
We which shortly is is general a return to of not for string, a most literal the will mechanisms. 
to to make will how arrays, of initialize character how the in 5 Chapter and show discussion 
a that slightly There also when a is set parameter different program run. is the is pattern 
in you Chapter to one it of might find getline; 1. to it compare instructive the version 



<stdio.h> #include 

length input line */ #define MAXLINE /* 1000 maximum 



line[], getline(char int max) int 

source[], strindex(char char searchfor[]); int 



to pattern[] "ould"; char for search /* = */ pattern 



matching lines */ find pattern all /* 

main() 

{ 

line[MAXLINE]; char 

= 0; int found 



MAXLINE) (getline(line, > 0) while 

0) { >= if pattern) (strindex(line, 

line); printf("%s", 

found++; 

} 

found; return 

} 



length s, return */ /* getline: line get into 

s[], getline(char int lim) int 

{ 

i; c, int 



0; = i 

> c != && (--lim EOF && while 0 != '\n') (c=getchar()) 

c; = s[i++] 

== '\n') if (c 

c; = s[i++] 

 
'\0'; = s[i] 

i; return 

} 



return if none of strindex: s, -1 /* index in */ t 

s[], strindex(char char t[]) int 

{ 

j, k; int i, 



i++) != '\0'; { for (i 0; = s[i] 

s[j]==t[k]; (j=i, j++, && for k=0; k++) t[k]!='\0' 

; 

t[k] (k == && if > '\0') 0 

i; return 

} 

-1; return 

} 

the form has Each definition function 



declarations) function-name(argument return-type 

{ 

statements and declarations 

} 

function a minimal is Various parts be may absent; 



{} dummy() 

nothing and useful returns nothing. sometimes do-nothing is this A which function does like 
int If type is return omitted, assumed. the a as program during holder place development. is 

between just of Communication functions. A program a set and of variables definitions the is 
functions, and returned functions is by arguments through external and values the by 
source can program file, the any The occur in functions can in source the order and variables. 
into function is files, split as no be multiple long split. so 

function returning from to value called its a return The mechanism the is statement for the 
follow return: can caller. expression Any 



expression; return 

necessary. be type if function The expression converted to the the of return Parentheses will 
but often around are are they the used optional. expression, 

to the Furthermore, be value. need no returned calling The to free is function ignore there 
also in returns the Control no after that case, return; to is to returned value caller. expression 
by no reaching of function execution caller value when with the off end'' the ``falls the the 
if not returns illegal, right sign value function a of but closing is brace. a It probably a trouble, 
In value from function return a and to no case, value, a one from if place its fails another. any 
be garbage. to ``value'' certain is 

program returns This a status found. main, matches of from The the pattern-searching number 
available called the use is environment that value for the program by 

multiple how source that on and mechanics to compile of files a program C load resides The 
the On system, cc UNIX example, command the from vary the to system one next. for 
in 1 three functions stored job. in does the Chapter files that three the Suppose are mentioned 
Then main.c, the strindex.c. called getline.c, command and 

 


getline.c strindex.c cc main.c 

three files, and placing the getline.o, object main.o, files resulting compiles code the in 
an them error, If is an then all into loads say file a.out. called executable there strindex.o, 
the file previous result with recompiled main.c, can be the object itself the and by loaded in 
the command files, with 



getline.o strindex.o cc main.c 

command uses files the ``.c'' source ``.o'' distinguish to versus The naming cc convention 
files. object from 

position function which Exercise 4-1. returns the the rightmost of strindex(s,t) the Write 
there of if is none. t s, in or -1 occurrence 

Returning Non-integers 4.2 Functions 

value examples (void) a our So returned no functions What of int. far have if or either an 
return some cos other type? and numerical sin, sqrt, many function functions must like 
other specialized with functions return deal types. to how other return To double; illustrate 
to write its the s the let and use us double- atof(s), converts which function string this, 
which if extension precision floating-point of atof showed versions we an atoi, equivalent. 
sign 2 and or Chapters of handles optional 3. the and and in It presence decimal an point, 
input part version high-quality a absence of or fractional not part. is Our conversion either 
library we use. includes to standard an care that routine; space more take would than The 
declares it. <stdlib.h> atof; header the 

is the The type atof returns, name int. type since of First, declare itself it must value not it 
function name: precedes the 



<ctype.h> #include 



to atof: double s /* convert */ string 

s[]) atof(char double 

{ 

power; val, double 

sign; i, int 



white (i skip space */ = isspace(s[i]); 0; i++) /* for 

; 

: ? -1 1; sign = == (s[i] '-') 

s[i] (s[i] == || if == '-') '+' 

i++; 

isdigit(s[i]); i++) 0.0; for = (val 

- + (s[i] '0'); val = * 10.0 val 

== '.') if (s[i] 

i++; 

isdigit(s[i]); 1.0; { (power i++) = for 

- + (s[i] '0'); val = * 10.0 val 

10; *= power 

} 

/ power; val return * sign 

} 

a routine that non-int know returns value. must and Second, the important, as just calling atof 
The ensure declaration the routine. to way this is to is atof in explicitly declare calling One 
this balancing), which calculator in for check-book shown primitive adequate reads (barely 

 
printing a adds the and up, running sign, number one preceded optionally line, per with them 
each input: sum after 



<stdio.h> #include 



100 MAXLINE #define 



calculator */ /* rudimentary 

main() 

{ 

atof(char []); double sum, 

line[MAXLINE]; char 

line[], getline(char int max); int 



0; = sum 

MAXLINE) (getline(line, > 0) while 

+= atof(line)); printf("\t%g\n", sum 

0; return 

} 

declaration The 



atof(char []); double sum, 

is is a argument sum says and atof double one a takes that variable, char[] function that that 
a double. and returns 

atof must itself in atof The defined If declared to be call function and it and consistently. the 
detected source error by the be the file, have main the in types inconsistent same will 
would (as were mismatch the compiler. But is more separately, likely) compiled atof not if 
int, that treat and would an meaningless main detected, be a return would atof double as 
result. would answers 

definitions, said declarations this how match might about the In we what of light have must 
function reason prototype, there no can surprising. a mismatch The a is if that happen is seem 
an by first function is appearance declared such as expression, its in implicitly 



atof(line) += sum 

in that an a name If previously occurs not followed has is a been by expression declared and 
is is assumed name, function context parentheses, declared by it to be function a to the left 
int, and function nothing is a about if Furthermore, assumed return its an arguments. 
arguments, include in does as not declaration 



atof(); double 

be taken assumed all is that nothing to mean of to arguments too that atof; about is the 
is turned of list argument parameter checking off. This empty special the meaning intended is 
bad to use compile permit But with to it it's with to programs older compilers. C new idea a 
no arguments, if arguments, them; takes use declare C new function the If programs. takes it 
void. 

terms declared, of to in write atof, we could properly it: (convert string a atoi int) Given 



integer atoi: string /* atof using s convert */ to 

s[]) atoi(char int 

{ 

s[]); atof(char double 



 
atof(s); (int) return 

} 

the of return of value Notice the the declarations The and statement. the expression structure 
in 



expression; return 

the the value is Therefore, the converted type of to of before return the function taken. is 
return, int appears since it this the when a atof, automatically converted is double, to in 
returns discard information, int. atoi does potentionally function an operation however, This 
is cast that intended, explicitly operation and states some so it. of warn compilers The the 
warning. any suppresses 

of 4-2. notation the form Extend to atof handle scientific Exercise 



123.45e-6 

optionally by E signed or an exponent. e a where be may number floating-point followed and 

Variables External 4.3 

or consists functions. are variables set C of a program The external which objects, of either A 
describes in to adjective ``external'' ``internal'', used arguments and the contrast which is 
of External are variables defined defined functions. function, and any variables outside inside 
potentionally are always to thus Functions themselves are available functions. external, many 
default, not defined By functions. because C allow functions other to inside be external does 
same all them name, to the even references and variables property the have functions that by 
compiled separately, this are references calls the standard (The to from same functions thing. 
linkage.) analogous to this external variables are property In external Fortran sense, 
later block We how Pascal. see to in blocks COMMON the in variables or outermost will 
variables and file. functions that source visible single a are define only external within 
variables alternative to globally external provide an Because are they function accessible, 
return Any function for and between functions. arguments values data may communicating 
has it if been name, name declared by an access referring by variable external to the 
somehow. 

are number shared variables external If a of variables functions, must among be more large 
however, than pointed 1, Chapter convenient and long argument in lists. out As this efficient 
effect for have on can bad program it should reasoning some with applied be caution, a 
lead connections between programs and many data structure, to too functions. with 

scope useful of External variables their also lifetime. Automatic and because greater are 
is come when entered, existence function and into are variables function; a to internal they the 
so on hand, they other permanent, can the when disappear External left. is it variables, are 
must the if share Thus functions some next. values retain invocation function one from to two 
convenient calls if in neither data, is most other, is the data yet it kept the often shared 
out variables and via arguments. rather being than passed in external 

a this calculator is write a us issue with examine program example. problem The larger to Let 
it operators is will the that and Because -, the +, implement, provides * calculator easier /. to 
some notation Polish by used use reverse instead of is infix. notation (Reverse pocket Polish 
Forth and and like calculators, in Postscript.) languages 

an each follows In reverse its notation, expression like infix operator operands; Polish 

 


(4 * 5) - + 2) (1 

as entered is 



5 4 * 2 + - 1 

how needed; as know we Parentheses are the notation as is long unambiguous many not 
operator expects. operands each 

operator simple. onto an when The implementation Each operand stack; is a pushed arrives, is 
is binary popped, applied is operator to operators) proper the (two operands of number for the 
above, pushed 1 back and In 2 instance, and the onto them, is the stack. result the for example 
and replaced then 5 pushed difference, pushed, by their then replaced Next, and 4 -1. are are 
The of replaces -1 on and 9. the their stack. is The sum, which -9, by 9, on value them product 
the the end encountered. of the and when is line stack input top popped is of printed the 

operation a performs on that proper each loop structure The is program the of thus the 
it appears: as operator operand and 



end-of-file is not indicator) while (next or operator operand 

(number) if 

it push 

(operator) if else 

operands pop 

operation do 

result push 

(newline) if else 

of stack top pop print and 

else 

error 

error pushing detection by time a operation and popping of and are but trivial, stack the The 
better they to function added, recovery that is long a are in are enough separate put it each 
a the program. be should than to code throughout there the And whole separate repeat 
or input operator operand. function for the fetching next 

is decision where which design The yet discussed has that that is, main not is, the been stack 
in directly. main, the it routines to it possibility stack On the access is and and keep pass 
need to to But doesn't that stack the routines position know and it. pop push main current 
So that we and operations. stack; the control the variables have only push does it pop about 
to the information accessible variables decided to stack and external its in associated the store 
not and to but push pop main. functions 

the into program we of easy this code is outline as If now for enough. think Translating 
will in source existing like look file, one this: it 

#includes 
#defines 

for main function declarations 

... } main() { 

and pop push external for variables 



 
main() 

{ 

type; int 

op2; double 

s[MAXOP]; char 



!= getop(s)) { ((type EOF) = while 

{ (type) switch 

NUMBER: case 

push(atof(s)); 

break; 

'+': case 

pop()); + push(pop() 

break; 

'*': case 

pop()); * push(pop() 

break; 

'-': case 

pop(); = op2 

op2); - push(pop() 

break; 

'/': case 

pop(); = op2 

!= 0.0) if (op2 

op2); / push(pop() 

else 

divisor\n"); zero printf("error: 

break; 

'\n': case 

pop()); printf("\t%.8g\n", 

default: 

command unknown %s\n", s); printf("error: 

break; 

} 

} 

0; return 

} 

{ f) } push( ... double void 

{ pop(void) ... } double 



... } { int s[]) getop(char 
by getop routines called 
source discuss split more or Later we how this two might into be files. will 

of loop operand; containing function on is or this the a The a main switch is big operator type 
typical shown in of more the one a use than . switch 

3.4 Section 



<stdio.h> #include 

atof() */ for #include /* <stdlib.h> 



or MAXOP operand operator */ 100 max /* size of #define 

was NUMBER number found */ '0' signal /* that a #define 



[]); getop(char int 

push(double); void 

pop(void); double 



Polish reverse calculator */ /* 

 
operands * order popped the Because + are commutative which operators, in the are and 
be but distinguished. right must and is for - irrelevant, In the and left / operand combined 



WRONG */ /* push(pop() pop()); - 

evaluated which is right in the of are two guarantee the To order calls the not pop defined. 
a necessary temporary main. is order, first into pop did to we it the in variable value as 



of MAXVAL /* #define stack val maximum 100 */ depth 



free sp 0; int position stack /* = */ next 

stack */ value double /* val[MAXVAL]; 



value push: stack onto /* push */ f 

f) push(double void 

{ 

< MAXVAL) if (sp 

f; = val[sp++] 

else 

push can't f); stack %g\n", full, printf("error: 

} 



value pop: and /* stack from return pop */ top 

pop(void) double 

{ 

> 0) if (sp 

val[--sp]; return 

{ else 

empty\n"); stack printf("error: 

0.0; return 

} 

} 

any external function. index is A defined of it and if stack variable is stack Thus outside the 
main shared itself these But and must by push be does are outside defined pop functions. that 
to the hidden. stack or be position can representation stack not - refer the 

next turn operator that the implementation us to the now or getop, function the of fetches Let 
is Skip digit blanks The the a a or next and operand. easy. task If is tabs. not character 
return it. a Otherwise, collect include string might (which a hexadecimal of point, digits 
number NUMBER, signal decimal point), that return been collected. has the a and 



<ctype.h> #include 



getch(void); int 

ungetch(int); void 



operand or numeric */ /* getop: next get character 

s[]) getop(char int 

{ 

c; i, int 



|| = == while ((s[0] ' c == '\t') c getch()) ' = 

; 

'\0'; = s[1] 

!= '.') c if && (!isdigit(c) 

a not */ c; number /* return 

0; = i 

integer collect */ (isdigit(c)) part /* if 

= getch())) c while = (isdigit(s[++i] 

; 

part collect fraction */ if (c '.') == /* 

 
= getch())) c while = (isdigit(s[++i] 

; 

'\0'; = s[i] 

!= EOF) if (c 

ungetch(c); 

NUMBER; return 

} 

that and a has getch What often case It that ungetch? determine are is it program the cannot 
characters too instance that One collecting make much. enough read has it until input read is 
But until then is complete. non-digit a the first number: the seen, number the is not up 
prepared one character not is program has character too it far, that a for. read 

character. be possible unwanted the The problem solved if ``un-read'' it to were Then, would 
could program push so the every too it one the reads on time character input, it many, back 
read. could easy behave rest had simulate it's to never as the code of it the if Fortunately, been 
character, by next writing a the of delivers getch pair un-getting cooperating a functions. 
before considered; will input character return be new input. reading ungetch them to 

work together shared is simple. a puts into characters ungetch How the they pushed-back 
else, character and there anything reads -- array. getch a calls the if buffer from is buffer 
records buffer the index that There if is empty. the position also an be must variable getchar 
in character buffer. the the current of 

retain and their ungetch must are the the index buffer values by and getch shared and Since 
getch, both we ungetch, Thus write and routines. calls, between external be must they to can 
variables as: their shared 



100 BUFSIZE #define 



for buffer */ buf[BUFSIZE]; ungetch /* char 

in bufp position buf */ = /* 0; next free int 



character (possibly pushed-back) */ int getch(void) get /* a 

{ 

buf[--bufp] (bufp : ? return > getchar(); 0) 

} 



back ungetch(int /* void input on push c) */ character 

{ 

>= BUFSIZE) if (bufp 

many characters\n"); printf("ungetch: too 

else 

c; = buf[bufp++] 

} 

library includes we a function pushback; that of character ungetch The provides standard one 
array in for single it will have an 7. than Chapter rather discuss We a the used pushback, 
more a approach. to general illustrate character, 

extend basic it's Exercise 4-3. straightforward the calculator. Add the framework, to Given 
negative provisions for numbers. the modulus operator (%) and 

without the of popping, elements stack to top 4-4. Exercise to commands the Add print the 
clear two a the Add to stack. elements. it, duplicate the swap to and top command 

 
<math.h> access sin, See pow. Exercise 4-5. to library and functions exp, like in Add 
Section 4. Appendix B, 

to for variables. Exercise 4-6. (It's commands twenty-six variables provide handling easy Add 
names.) recently printed a single-letter the most with Add for value. variable 

onto will an the back string input. push 4-7. Exercise ungets(s) routine a Write that entire 
it buf bufp, Should ungets or about use ungetch? just and should know 

pushback. that more of character Exercise 4-8. there will one never than be Modify Suppose 
ungetch accordingly. getch and 

Our getch Decide and ungetch correctly. not EOF pushed-back do Exercise handle 4-9. a 
implement an pushed your is then design. EOF their what be to ought properties if back, 

this alternate read line; input Exercise 4-10. organization uses entire getline an to makes An 
use and to this approach. ungetch Revise unnecessary. the calculator getch 

Rules Scope 4.4 

program external need the and The up C that compiled variables be functions make at not a all 
files, program kept and be several previously may time; same of text source the the in 
questions loaded libraries. compiled routines Among be interest are of from the may 

are properly declared written How variables are  declarations that during so 
compilation? 
connected declarations the properly be  How arranged so will that pieces all when are 
is loaded? the program 
only How is one copy? are organized declarations so there  
variables initialized? external  are How 


As these calculator files. several Let us topics by into reorganizing program the a discuss 
splitting, calculator but of the practical to worth too fine is a matter, small illustration it be is 
in arise programs. issues larger that the 

of is the the be used. a can name program For which scope The within of an name part the 
function a scope in the the which function, variable automatic beginning the at declared of is 
are declared. same functions different the name Local variables in of name the unrelated. is 
effect of which local function, in variables. the same The the of true is parameters are 

at variable is or scope from to it declared the a The external of lasts an function which point 
main, the sp, defined of the For if being pop file and end compiled. are val, example, push, 
shown one in in that above, the file, is, order 



... } main() { 



= 0; int sp 

val[MAXVAL]; double 



... } { void f) push(double 



{ pop(void) ... } double 

 
push sp and no variables then be in val naming and by the may them; pop used simply 
push needed. and main, are names declarations But these are pop not in visible are nor further 
themselves. 

if external before variable is is hand, defined, the or referred if other be to On to is it it an 
then different an is used, from in source file a extern one it where the being defined 
mandatory. is declaration 

its to of and variable It is distinguish between external the an declaration definition. important 
announces the also properties of definition variable a type); a A (primarily declaration its 
the aside. If lines causes storage be to set 



sp; int 

val[MAXVAL]; double 

cause the sp storage variables val, to external outside appear they function, any of define and 
that serve On as set the other file. the rest the be also aside, for and declarations source of 
lines the hand, 



sp; int extern 

val[]; double extern 

double source and file val that rest is for a an of the is int declare sp (whose array that the 
storage not variables for the reserve them. create is size they but elsewhere), determined do or 

among only all the be There an variable definition make one that must of up the external files 
also files to may (There source program; may contain it. extern access declarations be other 
in the with file containing specified definition.) be must the extern Array declarations sizes 
extern with an declaration. the definition, are but optional 

only of external Initialization the with variable an definition. goes 

pop not could functions and organization it a likely is be this the program, for push Although 
another. file, Then and in variables in and the one these and defined sp val initialized defined 
to and would definitions them tie be declarations together: necessary 

file1: in 



sp; int extern 

val[]; double extern 



... } { void f) push(double 



{ pop(void) ... } double 

file2: in 



= 0; int sp 

val[MAXVAL]; double 

definitions, declarations of function the Because the in file1 outside lie and ahead they extern 
This declarations all same for file1. organization suffices to apply set one functions; all of of 
in needed one followed use definition also if the bee file. sp val and of their would 

Files Header 4.5 

 
might consider be files, it calculator is dividing the now is into source several program as Let 
one components main in go each of were substantially would bigger. function The file, the 
second and go file, variables a stack.c; their we which push, main.c; call will pop, into 
fourth getch go file, ungetch a getch.c; and goes getop getop.c. third, a into Finally, into 
come the because we separate they from a separately-compiled from others would them 
a in realistic program. library 

shared about definitions among the declarations files. - is There to thing more one worry and 
this, want to only to get possible, copy we that and is much As there as keep one centralize so 
a program place in material right as evolves. Accordingly, common we this will header the 
in will (The described is file, calc.h, be included line as #include necessary. Section which 
looks The like then 4.11.) resulting this: program 



the tradeoff information access to desire is between the a it each have file that only There 
maintain the files. practical for is to header Up harder reality needs and its it job that more to 
that size, to file header some moderate it is one probably have best contains program 

 
of to the we is everything any parts shared the be is that between decision program; two that 
be a organization would headers made here. much larger more program, and more needed. For 

Variables Static 4.6 

are in private stack.c, variables bufp of the use in and The val sp and and buf for getch.c, 
accessed and meant by not be anything are functions the source respective their in files, to 
scope declaration, variable the limits else. The applied to function, an or external of static 
provides the a External thus the object rest of to way file compiled. being source static that 
be like the must which to hide buf and combination, bufp getch-ungetch in external names 
getch be and to of which they shared, yet can ungetch. not visible be should users so 

If specified declaration static. word Static storage by prefixing the the with normal the is 
one two are two routines compiled the as in file, variables in and 



for char ungetch buffer static buf[BUFSIZE]; */ /* 

bufp in buf 0; int free position static = next */ /* 



{ getch(void) ... } int 



... } { void c) ungetch(int 

and routine bufp, conflict other then to buf be will will names no able not and access those 
program. names In that same with of same other the in way, the files variables the the same 
val use to declaring and manipulation and for stack pop be be by hidden, can sp push 
static. 

be used but applied variables, can to for external The most is declaration static often it 
the Normally, visible of part functions as function names any are to global, entire well. 
the function file invisible of static, If is declared a in its is name however, outside program. 
is declared. which it 

declaration can are also be variables to static Internal applied The internal static variables. 
a particular they function just automatics, automatic unlike but as local variables to are, 
activated. rather each is function remain in than coming the and time going This existence 
internal within a variables that permanent storage means static private, single provide 
function. 

use doesn't use an to Hint: internal need 4-11. Exercise that so getop Modify it ungetch. 
variable. static 

Variables Register 4.7 

declaration advises heavily the compiler be the will question that A variable register in 
registers, are placed which be machine may to The used. register that is idea variables in 
smaller and advice. faster programs. the compilers ignore to But result are in free 

declaration register looks like The 



x; int register 

c; char register 

 
and only to to applied variables the be so and declaration register The on. can automatic 
of it looks function. parameters later case, formal a this like In 



long n) register f(register m, unsigned 

{ 

i; int register 

... 

} 

the restrictions register In practice, variables, are of underlying realities on reflecting there 
and function kept only be registers, certain may Only hardware. in variables few a each in 
allowed. since the register are harmless, however, types Excess are word declarations 
to declarations. is take it possible the And is register or excess for ignored disallowed not 
whether covered 5), the Chapter of variable in of address (a variable register a topic regardless 
of in restrictions types and is actually a register. number The on specific register placed 
to machine. machine variables from vary 

Structure Block 4.8 

languages, a sense similar or C is block-structured language Pascal in of the because not 
can be On variables hand, functions may defined within other other the functions. be not 
a of variables fashion in function. Declarations defined block-structured a (including within 
follow the the left brace just introduces not statement, that initializations) any may compound 
begins a named function. Variables identically in any hide declared one this that way 
For blocks, until brace. right variables in and remain matching in the existence example, outer 
in 



> (n 0) { if 

new i; i a int /* */ declare 



< (i n; i for = i++) 0; 

... 

} 

any is this the is ``true'' the unrelated scope to the variable of of if; the branch outside i i i 
each initialized block time a initialized the in block. the declared variable automatic An and is 
entered. is block 

variables variables, external and functions including parameters, formal also hide Automatic 
Given name. declarations the the same of 



x; int 

y; int 



x) f(double 

{ 

y; double 

} 

a function double; parameter, is of within f, occurrences the outside refer the to x which then 
variable to same the of f, they the external true int. is The y. refer 

names it's outer best a names the an scope; that to As style, matter variable of avoid in conceal 
is for too error potential confusion great. and 

Initialization 4.9 

 
been mentioned to in passing peripherally times always but many Initialization so has far, 
have of now discussed rules, we the the other some summarizes section This topic. some that 
classes. storage various 

absence of be explicit initialization, to and guaranteed are external In static the variables 
zero; (i.e., garbage) and to have undefined initialized automatic variables initial register 
values. 

with be defined, name the Scalar variables initialized when following they by are an may 
and sign an expression: equals 



= 1; int x 

= '\''; char squota 

24L; * * long day 60L 1000L milliseconds/day */ /* 60L * = 

a variables, initializer For external must static expression; the constant the be and 
done execution. For conceptionally is program begins initialization once, the automatic before 
may restricted a be being it any to register and is initializer the variables, not constant: 
For involving calls. example, the previously values, defined even function expression 
could search in initialization of Section binary written as be program 3.3 the 



v[], int n) binsearch(int int x, int 

{ 

= 0; int low 

- 1; n int = high 

mid; int 

... 

} 

of instead 



high, mid; int low, 



0; = low 

n = - 1; high 

initialization for assignment automatic effect, just shorthand In of are statements. variables 
used prefer of generally have Which form is largely We a taste. matter explicit to 
initializers in the declarations are from to away further harder assignments, see because and 
use. of point 

initializers its a enclosed with of in declaration array An by initialized be may following list 
the to array number an with of initialize and braces For commas. by separated example, days 
each month: days in 



30, { 31 31, 31, 31, days[] 31, 28, = } 31, 31, 30, 30, 30, int 

by of counting compute length is the the array size the the will compiler omitted, the When 
this 12 in case. initializers, of there which are 

specified fewer size, for are If array the for be initializers will there an zero the than others 
There automatic is too initializers. is static variables. It and no error have to an many external, 
an repetition element array specify way nor initialize an of of middle to initializer, an in to the 
values supplying as preceding without all well. the 

of a the be instead of arrays special case are braces a may string initialization; used Character 
notation: commas and 

 


= "ould"; char pattern 

longer a but the is shorthand equivalent for 



'l', pattern[] { char '\0' 'd', 'o', = }; 'u', 

case, the '\0'). array size terminating five the plus is In (four this characters 

Recursion 4.10 

either is, may directly function itself or a functions C recursively; used be may that call 
printing a the number as before, character mentioned we a indirectly. string. Consider As 
generated in digits, the wrong high-order low-order before available order: digits digits are are 
the they to but way other be have around. printed 

in this as problem. are store are array they the On There to two to solutions is an digits 
section them 3.6. with in reverse then in the print The as did we order, itoa generated, 
with printd itself any calls cope leading first is alternative in solution, recursive a which to 
largest the version the on digits, then trailing digit. fail Again, can this negative prints 
number. 



<stdio.h> #include 



in n */ printd: decimal print /* 

n) printd(int void 

{ 

< (n 0) { if 

putchar('-'); 

-n; = n 

} 

/ 10) if (n 

10); / printd(n 

10 % + '0'); putchar(n 

} 

all invocation fresh the a of automatic gets a When recursively, itself calls function each set 
of the the previous set. receives in printd first This variables, printd(123) independent the 
a passes 12 turn to a 123. 1 It printd, third. in n argument which = The passes to second 
2, the That then level. prints returns second printd third-level returns then 1, prints to printd 
prints the level. to and 3 That first terminates. one 

algorithm recursion quicksort, Another good a of by C.A.R. developed is sorting example 
partitioned element and in chosen others two is in Hoare array, an Given 1962. one the 
greater less than same those subsets element those the it. than to - partition The or and equal 
fewer two a than When has two subsets. is process to recursively applied then the subset 
this it need elements, the stops any doesn't recursion. sorting; 

it's quicksort one the of Our fastest but not We is simplest. version the use of possible, the 
subarray each partitioning. element for of middle 



increasing qsort: order into /* sort */ v[left]...v[right] 

left, int right) qsort(int int v[], void 

{ 

last; i, int 

i, int j); swap(int int v[], void 



 
array (left if contains */ >= /* right) do nothing if 

two than */ /* elements fewer return; 

move left, + swap(v, elem partition right)/2); (left */ /* 

to /* */ = v[0] left; last 

i++) + i for (i <= left partition */ /* 1; right; = 

< v[left]) if (v[i] 

i); ++last, swap(v, 

partition left, elem restore swap(v, last); */ /* 

last-1); left, qsort(v, 

right); last+1, qsort(v, 

} 

three swapping function occurs it We moved operation into because a swap separate times the 
qsort. in 



and v[i] */ swap: v[j] interchange /* 

i, int j) swap(int int v[], void 

{ 

temp; int 



v[i]; = temp 

v[j]; = v[i] 

temp; = v[j] 

} 

any includes that of objects The standard a version sort of can qsort type. library 

values no somewhere the of Recursion may saving in stack storage, a since being provide 
more be recursive compact, But is and faster. must processed will Nor maintained. be it code 
non-recursive write understand often much than to Recursion is equivalent. and the easier 
for recursively nice defined data a like see will structures especially trees, convenient we 
Section 6.6. example in 

that the is, version itoa; printd 4-12. ideas of Adapt convert write recursive a to of Exercise 
calling integer a an recursive a string into routine. by 

reverse(s), recursive of Exercise 4-13. the a reverses the which version function Write 
in place. string s 

C Preprocessor 4.11 The 

certain language a facilities by conceptionally of is which means C a provides preprocessor, 
step in to compilation. The #include, most are features two separate frequently first used 
token compilation, to by #define, a an and the include file a of contents during replace 
of section include Other sequence in this arbitrary characters. described conditional features 
macros and with arguments. compilation 

Inclusion File 4.11.1 

makes it other easy to (among collections declarations and handle File of inclusion #defines 
of line form Any the source things). 



"filename" #include 

or 



<filename> #include 

the the filename file by is file If of for contents searching replaced the the is filename. quoted, 
there, program the was begins is is if name not found; typically source where it the if or found 

 
file. and implementation-defined the find enclosed in >, searching to follows rule an An < 
contain itself lines. file #include may included 

to the a include of file, common beginning are There lines #include several often at source 
and function prototype declarations, statements access the #define extern to declarations or 
functions from files; headers like be (Strictly not need <stdio.h>. for speaking, library these 
are are accessed implementation-dependent.) the details how of headers 

program. preferred declarations large a #include is way to for tie together the It the 
and the supplied definitions same guarantees that source files the will with be variable all 
thus eliminates included a particularly an kind when Naturally, nasty declarations, of and bug. 
changed, must be files is on it file all depend recompiled. that 

Substitution Macro 4.11.2 

has definition the form A 



replacement text #define name 

of the - the kind occurrences token simplest calls It substitution macro a for of subsequent 
has the form replacement will in a same as a text. name by be name replaced The the #define 
rest replacement the the is variable name; text is text arbitrary. replacement Normally of the 
continued definition may placing at the a \ long several end by line, the lines but of a be onto 
defined be with of to each of name The its continued. from line scope point #define a is 
use end being may definition definition to of the A source compiled. file previous the 
are made quoted only for within and place take tokens, definitions. do Substitutions not 
substitution if name, no be strings. For YES is would a there defined in example, 
in YESMAN. printf("YES") or 

text. name replacement For example may defined be with any Any 



infinite forever loop /* #define for */ (;;) 

infinite for an loop. defines a word, new forever, 

can with the be so text different arguments, is It define to possible also macros replacement 
calls of max: the macro. called an macro a As for example, different define 



? max(A, ((A) #define : (A) > B) (B)) (B) 

code. like Each expands in-line call, it a function looks occurrence use max of a into Although 
corresponding B) replaced actual be the argument. will a of A (here parameter formal or by 
line the Thus 



max(p+q, r+s); x = 

the line by will replaced be 



: ? (p+q) (r+s)); x = > ((p+q) (r+s) 

any consistently, will data macro for type; this long So are arguments the as treated serve 
different need data with no there of for different would for there is kinds be types, max as 
functions. 

 
expressions the will The pitfalls. If you expansion of some max, notice you are examine 
or involve like input effects operators and side twice; evaluated if bad is this they increment 
instance For output. 



/* j++) WRONG */ max(i++, 

to larger make taken parentheses care increment twice. Some the sure has be to also with will 
of when the is order what happens the evaluation consider macro preserved; 



/* square(x) WRONG x #define x */ * 

as square(z+1). is invoked 

are <stdio.h>, in One macros comes from Nonetheless, valuable. example which practical 
of are to overhead run-time getchar and often defined the as avoid macros a putchar 
per are also processed. call in <ctype.h> function character functions usually The 
macros. as implemented 

a undefined function, routine really usually may with #undef, be not ensure a that to is Names 
macro: a 



getchar #undef 



{ getchar(void) ... } int 

are not is replaced within name strings. parameter a quoted Formal If, parameters however, 
a # quoted be into replacement by in the a string the will combination text, expanded preceded 
parameter replaced string by the with argument. combined be actual with This the can 
print a debugging macro: concatenation to for make, example, 



= " expr) dprint(expr) %g\n", printf(#expr #define 

as in invoked, When is this 



dprint(x/y) 

is macro expanded into the 



= " &g\n", x/y); printf("x/y" 

effect so the is and the are strings concatenated, 



&g\n", x/y); printf("x/y = 

is is by replaced so by argument, the the result each each actual and \ Within \" legal a \\, " 
constant. string 

actual provides way The preprocessor to ## during macro arguments a concatenate operator 
parameter parameter is a the replacement If in the a replaced is to adjacent text ##, expansion. 
result argument, is removed, the and the the ## actual re- white are space surrounding and by 
concatenates For the scanned. two its macro example, arguments: paste 



## back front #define back) paste(front, 

the creates name1. paste(name, token 1) so 

in nested Appendix may found ## rules uses of for A. arcane; details further are be The 

arguments macro that Exercise 4-14. interchanges a type t. of swap(t,x,y) two Define 
will help.) (Block structure 

 
Inclusion Conditional 4.11.3 

statements control itself It is with to are evaluated that preprocessing conditional possible 
This provides value a way the include on depending to during code preprocessing. selectively, 
evaluated conditions during compilation. of 

casts, evaluates (which sizeof, include The #if a constant not integer may expression or line 
#elif the lines or #endif enum constants). expression is an non-zero, until subsequent or If 
included. else-if.) The preprocessor are is like #else (The #elif expression statement 
0 #if name and defined, defined(name) in is 1 been if has the otherwise. a 

only make once, hdr.h included the example, sure that to the of file a contents are For 
conditional of a like this: the are file surrounded with contents 



!defined(HDR) #if 

HDR #define 



go hdr.h */ contents here of /* 



#endif 

the of HDR; find will The first hdr.h defines inclusions the subsequent name name inclusion 
avoid down including be to #endif. and to the skip files similar can style A used defined 
include consistently, header any each itself other then times. multiple is style this If used can 
deal user header with the to the of on headers without depends, it which the having 
interdependence. 

to the which header a This sequence name SYSTEM of to version decide include: tests 



== SYSV #if SYSTEM 

"sysv.h" HDR #define 

== BSD #elif SYSTEM 

"bsd.h" HDR #define 

== MSDOS #elif SYSTEM 

"msdos.h" HDR #define 

#else 

"default.h" HDR #define 

#endif 

HDR #include 

is forms whether defined. test name The that #ifdef The are lines #ifndef and specialized a 
been could have written first example #if of above 



HDR #ifndef 

HDR #define 



go hdr.h */ contents here of /* 



#endif 

 


and Arrays Pointers Chapter - 5 

a a variable. C, is A the of that used variable much pointer contains in Pointers address are 
partly are to and computation, partly because sometimes the a only express way because they 
in efficient can other than obtained ways. code usually they compact more to lead and be 
arrays are shows closely related; and chapter relationship this this Pointers also and explores 
exploit it. how to 

create lumped as to way Pointers have with the marvelous goto a statement impossible- been 
is they carelessly, easy used it to are programs. to-understand true certainly is This when and 
that pointers can somewhere pointers discipline, however, create point With also unexpected. 
try achieve to that will simplicity. used clarity and to illustrate. is aspect the This we be 

pointers in can rules how is main ANSI C change be make the explicit to about The 
practice in already and good effect what mandating good programmers manipulated, 
char void to * (pointer replaces as * already compilers the addition, In enforce. type void) 
a for pointer. proper generic type the 

and Addresses 5.1 Pointers 

machine with has organized. typical picture us a simplified begin an how is memory of A Let 
consecutively may be or of cells that array numbered memory manipulated addressed 
a contiguous char, byte be common or groups. One in a is any that situation can individually 
integer, cells and long. one-byte pair as short be form can bytes of treated a four a adjacent 
address. char is hold A can that four) is (often of pointer So group if two a cells an a or and c 
this pointer we situation the p is that points represent to could it, way: a 



object, gives address The unary of & the statement so the an operator 



&c; = p 

& the to variable to'' p, of c. the The is c address p said assigns and only operator ``point to 
objects in to memory: variables applied array be cannot and applies elements. to It 
or constants, register variables. expressions, 

a or when pointer, operator; to it dereferencing unary The the is * operator indirection applied 
integers points is to. the and pointer ip a y Suppose accesses pointer object x the that and are 
pointer artificial and *: This to to a shows & sequence use int. how and how declare to 



= x 2, y int = z[10]; 1, 

pointer *ip; ip int int to is /* */ a 



 
points = /* ip x to ip &x; */ now 

1 is now */ y = /* *ip; y 

0 is now */ *ip = /* 0; x 

points = /* ip z[0] to ip &z[0]; */ now 

The and the z declaration seen ip, of pointer all are The y, of we've x, what declaration along. 



*ip; int 

*ip a is the as is that expression it syntax mnemonic; The intended says of an the int. 
a variable might mimics the variable of the which syntax declaration expressions for in 
well. This as For example, reasoning to applies function declarations appear. 



atof(char *); double *dp, 

the an argument double, that and that expression *dp in of have of values atof(s) and says 
to char. pointer atof a is 

a note particular to to that should the implication also kind pointer constrained is a point You 
a pointer ``pointer is exception: a object: points to every to data (There type. specific one of 
cannot to be to used void'' of but any come hold We'll is type back dereferenced pointer itself. 
Section 5.11.) it in 

occur to in so points If then can integer x the where ip x, could, any *ip context 



*ip = + 10; *ip 

by 10. increments *ip 

the * tightly so operators, The unary and & arithmetic bind than more assignment operators 



*ip = + 1 y 

ip points while at, adds y, and to result 1, takes assigns whatever the 



1 += *ip 

to, points do what as ip increments 



++*ip 

and 



(*ip)++ 

them, in last The parentheses example; necessary expression would the this without are 
++ of associate like and points ip what it instead right because operators unary to, * increment 
left. to 

pointers are if variables, they example, be For dereferencing. can Finally, used since without 
to int, pointer iq another is 



ip = iq 

ip thus point pointed iq whatever to. making the copies into ip of contents iq, to 

and Pointers Function Arguments 5.2 

the arguments called direct for by C to functions passes function there no is value, way Since 
might function. a exchange instance, routine two For alter to the in variable a calling sorting 
not function swap. out-of-order arguments It a to write enough called is with 

 


b); swap(a, 

is function as the defined swap where 



/* swap(int WRONG y) void x, */ int 

{ 

temp; int 



x; = temp 

y; = x 

temp; = y 

} 

in swap that can't of a it. routine called and affect Because value, call arguments by the the b 
and of a b. The function swaps above copies 

pass desired the effect way calling to to values program is The the to the obtain for pointers to 
changed: be 



&b); swap(&a, 

a the address pointer In swap & a. produces &a itself, a the Since is operator the to of variable, 
accessed pointers, the parameters are operands as through them. indirectly and are declared 



and swap(int *px *py */ *px, *py) int /* interchange void 

{ 

temp; int 



*px; = temp 

*py; = *px 

temp; = *py 

} 

Pictorially: 

 


that and in called objects function it. change arguments Pointer to function a enable access the 
free-format a getint As an that consider conversion by input function performs example, 
has values, per to integer getint return one a breaking into characters of stream integer call. 
no also These signal value when have input. values there end the and it file found of more is 
used separate that paths, be what also EOF, could value for to by passed matter back no for is 
an of integer. the input value be 

its getint while return solution file a value, using status the One have is of to end function as 
is store in This function. pointer argument the converted calling integer the back the to 
Section well; see 7.4. scheme used scanf by as 

loop calls to an following integers by The fills with getint: array 



array[SIZE], n, getint(int *); int 



= != EOF; n (n && getint(&array[n]) for 0; SIZE n++) < 

; 

the array[n] input it sets Each integer in the Notice to n. call next that and found increments 
way pass for there no of essential the address to getint to Otherwise getint. array[n] is is 
the back to caller. to communicate converted the integer 

number, for next end is of getint not version a if returns of zero the Our file, a and input EOF 
valid contains a number. positive value the if input 



<ctype.h> #include 

 


getch(void); int 

ungetch(int); void 



input getint: next /* *pn into integer get */ from 

*pn) getint(int int 

{ 

sign; c, int 



space skip white */ while (isspace(c getch())) = /* 

; 

'-') c != != c if (!isdigit(c) != EOF && && '+' c { && 

a /* number not ungetch(c); it */ is 

0; return 

} 

: ? -1 1; sign = == (c '-') 

c (c == || if == '-') '+' 

getch(); = c 

c (*pn = isdigit(c), for = getch()) 0; 

- + (c '0'); *pn = * 10 *pn 

sign; *= *pn 

!= EOF) if (c 

ungetch(c); 

c; return 

} 

used ordinary We getch variable. also and int getint, Throughout as used is *pn an have 
can Section be must read the (described 4.3) so in pushed extra that character one be ungetch 
the input. back onto 

not written, followed valid As Exercise + - treats as getint digit 5-1. a a by or a 
zero. Fix input. it to the such on back push representation a of character 

Write What type the 5-2. of getint. Exercise getfloat, analog does floating-point 
function value? its getfloat as return 

and Arrays 5.3 Pointers 

that is pointers enough strong In C, a strong arrays, relationship and between pointers there 
should be array discussed simultaneously. by operation achieved be Any and that arrays can 
be The will faster version general but, pointer can subscripting with done be also pointers. in 
to somewhat harder understand. at least the to uninitiated, 

declaration The 



a[10]; int 

named of a[0], 10 objects that an size 10, array a[1], a of block is, consecutive defines 
...,a[9]. 



 
is the to i-th notation array. integer, pointer an If element The to a[i] the refers of a pa 
as declared 



*pa; int 

assignment the then 



&a[0]; = pa 

address point of pa the zero pa to element to a[0]. a; is, that of contains sets 



assignment the Now 



*pa; = x 

a[0] copy into of will the x. contents 

then to by next points If of array, particular to a points pa element the definition an pa+1 
Thus, and i if points before. pa pa-i pa+i element, after elements i points pa, elements 
a[0], to points 



*(pa+1) 

of contents a[i], of the refers is address a[1], the of is to pa+i contents and the *(pa+i) 
a[i]. 



of true the The are These type size of array regardless the remarks the a. variables or in 
is and all that extension, arithmetic, pa+1 by of meaning a to 1 ``adding pointer,'' pointer 
the next pa. object, and beyond points object i-th pa+i points to to the 

 
close. and arithmetic The correspondence is indexing definition, the By pointer very between 
the variable address array. a value type is expression of or zero of of the of array element 
the assignment Thus after 



&a[0]; = pa 

name values. Since a the location have for identical an of is and pa array a the synonym the of 
also element, assignment initial written be pa=&a[0] the as can 



a; = pa 

a[i] sight, be is more a as also written reference the Rather first surprising, that at fact can to 
evaluating a[i], are C converts forms to two the it *(a+i). *(a+i) In immediately; 
that operator of follows it equivalent. Applying & to equivalence, both this parts &a[i] the 
beyond a+i the is a+i the side As other i-th the and identical: are of also address a. element 
a is is a this use to pa[i] identical it pointer, of pa coin, might if expressions subscript; with 
pointer an to a as *(pa+i). In array-and-index expression written is one equivalent and short, 
offset. 

pointer difference that A one There name a an in between kept is array mind. must and be 
But variable, an variable; a pointer pa++ legal. pa=a not so is is and a array are name 
a++ and illegal. like are a=pa constructions 

is name passed initial array When a what passed of is location an to the is function, the 
an is variable, array local so name a Within element. this function, called the argument and 
address. pointer, We write a parameter variable an is, fact that this is a to can containing use 
of version length a string. of which strlen, computes the another 



string strlen: s of /* return */ length 

*s) strlen(char int 

{ 

n; int 



!= (n '\0', *s for = s++) 0; 

n++; 

n; return 

} 

s++ a has string is Since is legal; incrementing the pointer, on s it character no perfectly effect 
function that the called strlen, of merely copy private but in increments the strlen's 
calls like that pointer. means That 



constant */ string strlen("hello, /* world"); 

char /* array[100]; */ strlen(array); 

char /* *ptr; */ strlen(ptr); 

work. all 

a in definition, formal function parameters As 



s[]; char 

and 



*s; char 

variable it explicitly is more the a says equivalent; are latter the prefer we because that 
at to the its function, can convenience a When pointer. is name array an passed function 

 
it has accordingly. pointer, manipulate either that been handed it It array a or an and believe 
appropriate even seems and clear. use notations both if it can 

beginning of passing an pointer array to to is the function, pass possible a by It to the of a part 
is For an a subarray. example, array, if 



f(&a[2]) 

and 



f(a+2) 

subarray the that the to both address the f Within function a[2]. pass the f, starts of at 
can read parameter declaration 



{ arr[]) ... } f(int 

or 



{ *arr) ... } f(int 

the as of the no far array larger parameter So concerned, of that as a refers fact is f part to is 
consequence. 

index the an elements one also p[-1], in array; possible exist, If that is is sure it backwards to 
immediately on refer that elements p[-2], and are syntactically the legal, to and precede so 
the it array are within to Of is illegal course, bounds. to that objects refer not p[0]. 

Arithmetic Address 5.4 

of to some increments point to a to pointer array, the p++ p If then is next p element an 
does. increments elements currently it element, and it to where point beyond i These p+=i 
constructions or address the similar of pointer and are forms arithmetic. simples 

of and to integration its C is regular in arithmetic; its address approach pointers, consistent 
us the the illustrate of Let by strengths and arrays, one is arithmetic address of language. 
rudimentary storage a allocator. There returns two alloc(n), first, are writing routines. a The 
of can by alloc used caller for be to pointer positions, character consecutive n which the 
be second, thus can it storing characters. afree(p), releases so the acquired storage re- The 
made the afree in to be the calls later. used ``rudimentary'' are routines The because must 
alloc the and storage by on order calls made to afree That the is, alloc. managed opposite 
provides last-in, The is a standard or functions called analogous first-out. library stack, 
8.7 that we be free malloc restrictions; Section no they have how and such can will in show 
implemented. 

array is that a character alloc easiest to have implementation we out of pieces hand large The 
in This pointers, Since deal private call array is allocbuf. not alloc afree. and to they will 
can the the be of which declared name indices, array need routine other no know array, 
outside and thus it. and invisible In afree, in static containing file source the alloc be 
instead array have might it practical implementations, may well name; not a even be the 
to the for some system pointer unnamed operating by obtained by or malloc calling asking a 
storage. of block 

use of been a has We pointer, allocbuf other The how is needed information much used. 
n points characters, is for next allocp, to the that it element. alloc When free asked called 

 
allocbuf. if If value see checks room in is the there returns to enough current so, left alloc 
n of to the allocp increments next point the it free of beginning (i.e., then the block), to by 
allocp no if room, area. afree(p) is p p merely alloc free is If zero. there returns to sets 
allocbuf. inside 





space of available */ #define ALLOCSIZE /* 10000 size 



for char alloc storage static allocbuf[ALLOCSIZE]; */ /* 

next char = static position free allocbuf; *allocp */ /* 



to *alloc(int /* char characters n return n) */ pointer 

{ 

/* - >= if (allocbuf n) ALLOCSIZE fits */ it allocp { + 

n; += allocp 

old allocp p /* return - */ n; 

enough not */ else room /* } 

0; return 

} 



by afree(char to p */ *p) free /* storage pointed void 

{ 

< (p allocbuf if + allocbuf && >= ALLOCSIZE) p 

p; = allocp 

} 

normally pointer the variable though initialized general can be a only as other any just can, In 
are zero data or an defined involving previously of expression meaningful the values address 
type. appropriate The declaration of 



*allocp char = allocbuf; static 

the and to beginning it to of initializes allocp defines character a be to pointer point 
also when starts. have program could been the which allocbuf, free next the is position This 
written 



*allocp char = &allocbuf[0]; static 

the the of zeroth element. array is name the address since 

test The 



/* - >= if (allocbuf n) ALLOCSIZE fits */ it allocp { + 

 
there to new satisfy if n of the value characters. a checks room there's for enough request is, If 
can at be If request beyond would most one be satisfied, end allocbuf. of the the allocp 
declaration pointer of characters the beginning returns to the a the a of block of (notice alloc 
left. not, C is space return itself). alloc must If guarantees signal there that some no function 
to address of for can data, never be zero used return a is a value that so an signal zero valid 
case this space. event, no in abnormal 

integers are zero not interchangeable. constant is the exception: Zero Pointers the and sole 
constant to zero. compared the and be a pointer, assigned The pointer be may a with may 
indicate is more a to in constant often used NULL clearly of as zero, place mnemonic symbolic 
is a defined NULL is that a NULL value will special We this for use in pointer. <stdio.h>. 
henceforth. 

like Tests 



/* - >= if (allocbuf n) ALLOCSIZE fits */ it allocp { + 

and 



< (p allocbuf if + allocbuf && >= ALLOCSIZE) p 

may of arithmetic. show several First, facets compared under be pointer pointers important 
relations p like same then point circumstances. and q If ==, members the of to array, certain 
properly. <, For work !=, >=, example, etc., 



q < p 

q to pointer an true the be Any can array earlier is points if of p element does. than 
for equality for or inequality undefined zero. is behavior with meaningfully But compared the 
same with point the of arithmetic or pointers that members do to not array. comparisons 
first address of of can be exception: array the past used end is (There the one in an the element 
arithmetic.) pointer 

added pointer integer or an be subtracted. and we Second, that observed already have a may 
construction The 



n + p 

This of is currently to. object the the n-th address true the p one beyond points means 
to; object p to of the kind size of is objects according of regardless scaled the p the points n 
is by for the to, If the bytes, example, an declaration points determined which p. is of four int 
by four. scaled int be will 

the if and p subtraction to then array, p<q, elements and Pointer valid: is point also q same of 
can elements to from is inclusive. yet used write This p q-p+1 of the q number to be fact 
of strlen: another version 



string strlen: s of /* return */ length 

*s) strlen(char int 

{ 

= s; char *p 



!= '\0') while (*p 

p++; 

- s; return p 

} 

 
string. to the s, character that p of its the point is declaration, to to In is, the In first initialized 
'\0' character at p each while examined the turn seen. in is loop, is Because the until end 
gives p++ the time, p-s to to advances p characters, number next each character the and points 
in string number the (The characters string length. characters of is, that over, advanced the of 
type large ptrdiff_t <stddef.h> a in be to store too that int. header The an defines could 
were to being values. we signed large hold the enough cautious, of pointer two difference If is 
the return strlen, standard of match library value we however, for size_t use would the to 
is the sizeof unsigned size_t returned by version. the type operator. integer 

is consistent: more if we occupy been which floats, had Pointer dealing arithmetic with 
float, and p++ float. chars, storage a to p the if to that were next would pointer advance 
chars, write that of instead Thus we another version floats of maintains alloc merely could 
All float alloc by changing and to pointer manipulations the throughout afree. char 
objects take the pointed to. into the account size of automatically 

pointer operations or are assignment adding pointers type, same of The of valid the 
of and comparing members to subtracting a an integer, pointers subtracting two or the pointer 
It assigning is arithmetic illegal. to array, or comparing and not All pointer other zero. is same 
or or to mask to add two or pointers, or float or to legal shift add or them, multiply divide 
*, except for of to a or type even, assign pointer pointer to double a them, of one void to 
without type a cast. another 

Pointers Character and Functions 5.5 

constant, string written as A 



a string" "I am 

with internal array the the terminated null representation, an is In characters. of array the is 
length that in than so character the The can one programs thus '\0' find more storage end. is 
the number double between the of quotes. characters 

as common is functions, to Perhaps the occurrence of arguments string as constants in most 



world\n"); printf("hello, 

through string a to is appears a like this character character a access program, in it When 
is, beginning character a the That string of printf pointer; to pointer a receives the array. 
to is by constant first its a accessed element. pointer 

need is declared be constants If pmessage String not arguments. as function 



*pmessage; char 

statement the then 



the time"; is pmessage "now = 

copy; a only not string the to pointer to pmessage pointers array. is This character a assigns 
of operators an characters processing string as for involved. are provide not does C any entire 
unit. a 

between is these difference There an definitions: important 



 
an amessage[] /* array */ = is "now the time"; char 

a *pmessage /* pointer */ = is "now the time"; char 

and to sequence '\0' the characters that hold is amessage big just array, an enough of 
Individual characters always within the will may amessage but array initializes be it. changed 
is same a a the refer other pmessage On point storage. to to the to pointer, hand, initialized 
result pointer to the but string constant; may subsequently elsewhere, be point modified is the 
string modify the contents. undefined if try you to 



two more arrays of versions We will aspects of studying pointers by and useful illustrate 
is standard The functions adapted first the which copies strcpy(s,t), library. function from 
nice to but It the t the copies just the s. not be string this to would pointer, the s=t say string 
The characters, need characters. To a the version first: array we loop. copy 



array strcpy: t /* version subscript to copy */ s; 

*s, strcpy(char char *t) void 

{ 

i; int 



0; = i 

!= '\0') t[i]) while = ((s[i] 

i++; 

} 

of contrast, is For with strcpy a here pointers: version 



version s; pointer */ /* strcpy: t copy to 

*s, strcpy(char char *t) void 

{ 

i; int 



0; = i 

!= *t) { ((*s '\0') = while 

s++; 

t++; 

} 

} 

parameters passed s it are Because can the value, any by in arguments strcpy way and use t 
they are a conveniently initialized arrays which the along pointers, pleases. are Here marched 
into time, terminates copied been character at until the has '\0' t that s. a 

C would we Experienced above. In practice, not be it written showed as programmers strcpy 
prefer would 



pointer strcpy: t /* 2 version to copy */ s; 

*s, strcpy(char char *t) void 

{ 

!= '\0') *t++) while = ((*s++ 

; 

 
} 

*t++ and the t The into increment value moves of part of the test of This the the is loop. s 
change was postfix t the doesn't until incremented; that character before to pointed t t ++ 
the has character s character after the way, fetched. the been into this In old is same stored 
compared is also is that position before incremented. This value character the is against s 
from The s, net to characters and to up are effect '\0' loop. control that the is t copied 
terminating '\0'. including the 

final abbreviation, the observe that since comparison redundant, is a As against the '\0' 
be zero. function written the likely as So is question expression the whether merely is would 



pointer strcpy: t /* 3 version to copy */ s; 

*s, strcpy(char char *t) void 

{ 

= *t++) while (*s++ 

; 

} 

may seem and cryptic at considerable, sight, is convenience first Although the this notational 
should be programs. mastered, because C will in frequently you the see idiom it 

in the function standard library its returns as string (<string.h>) The the strcpy target 
value. 

which we examine The second is that the character compares will strcmp(s,t), routine 
less t, than, s lexicographically negative, s and returns and equal or if positive zero is strings 
the than first the at value or t. The greater position obtained subtracting by is characters to, 
and s t disagree. where 



>0 if 0 /* strcmp: if <0 s>t */ if s<t, s==t, return 

*s, strcmp(char char *t) int 

{ 

i; int 



== (i t[i]; s[i] for = i++) 0; 

== '\0') if (s[i] 

0; return 

- t[i]; return s[i] 

} 

version pointer of strcmp: The 



>0 if 0 /* strcmp: if <0 s>t */ if s<t, s==t, return 

*s, strcmp(char char *t) int 

{ 

*t; ( s++, == for ; t++) *s 

== '\0') if (*s 

0; return 

- *t; return *s 

} 

other -- combinations -- and Since or operators, either ++ are and ++ prefix and of postfix * 
For example, frequently. occur, less although 



*--p 

pair p In of to. the expressions points p decrements character the fetching before that fact, 



stack val onto */ *p++ = /* val; push 

into = stack val */ *--p; pop /* top of val 

 
stack; for and are the popping idiom Section 4.3. see pushing a standard 

in declarations the The header functions contains section, plus this for mentioned <string.h> 
from variety other a standard the string-handling of library. functions 

in the that Chapter strcat showed 2: function 5-3. Exercise version pointer a Write of we 
the copies string strcat(s,t) of end t the s. to 

occurs returns the at if t the 1 5-4. Exercise strend(s,t), function the Write which string 
and of zero s, end the otherwise. string 

strncat, of library Exercise 5-5. functions versions strncmp, which and the strncpy, Write 
at most example, the first For characters strings. argument n operate of on their 
in t Full Appendix s. are B. to copies strncpy(s,t,n) characters n most at of descriptions 

Rewrite exercises with programs 5-6. chapters and Exercise appropriate earlier pointers from 
array indexing. itoa, Good possibilities atoi, getline 4), and include instead (Chapters of 1 
and (Chapters reverse strindex and and their 2, 3, 3), and (Chapter 4), getop variants 
4). (Chapter 

to Pointers Pointers 5.6 Arrays; Pointer 

other variables stored as just Since pointers themselves, they arrays can in be variables are 
sort illustrate a alphabetic us can. program will writing lines by text Let a into set that of 
program the UNIX sort. order, a version stripped-down of 

would we sort in 3, In sort that a integers, presented of Chapter Shell and an function array 
work, a same except The will that quicksort. 4 Chapter it on improved we with algorithms 
and to which, of lengths, lines we deal with have unlike text, are which of different now 
data a We representation operation. a that single can't integers, moved or compared be in need 
text with variable-length lines. will cope and efficiently conveniently 

sorted of end-to-end pointers is lines one stored in to enters. This array where the the If are be 
first then character. pointer its can character each line array, The accessed a by be to long 
by array. can passing lines compared their Two themselves pointers in stored bee can an be 
in When to pointers the pointers to two out-of-order exchanged, lines be have the strcmp. 
lines the text themselves. pointer array exchanged, are not 



and problems complicated This eliminates storage twin overhead that high of management the 
the moving themselves. go lines with would 

three steps: has The process sorting 

 
of input lines read the all 
them sort 
in order print them 

natural program that division, functions this with into usual, As divide to best it's the match 
for Let the a defer step moment, us main the other the controlling routine functions. sorting 
input concentrate the and output. on data the structure and and 

of has each of routine The save characters collect an to build input and array line, the and 
lines, lines. since number input also to It will the that to the count have of pointers 
cope Since function with input only a the is information and sorting for needed printing. can 
count input like is of finite return illegal it much lines, too number can input -1 some if 
presented. 

lines to print which in the only appear has the array in output The order routine of they the in 
pointers. 



<stdio.h> #include 

<string.h> #include 



to MAXLINES /* #define sorted be max 5000 */ #lines 



text *lineptr[MAXLINES]; lines to char /* */ pointers 



*lineptr[], readlines(char int nlines); int 

*lineptr[], writelines(char int nlines); void 



left, int right); qsort(char int *lineptr[], void 



input sort lines */ /* 

main() 

{ 

read input lines */ int nlines; number /* of 



>= ((nlines 0) MAXLINES)) if = { readlines(lineptr, 

nlines-1); 0, qsort(lineptr, 

nlines); writelines(lineptr, 

0; return 

{ else } 

to sort\n"); big printf("error: too input 

1; return 

} 

} 



input MAXLEN any line */ 1000 max /* length of #define 

*, int); int getline(char 

*alloc(int); char 



lines */ input /* read readlines: 

*lineptr[], readlines(char int maxlines) int 

{ 

nlines; len, int 

line[MAXLEN]; *p, char 



0; = nlines 

MAXLEN)) getline(line, 0) ((len > = while 

= (nlines maxlines if == alloc(len) || >= NULL) p 

-1; return 

{ else 

 
delete /* */ = newline '\0'; line[len-1] 

line); strcpy(p, 

p; = lineptr[nlines++] 

} 

nlines; return 

} 



lines */ output /* write writelines: 

*lineptr[], writelines(char int nlines) void 

{ 

i; int 



< (i nlines; i for = i++) 0; 

lineptr[i]); printf("%s\n", 

} 

from is 1.9. function Section getline The 

for the declaration lineptr: The main thing new is 



*lineptr[MAXLINES] char 

element is of a lineptr says MAXLINES each array pointer an a that of to which elements, is 
it lineptr[i] and character the char. That is a is character *lineptr[i] pointer, points is, 
i-th the character to, text saved of first line. the 

array, name of as in the itself pointer the can same treated lineptr Since be is manner a an it 
our written instead examples, in can be as earlier writelines as and 



lines */ output /* write writelines: 

*lineptr[], writelines(char int nlines) void 

{ 

> 0) while (nlines-- 

*lineptr++); printf("%s\n", 

} 

next each it line advances the pointer element *lineptr Initially, first the to points line; to 
is nlines counted down. while 

from can sorting. Chapter to quicksort 4 proceed input With control, under output and we The 
and declarations to needs minor be the comparison operation the have modified, changes: 
us by remains gives which must be calling strcmp. same, The the algorithm some done 
still work. will confidence it that 



increasing qsort: order into /* sort */ v[left]...v[right] 

left, int right) qsort(char int *v[], void 

{ 

last; i, int 

i, int j); swap(char int *v[], void 



array (left if contains */ >= /* right) do nothing if 

two than */ /* elements fewer return; 

(left left, + right)/2); swap(v, 

left; = last 

<= (i right; i for = i++) left+1; 

v[left]) (strcmp(v[i], < 0) if 

i); ++last, swap(v, 

last); left, swap(v, 

last-1); left, qsort(v, 

 
right); last+1, qsort(v, 

} 

only the trivial needs Similarly, swap changes: routine 



and v[i] */ swap: v[j] interchange /* 

i, int j) swap(char int *v[], void 

{ 

*temp; char 



v[i]; = temp 

v[j]; = v[i] 

temp; = v[j] 

} 

be element also, pointer, must (alias any of v individual so is character a lineptr) temp Since 
to copied other. can the be one 

rather readlines an main, by Exercise 5-7. to store supplied lines array in than Rewrite 
is alloc faster the program? to storage. maintain How much calling 

Arrays Multi-dimensional 5.7 

are arrays, in C provides practice multi-dimensional less used much although they rectangular 
of pointers. properties. In this their we of some section, than will arrays show 

month of to vice problem Consider day the conversion, year date the the from and day of of 
day is the and day of March 61st 1 a a year, For versa. non-leap example, leap the 60th of 
month define the the converts year. Let two functions day_of_year to conversions: do and us 
the the the year, into the and into month day and day of the converts day month_day year of 
will latter the arguments day day. Since function computes and two month values, be this 
pointers: 



&m, &d) month_day(1988, 60, 

to m 2 sets (February 29 and to 29th). d 

in need each number days information, functions the same both month table the of a of These 
for number per leap days differs years of days (``thirty Since ...''). September hath the month 
two-dimensional them rows array two a than into non-leap and to easier it's years, separate of 
the of during and array to keep what happens The to computation. February functions track 
are transformations follows: performing as the for 



daytab[2][13] char = { static 

30, 30, 30, {0, 31, 31, 31, 30, 31}, 31, 31, 31, 28, 

30, 30, 30, {0, 31, 31, 31, 30, 31} 31, 31, 31, 29, 

}; 



& day_of_year: month day */ set of day year from /* 

month, int day) day_of_year(int int year, int 

{ 

leap; i, int 

|| 0 year%100 leap = != == == 0; year%400 && 0 year%4 

< (i month; i for = i++) 1; 

daytab[leap][i]; += day 

day; return 

} 



 
day month_day: month, /* year of day set */ from 

int int *pmonth, *pday) void month_day(int int year, yearday, 

{ 

leap; i, int 



|| 0 year%100 leap = != == == 0; year%400 && 0 year%4 

> (i daytab[leap][i]; yearday for = i++) 1; 

daytab[leap][i]; -= yearday 

i; = *pmonth 

yearday; = *pday 

} 

as arithmetic the zero the Recall logical such of is value leap, that a either one expression, for 
the be a array as of daytab. used or (false) it so (true), one can subscript 

they to and can day_of_year so both both array The be to has daytab external month_day, 
storing made small of for to it. it char We non-character a use legitimate illustrate char use 
integers. 

two-dimensional have In array with. a is dealt is daytab array two-dimensional first the we C, 
one-dimensional array, are each of subscripts elements Hence array. whose really is a an 
as written 



[row][col] */ daytab[i][j] /* 

than rather 



WRONG */ daytab[i,j] /* 

this notational the distinction, a much array in treated two-dimensional Other can than be 
rightmost are rows, subscript, by the or stored way same languages. other in as Elements so 
accessed varies as column, storage in elements fastest order. are 

braces; initialized each is is An of in a two-dimensional by a array list array row initializers of 
of the with zero daytab column so array by initialized We sub-list. corresponding a started a 
12 can 11. natural a numbers is space instead that the at to month Since of 1 not run to 0 from 
the than adjusting indices. premium here, is this clearer 

declaration passed function, in a parameter the to a If to is array two-dimensional be the 
since the rows what of irrelevant, is number must function of number the include columns; is 
13 to row an an array before, array is, of where a as rows, each passed of In ints. is pointer 
13 a if pointer particular are array Thus the arrays to this is case, that it objects ints. of 
would be f, f of daytab is passed to declaration a the function be: to 



{ daytab[2][13]) ... } f(int 

also be It could 



{ daytab[][13]) ... } f(int 

it the or could be number rows of is irrelevant, since 



{ (*daytab)[13]) ... } f(int 

The the parentheses of integers. a says parameter is that are to array an pointer 13 which 
brackets Without parentheses, have since than *. necessary [] precedence the higher 
declaration 



*daytab[13] int 

 
dimension integers. only (subscript) generally, first of More an is pointers 13 of array to the 
to array have be specified. is all free; the others an 

complicated discussion of declarations. Section 5.12 a has further 

There is defect. no error this in Remedy month_day. checking Exercise day_of_year 5-8. or 

of Initialization Pointer Arrays 5.8 

problem of a writing a to month_name(n), pointer a function Consider which the returns 
application n-th is for This ideal an month. string character of name the containing the an 
array. month_name a contains a returns array and strings, private internal of static character 
of This how names shows array is section to pointer when one proper the called. that 
initialized. 

to similar initializations: syntax previous is The 



n-th month_name: month of /* return */ name 

n) *month_name(int char 

{ 

*name[] char = { static 

month", "Illegal 

"March", "February", "January", 

"June", "May", "April", 

"September", "August", "July", 

"December" "November", "October", 

}; 



< name[0] : || (n 12) ? return 1 > name[n]; n 

} 

pointers, name, is the of The array character is lineptr which as declaration an in the of same 
to initializer character assigned is sorting example. is a each list strings; of the The 
in the somewhere, array. The placed of are string characters corresponding the position i-th 
the is is stored a the specified, name not size in and them pointer Since to name[i]. array of 
the compiler in correct number. counts initializers the and fills the 

vs. Pointers Multi-dimensional Arrays 5.9 

C between a sometimes to the difference Newcomers are about two-dimensional confused 
Given as the the in above. definitions name and array pointers, of array an such example 



a[10][20]; int 

*b[10]; int 

a b[3][4] is single But syntactically a[3][4] are both and a references a to legal int. then 
aside, int-sized have true two-dimensional been 200 the conventional and locations set array: 
a[row,col]. is find For to element b, used subscript rectangular row * 20 calculation +col the 
not allocates pointers however, the and only them; initialization initialize 10 does definition 
of with that b Assuming element does code. be must statically either explicitly, done or each 
ints twenty-element set the a point will 200 then cells array, ten to there for aside, be plus 
the advantage rows of important pointers. array that the may of array The pointer be of is the 
twenty-element b point vector; not a some need lengths. different element each is, That of to 
to two all. elements, some at fifty, none to to may and point some 

 
frequent phrased use far most in we this discussion have of of by integers, terms the Although 
the is of in as arrays of to store lengths, character diverse strings function pointers 
array Compare an of pointers: the and declaration picture for month_name. 



"Jan", *name[] { char "Mar" "Feb", "Illegal = }; month", 



two-dimensional array: a with for those 



"Jan", aname[][15] { char "Mar" "Feb", "Illegal = }; month", 



Rewrite pointers instead routines 5-9. month_day with Exercise the and of day_of_year 
indexing. 

Arguments Command-line 5.10 

or support way arguments command-line In environments C, there pass is to a parameters that 
with when two it called executing. a it begins program arguments. main called, is When is to 
the argc, argument The first count) called of command-line number for is (conventionally 
a was (argv, is vector) arguments the invoked with; argument the for second pointer program 
We contain one customarily arguments, string. use the an to strings character of array that per 
character manipulate these strings. multiple levels pointers of to 

illustration is a the program on which arguments command-line echo, The echoes simplest its 
the That is, command single line, by separated blanks. 



world hello, echo 

output the prints 



world hello, 

was is invoked, 1. argv[0] By which program name at the is convention, by least so the argc 
In command-line the the after name. example arguments argc If are there 1, is no program 
is 3, "world" and argv[0], and and "hello,", "echo", argv[1], above, argv[2] argc are 
first last is argument The and the respectively. optional argv[1] argv[argc-1]; is 
be the requires additionally, null a that standard pointer. argv[argc] 

 


array echo argv The first as of character pointers: of treats an version 



<stdio.h> #include 



1st arguments; */ echo version command-line /* 

char *argv[]) main(int argc, 

{ 

i; int 



< (i argc; i for = i++) 1; 

" argv[i], < printf("%s%s", : " argc-1) (i ""); ? 

printf("\n"); 

0; return 

} 

pointer a rather can the an argv pointer to is than of we pointers, array manipulate Since 
pointer This to which a is the next variant array. pointer on argv, incrementing based is index 
is argc down: char, counted while to 



<stdio.h> #include 



2nd arguments; */ echo version command-line /* 

char *argv[]) main(int argc, 

{ 

> 0) while (--argc 

" *++argv, > printf("%s%s", : " 1) (argc ""); ? 

printf("\n"); 

0; return 

} 

array a of 1 is Since beginning the to it pointer incrementing argv the by argument of strings, 
of at original (++argv) makes argv[1] point Each successive argv[0]. the instead it 
that along argument. the to next moves to the it At *argv then is argument; pointer increment 
arguments it there left zero, no to becomes same the decremented; is argc time, when are 
print. 

printf we statement the Alternatively, could as write 



"%s", " : *++argv); printf((argc > ? 1) "%s 

be format of This shows printf the expression too. an argument can that 

second example, from let us program some pattern-finding the make As enhancements a to 
program, the deep an pattern the obviously search 4.1. Section we recall, you If wired into 
Following the the lead of enhance UNIX us let the unsatisfactory program arrangement. grep, 
the pattern command first on matched so to be the line. specified the by is argument program 

 


<stdio.h> #include 

<string.h> #include 

1000 MAXLINE #define 



*line, getline(char int max); int 



1st find: from arg */ print that lines match pattern /* 

char *argv[]) main(int argc, 

{ 

line[MAXLINE]; char 

= 0; int found 



!= 2) if (argc 

pattern\n"); find printf("Usage: 

else 

MAXLINE) (getline(line, > 0) while 

NULL) { != if argv[1]) (strstr(line, 

line); printf("%s", 

found++; 

} 

found; return 

} 

library function the strstr(s,t) returns of pointer occurrence first a The to standard the 
declared the in none. is or t string s, in <string.h>. if is there NULL It string 

can now want be elaborated we illustrate Suppose constructions. to The further model pointer 
that ``print lines match the those the all allow to One arguments. optional two says except 
second its line ``precede the line by pattern;'' says printed number.'' each 

that UNIX that begins is argument with systems common A programs C for convention on an 
(for or we ``except'') If -x to parameter. minus a optional an introduces sign flag choose 
numbering, -n to signal the request and the command then (``number'') line inversion, 



-npattern -x find 

each line number. that doesn't line the its by match will pattern, print preceded 

program order, rest should the the be and arguments Optional in permitted be should any of 
the number for of arguments convenient we is it that independent present. of Furthermore, 
as be combined, in users if arguments option can 



pattern -nx find 

the program: Here is 



<stdio.h> #include 

<string.h> #include 

1000 MAXLINE #define 



*line, getline(char int max); int 



1st find: from arg */ print that lines match pattern /* 

char *argv[]) main(int argc, 

{ 

line[MAXLINE]; char 

= 0; long lineno 

found c, 0, = 0; except 0, = number = int 



(*++argv)[0] (--argc == && while > '-') 0 

 
= *++argv[0]) while (c 

{ (c) switch 

'x': case 

1; = except 

break; 

'n': case 

1; = number 

break; 

default: 

option illegal %c\n", c); printf("find: 

0; = argc 

-1; = found 

break; 

} 

!= 1) if (argc 

-x find -n pattern\n"); printf("Usage: 

else 

0) { > while MAXLINE) (getline(line, 

lineno++; 

!= ((strstr(line, except) NULL) if *argv) { != 

(number) if 

lineno); printf("%ld:", 

line); printf("%s", 

found++; 

} 

} 

found; return 

} 

end and each the At argc is argv is argument. incremented optional before of decremented 
unprocessed argc many and how remain argv tells loop, the no are there if errors, arguments 
1 first and pattern. the points argc be these. at of point to Thus the *argv should should 
its an so first string, is character. argument that Notice pointer a is *++argv to (*++argv)[0] 
and Because tighter ++, binds * the [] alternate (An be would form valid **++argv.) than 
taken them expression parentheses are would without *++(argv[0]). In as the be necessary; 
the have used task walk along what to we loop, a the that fact, where is specific is in inner 
In increments the inner string. expression *++argv[0] argument the the pointer loop, 
argv[0]! 

such that more in these; It is one uses than pointer complicated expressions cases, rare 
be them will more intuitive. into or two three steps breaking 

Write the the program expr, from evaluates expression Polish which Exercise a 5-10. reverse 
separate operator operand command line, is each For example, argument. or a where 



+ * 4 expr 3 2 

* (3+4). evaluates 2 

1) the (written Chapter in Exercise 5-11. program entab exercises and as detab to Modify 
default of tab arguments. list accept arguments. the stops are tab there a as no settings Use if 

to 5-12. entab Exercise the accept and Extend shorthand detab 



+n -m entab 

(for starting m. the column convenient user) at mean to n every stops tab columns, Choose 
behavior. default 

 
n the lines n Write Exercise prints last tail, By program input. 5-13. which default, of the its 
be 10, changed that to is but can us argument let optional set say, so by it an 



-n tail 

unreasonable n behave how matter prints the lines. The no program rationally should the last 
best n. available Write or it lines of storage; makes the input of the so value program use the 
two-dimensional as array not a sorting be in the stored of of 5.6, Section program in should 
size. fixed 

to Functions 5.11 Pointers 

to is to not C, it which pointers functions, is a In itself a but function variable, define possible 
so to by on. returned and We functions, be can arrays, in placed assigned, passed functions, 
so procedure in that earlier chapter if written illustrate will the modifying by this sorting this 
instead -n sort numerically lines the optional is given, input it the will of argument 
lexicographically. 

that consists determines of often A - comparison three any of of sort parts pair the a ordering 
exchange that comparisons reverses their makes and that algorithm order, objects, a an sorting 
of the The independent is and exchanges objects are algorithm in sorting order. the until 
comparison and different and exchange exchange so operations, by passing comparison 
criteria. we This our it, functions sort different arrange taken can approach to to in is by the 
sort. new 

also by before; need as will a strcmp, comparison Lexicographic is lines two of done we 
returns the numeric the of and same basis numcmp routine lines two compares that on value 
main indication functions of ahead kind of as strcmp declared does. are These and condition 
error the processing have on is pointer appropriate one to for to We qsort. passed skimped a 
main on the issues. arguments, so to as concentrate 



<stdio.h> #include 

<string.h> #include 



to MAXLINES /* #define sorted be max 5000 */ #lines 

text *lineptr[MAXLINES]; lines to char /* */ pointers 



*lineptr[], readlines(char int nlines); int 

*lineptr[], writelines(char int nlines); void 



left, int right, qsort(void int *lineptr[], void 

*, (*comp)(void void *)); int 

*, numcmp(char char *); int 



input sort lines */ /* 

char *argv[]) main(int argc, 

{ 

read input lines */ int nlines; number /* of 

if numeric 0; int sort numeric /* = */ 1 



== strcmp(argv[1], "-n") 0) if (argc 1 > && 

1; = numeric 

>= ((nlines 0) MAXLINES)) if = { readlines(lineptr, 

0, nlines-1, qsort((void**) lineptr, 

: strcmp)); numcmp (int ? (*)(void*,void*))(numeric 

nlines); writelines(lineptr, 

 
0; return 

{ else } 

big too to sort\n"); printf("input 

1; return 

} 

} 

are to known functions. they and the qsort, strcmp call to are of addresses numcmp Since In 
is not before necessary, functions, way array needed an that in be is the same & the not it 
name. 

strings. qsort As not character can have so it written indicated any type, data process just We 
a prototype, of and integers, by the qsort expects two an pointers, array function function 
the arguments. void for used with two The generic is pointer * type pointer pointer 
of can information, again loss to Any be cast pointer so * back and void without arguments. 
of to The the *. cast function void can we casting by qsort call arguments elaborate 
the arguments effect of the no function. have generally comparison argument These casts will 
all actual that is well. representation, assure but the compiler on 



increasing qsort: order into /* sort */ v[left]...v[right] 

left, int right, qsort(void int *v[], void 

*, (*comp)(void void *)) int 

{ 

last; i, int 



*v[], swap(void int, int); void 



array (left if contains */ >= /* right) do nothing if 

two than */ /* elements fewer return; 

(left left, + right)/2); swap(v, 

left; = last 

<= (i right; i for = i++) left+1; 

v[left]) ((*comp)(v[i], < 0) if 

i); ++last, swap(v, 

last); left, swap(v, 

last-1, comp); qsort(v, left, 

right, comp); qsort(v, last+1, 

} 

should be is studied with qsort care. of parameter some The The declarations fourth 



*, (*comp)(void void *) int 

void a and pointer says that an arguments returns has to which is that function comp a * two 
int. 

in comp line use the of The 



v[left]) ((*comp)(v[i], < 0) if 

the the function, function, is is consistent declaration: comp with and pointer a to a *comp is 



v[left]) (*comp)(v[i], 

correctly to needed are components is the it. The the parentheses so are associated; call 
them, without 



/* *comp(void WRONG *) int *, */ void 

is a an very to which different. pointer that says function a is comp returning int, 

 
Here strcmp, compares We have two shown numcmp, which is which strings. already 
strings by calling a two value, computed compares on numeric atof: leading 



<stdlib.h> #include 



s2 numcmp: numerically and /* compare */ s1 

*s1, numcmp(char char *s2) int 

{ 

v2; v1, double 



atof(s1); = v1 

atof(s2); = v2 

< v2) if (v1 

-1; return 

(v1 if > v2) else 

1; return 

else 

0; return 

} 

earlier which identical presented we The swap exchanges two what pointers, to is in function, 
to chapter, changed void *. except the that declarations are the 



i, int j;) swap(void int *v[], void 

{ 

*temp; void 



v[i]; = temp 

v[j]; = v[i] 

temp; = v[j] 

} 

make other to some program; A variety options can sorting be the added challenging of 
exercises. 

sorting handle flag, in -r indicates reverse a 5-14. Exercise program sort the Modify to which 
with -r works -n. (decreasing) order. sure Be that 

so fold lower that and together, case upper 5-15. Exercise -f option the Add to case 
and during for distinctions are example, made compare equal. A sorting; a not 

makes -d order'') Exercise 5-16. option, the only on comparisons (``directory which Add 
and conjunction with Make numbers works in letters, blanks. it -f. sure 

Add a within field-searching capability, fields sorting on done so Exercise may 5-17. bee 
for independent options. this of index book set each lines, to according sorted field an (The 
with -df numbers.) for the page category the for index was and sorted -n 

Declarations Complicated 5.12 

sometimes castigated involve for the that of ones particularly syntax C its is declarations, 
use The agree; declaration the an to syntax is functions. it to the make attempt and pointers 
ones, can for because confusing harder declarations be well works but cases, simple for it the 
read left between to right, difference because The over-used. and cannot parentheses be are 



pointer *f(); f: int int to function /* */ returning 

and 



 
function (*pf)(); pf: int int returning pointer /* */ to 

than operator has (), it precedence so and the illustrates a is * problem: prefix lower 
the are proper force parentheses necessary association. to 

complicated declarations how rarely arise know practice, to important in Although it truly is 
to and, create way good to understand if necessary, One how them. to synthesize them, 
As small is 6.7. Section declarations is steps with in typedef, discussed which an in 
programs section that a this alternative, a of will C we valid in present to convert pair from 
and left to again. description description reads word back word right. The 

C is declaration in dcl, The It a more description, the word first, complex. as into converts a 
examples: these 



**argv char 

to char argv: pointer 

(*daytab)[13] int 

of int array[13] daytab: to pointer 

*daytab[13] int 

to int pointer daytab: of array[13] 

*comp() void 

to void pointer comp: returning function 

(*comp)() void 

returning void function comp: to pointer 

(*(*x())[])() char 

to pointer of function array[] returning x: 

function to returning char pointer 

(*(*x[3])())[5] char 

to pointer returning array[3] function of x: 

array[5] to of char pointer 

out specifies which precisely declarator, spelled in a is dcl grammar the on based that is 
simplified is a form: Appendix A, 8.5; Section this 





*'s direct-dcl dcl: optional 

name direct-dcl 

(dcl) 

direct-dcl() 

size] direct-dcl[optional 



*'s. dcl A a a In perhaps by a name, is a words, direct-dcl, or direct-dcl preceded is 
a direct-dcl by parenthesized dcl, parentheses, a followed by direct-dcl followed or or 
an with optional size. brackets 

instance, used parse This grammar functions. be this declarator: consider to For can 



(*pfa[])() 

pfa[] a a name will a Then also direct-dcl. direct-dcl. and pfa as be as identified thus is Then 
is (*pfa[]) direct-dcl. a a (*pfa[])() direct-dcl is is *pfa[] dcl, a as recognized so Then 
like can direct-dcl also thus with been (where has a illustrate and We a parse dcl. the this tree 
dir-dcl): to abbreviated 

 


functions, the dcl declaration of The a of program parse dcl that heart is a and pair dirdcl, 
defined, Because grammar according to is grammar. functions call the the recursively this 
called as a is program each other they recognize the pieces declaration; of a recursively 
parser. recursive-descent 



declarator */ a /* parse dcl: 

dcl(void) void 

{ 

ns; int 



= count *'s gettoken() (ns ) /* for 0; '*'; */ == 

ns++; 

dirdcl(); 

> 0) while (ns-- 

pointer to"); strcat(out, " 

} 



direct a */ dirdcl: declarator parse /* 

dirdcl(void) void 

{ 

type; int 



( (tokentype '(') if ) dcl { == */ /* 

dcl(); 

!= ')') if (tokentype 

)\n"); missing printf("error: 

/* else (tokentype } name variable == if */ NAME) 

token); strcpy(name, 

 
else 

name expected or (dcl)\n"); printf("error: 

type ((type=gettoken()) == || while == BRACKETS) PARENS 

== PARENS) if (type 

function returning"); strcat(out, " 

{ else 

array"); " strcat(out, 

token); strcat(out, 

of"); " strcat(out, 

} 

} 

bullet-proof, intended be Since the illustrative, are are significant there to not programs 
or only does handle on type handle It not line a restrictions can dcl. data It simple int. char 
doesn't functions, Spurious It it. argument types or qualifiers confuse like blanks const. do in 
recovery, so left invalid declarations are also improvements These will much confuse error it. 
exercises. as 

main and the routine: Here are global the variables 



<stdio.h> #include 

<string.h> #include 

<ctype.h> #include 



100 MAXTOKEN #define 



BRACKETS }; PARENS, enum NAME, { 



dcl(void); void 

dirdcl(void); void 



gettoken(void); int 

last tokentype; token of int /* */ type 

token last */ token[MAXTOKEN]; string /* char 

name */ identifier char /* name[MAXTOKEN]; 

char, datatype[MAXTOKEN]; data char etc. int, type /* */ = 

out[1000]; char 



to declaration */ /* words convert main() 

{ 

on (gettoken() token line */ != { EOF) /* 1st while 

the is */ token); datatype /* strcpy(datatype, 

'\0'; = out[0] 

of rest */ /* line parse dcl(); 

!= '\n') if (tokentype 

error\n"); printf("syntax 

out, datatype); name, printf("%s: %s\n", %s 

} 

0; return 

} 

input; skips a token the tabs, function blanks and gettoken ``token'' finds next the then in The 
brackets a perhaps other name, is a of of or pair number, a parentheses, any including pair a 
character. single 



next return */ gettoken(void) token /* int 

{ 

getch(void); c, int 

ungetch(int); void 

= token; char *p 



c ((c || == '\t') = == getch()) ' ' while 

 
; 

== (c '(') { if 

== getch()) { ((c ')') = if 

"()"); strcpy(token, 

= PARENS; return tokentype 

{ else } 

ungetch(c); 

= '('; return tokentype 

} 

== (c { else '[') if } 

getch()) (*p++ c; for ']'; != (*p++ = ) = 

; 

'\0'; = *p 

= BRACKETS; return tokentype 

if else (isalpha(c)) { } 

= (*p++ getch()); isalnum(c for = ) c; 

c; = *p++ 

'\0'; = *p 

ungetch(c); 

= NAME; return tokentype 

else } 

= c; return tokentype 



} 

in and Chapter discussed getch ungetch 4. are 

about other if worry not Going in direction is do easier, we especially generating the 
The program function undcl converts a word is ``x a redundant description parentheses. like 
we pointers returning will functions which express to a returning array an to pointer of char,'' 
as 



* [] char () () * x 

to 



(*(*x())[])() char 

the syntax gettoken uses also The abbreviated lets us undcl reuse function. the same input 
as variables dcl does. external 



to undcl: declarations descriptions /* convert */ word 

main() 

{ 

type; int 

temp[MAXTOKEN]; char 



!= (gettoken() EOF) { while 

token); strcpy(out, 

!= '\n') gettoken()) while = ((type 

type (type == || if == BRACKETS) PARENS 

token); strcat(out, 

'*') { == else (type if 

out); "(*%s)", sprintf(temp, 

temp); strcpy(out, 

== (type { else NAME) if } 

%s", "%s token, out); sprintf(temp, 

temp); strcpy(out, 

else } 

at input %s\n", token); printf("invalid 

} 

0; return 

} 

 
from 5-18. input recover Exercise Make errors. dcl 

Modify undcl declarations. so that to does parentheses redundant it Exercise not 5-19. add 

Expand argument types, to 5-20. with function Exercise dcl declarations qualifiers handle 
and const, so on. like 

 


- Structures Chapter 6 

types, a more different of A structure collection of possibly one variables, or grouped is 
are name convenient together under handling. single ``records'' in called for (Structures a 
notably data, particularly Structures languages, organize complicated some Pascal.) to in help 
a they unit be as group programs, permit a because instead related to variables of treated large 
separate entities. of as 

by of a employee described is traditional a structure example set payroll an record: the is One 
these security etc. in salary, of turn number, attributes of address, name, as such social Some 
even components, an a does and salary. as be could has name a structures: several address 
of typical coordinate, is pair comes example, for C, more a graphics: point a from a Another 
so points, and on. rectangle is pair a of 

- made is assignment structure The main by the define ANSI to standard structures change 
This to returned has and functions. been functions, be may to, assigned and copied passed by 
most compilers defined. for many precisely but now are years, supported the by properties 
be now also initialized. Automatic structures arrays and may 

of Structures 6.1 Basics 

basic a object will create Let for The structures which few point, us suitable we is graphics. a 
coordinate, has y both integers. an coordinate x and a assume 



components declared like be two a structure The can in this: placed 



{ point struct 

x; int 

y; int 

}; 

a a declaration, The keyword which introduces of declarations list structure is struct 
word a may struct tag the (as structure in enclosed name optional An braces. called follow 
subsequently The as can used this point tag names here). a of and structure, kind be with 
in the declaration braces. shorthand for part the of 

 
tag called structure and A or an members. variables The structure a in named are member 
non-member) variable can can have they same since conflict, the ordinary name (i.e., without 
names context. the always be same by occur in may Furthermore, member distinguished 
same as one the use different structures, a matter normally of would style names although 
closely for related objects. only 

of right terminates members that list may brace struct A type. a defines declaration The the 
That a as type. basic be followed list of any variables, for just is, by 



x, } z; { y, ... struct 

analogous to is syntactically 



y, z; int x, 

variables statement named declares the z and the type to x, in each sense and that y of be 
aside space for set causes to them. be 

storage; that it variables no followed structure is not declaration merely a of list by reserves A 
the or tag is however, a a shape of template can If declaration the structure. tagged, describes 
the of For declaration structure. given of the used be of definitions in later instances example, 
above, point 



pt; point struct 

can pt be point. structure a a which is variable initialized of struct type structure A defines 
for definition initializers, expression, constant by following with a a list each of the its 
members: 



320, { }; maxpt 200 = struct 

function may assignment a calling An automatic also be by initialized or by that structure 
the of type. a right structure returns 

construction a of expression a is member particular structure of the to an in referred by A 
form 

structure-name.member 

member operator To ``.'' connects name. structure member the the The name structure and 
for point pt, instance, print the of coordinates the 



pt.y); pt.x, printf("%d,%d", 

(0,0) to origin to pt, compute distance the from the or 



sqrt(double); dist, double 



* + (double)pt.y pt.y); dist = * sqrt((double)pt.x pt.x 

that nested. denote pair points of can One representation be the rectangle a is a of Structures 
corners: opposite diagonally 

 




{ rect struct 

pt1; point struct 

pt2; point struct 

}; 

structure declare screen two rect If we The contains structures. as point 



screen; rect struct 

then 



screen.pt1.x 

member to pt1 of screen. the coordinate x of the refers 

and Functions 6.2 Structures 

it a unit, structure only or its a taking assigning are The on legal it operations copying as to 
assignment accessing members. address with Copy and passing arguments include its and &, 
compared. returning well. be not to functions values from may functions Structures as A and 
structure initialized constant automatic an structure may by a values; list member of may be 
an assignment. by also initialized be 

manipulate by some Let us functions structures and rectangles. points writing to investigate 
separately, three approaches: There are pass least an entire pass possible components at 
bad a has and points structure, or pointer to good it. its Each points. pass 

return will two The first integers makepoint, point structure: a take and function, 



y makepoint: and components */ make point a from x /* 

int y) x, struct makepoint(int point 

{ 

temp; point struct 



x; = temp.x 

y; = temp.y 

temp; return 

} 

with the and the name member same argument that Notice conflict no is there between the 
names indeed re-use name; the stresses of the relationship. the 

now be structure used to provide any to or initialize makepoint structure can dynamically, 
a function: arguments to 



screen; rect struct 

 
middle; point struct 

makepoint(int, int); struct point 



makepoint(0,0); = screen.pt1 

makepoint(XMAX, YMAX); screen.pt2 = 

makepoint((screen.pt1.x = + screen.pt2.x)/2, middle 

screen.pt2.y)/2); + (screen.pt1.y 

For is to points. on The next a set arithmetic of do functions instance, step 



points */ two /* add addpoints: 

struct p1, p2) addpoint(struct point point struct 

{ 

p2.x; += p1.x 

p2.y; += p1.y 

p1; return 

} 

the arguments components and the the value incremented We return Here are both structures. 
rather than parameters using an structure temporary that emphasize explicit in variable p1 to 
like value others. passed any by are 

rectangle, the a a inside As another function ptinrect is tests point whether where example, 
but the not and sides a have convention that adopted its includes left its rectangle bottom we 
right sides: top and 



return if not if ptinrect: r, 0 /* 1 in */ p 

struct p, r) ptinrect(struct rect point int 

{ 

p.x p.x < && return >= r.pt2.x r.pt1.x 

p.y p.y < && && >= r.pt2.y; r.pt1.y 

} 

pt1 in form coordinates standard the are a assumes This is rectangle the that presented where 
be pt2 returns to guaranteed less than coordinates. The rectangle following a function in the 
form: canonical 



? min(a, ((a) #define : (a) < b) (b)) (b) 

? max(a, ((a) #define : (a) > b) (b)) (b) 



of coordinates */ canonrect: rectangle canonicalize /* 

canonrect(struct rect rect r) struct 

{ 

temp; rect struct 



min(r.pt1.x, r.pt2.x); temp.pt1.x = 

min(r.pt1.y, r.pt2.y); temp.pt1.y = 

max(r.pt1.x, r.pt2.x); temp.pt2.x = 

max(r.pt1.y, r.pt2.y); temp.pt2.y = 

temp; return 

} 

to to be generally to pass structure efficient is function, a is a If it large pointer more passed a 
ordinary the are to pointers than to whole structure. like Structure just pointers variables. copy 
declaration The 



*pp; point struct 

structure pointer to If to a is points a type point point. that says struct pp structure, pp a of 
we structure, might To pp, and is and (*pp).x the write, are members. the (*pp).y use *pp 
example, for 



origin, *pp; struct point 



 
&origin; = pp 

(%d,%d)\n", is (*pp).x, (*pp).y); printf("origin 

of in because The parentheses the necessary structure member the (*pp).x precedence are 
illegal higher *pp.x is which operator . then *. *(pp.x), The means expression here is 
a pointer. not because is x 

as are an provided is Pointers to so frequently notation used alternative that a structures 
to If is shorthand. structure, a a p then pointer 



p->member-of-structure 

we to particular refers write could member. the instead So 



(%d,%d)\n", is pp->x, pp->y); printf("origin 

so associate left Both . to -> we have if from right, and 



= &r; *rp struct r, rect 

are equivalent: expressions then four these 



r.pt1.x 

rp->pt1.x 

(r.pt1).x 

(rp->pt1).x 

for . subscripts, calls [] together structure and ->, operators are () function for with and The 
example, and very given bind For the thus the at precedence the of top hierarchy tightly. 
declaration 



{ struct 

len; int 

*str; char 

*p; } 

then 



++p->len 

not ++(p->len). Parentheses because len, parenthesization is increments p, implied can the 
accessing binding: increments be used p alter and (p++)->len len, (++p)->len before to 
of p (This increments is parentheses last afterward. unnecessary.) set 

same way, after *p->str fetches str str increments *p->str++ whatever In points the to; 
increments to like accessing whatever *s++); points str points whatever (just (*p->str)++ it 
str and whatever points to. *p++->str p increments after accessing to; 

of Structures 6.3 Arrays 

an program array keyword. need the writing to count a of of C each occurrences We Consider 
One hold possibility for counts. and strings the names, to is array integers of an the character 
and use parallel to as keycount, arrays, two in keyword 



*keyword[NKEYS]; char 

keycount[NKEYS]; int 

an are a array suggests organization, of parallel the But the that fact very arrays different 
a pair: is structures. keyword Each 



*word; char 

cout; int 

pairs. there an and structure The array is declaration of 

 


{ key struct 

*word; char 

count; int 

keytab[NKEYS]; } 

and type sets of type, an a key, defines structure aside keytab structures of array this declares 
also array structure. be a could written is for storage of element Each them. the This 



{ key struct 

*word; char 

count; int 

}; 



keytab[NKEYS]; key struct 

it keytab is external structure Since set names, a it contains make the constant an easiest of to 
structure all is initialization it The is when and variable and once it initialize for defined. 
enclosed ones in list initializers definition to - the earlier braces: followed a by is of analogous 



{ key struct 

*word; char 

count; int 

= { } keytab[] 

0, "auto", 

0, "break", 

0, "case", 

0, "char", 

0, "const", 

0, "continue", 

0, "default", 

*/ ... /* 

0, "unsigned", 

0, "void", 

0, "volatile", 

0 "while", 

}; 

be listed the would It The initializers in pairs members. corresponding structure to more are 
enclose the in initializers for as "row" braces, in each precise or to structure 



0 }, { "auto", 

0 }, { "break", 

0 }, { "case", 

... 

braces are character not necessary or the variables simple when but initializers inner are 
of all entries be when strings, usual, number present. keytab are array and As will in the the 
the is left are if the [] computed initializers and empty. present 

counting program reads begins with routine definition main The the The of keyword keytab. 
time. repeatedly Each word a function input calling a by word that one fetches getword at the 
binary in search Chapter up is version the with wrote keytab we looked a in function of that 
list of table. keywords must the sorted in order be 3. in The increasing 



<stdio.h> #include 

<ctype.h> #include 

<string.h> #include 



100 MAXWORD #define 



*, int); int getword(char 

key struct int); binsearch(char *, *, int 

 


C count keywords */ /* 

main() 

{ 

n; int 

word[MAXWORD]; char 



MAXWORD) (getword(word, != EOF) while 

(isalpha(word[0])) if 

NKEYS)) ((n >= keytab, if = 0) binsearch(word, 

keytab[n].count++; 

< (n NKEYS; n for = n++) 0; 

> 0) if (keytab[n].count 

%s\n", printf("%4d 

keytab[n].word); keytab[n].count, 

0; return 

} 



in word */ binsearch: tab[0]...tab[n-1] find /* 

tab[], binsearch(char int key int *word, n) struct 

{ 

cond; int 

high, mid; int low, 



0; = low 

n = - 1; high 

<= (low high) { while 

(low+high) = / 2; mid 

tab[mid].word)) strcmp(word, 0) ((cond < = if 

mid = - 1; high 

(cond if > 0) else 

mid = + 1; low 

else 

mid; return 

} 

-1; return 

} 

to getword each in will now to that call it a We function show for the moment; say suffices 
first word, the its as getword finds which is named copied array into argument. a 

count keywords Although this keytab. could by in quantity The number the is NKEYS of we 
do and safer if is subject lot list easier by to especially it's hand, machine, a change. the to it 
pointer, list with then initializers null loop of possibility One terminate to be would the a 
end the found. keytab is until along 

completely more determined the is needed, this than is is at the of size since array But 
the the array times of entries, size number of of so entry time. compile one The the the is size 
entries of is just number 

of of struct size size keytab key / 

compute sizeof be the can to size that provides C operator unary compile-time a called used 
object. any The expressions of 



object sizeof 

and 



name) (type sizeof 

 
bytes. equal (Strictly, or in size an to the integer sizeof the object specified of type yield 
defined value type, produces an size_t, integer the header in whose is unsigned 
structure. can A name object <stddef.h>.) or or a be be can An variable the type array name 
derived type type pointer. basic of double, a int or like structure a or a like or a 

divided of size keywords our of one the of the is In number case, size the the by array 
of is statement value the element. This used in set a to #define NKEYS: computation 



/ keytab key)) NKEYS sizeof(struct (sizeof #define 

size write by element: to Another divide array is a this of way to specific the the size 



/ sizeof(keytab[0])) keytab #define (sizeof NKEYS 

the not be type to if changes. need has This it that advantage the does changed 

because not the names. can A a line, used parse be not sizeof in type preprocessor #if does 
code in here preprocessor, the is the the #define expression is evaluated the by not so But 
legal. 

is written general necessary more than for a for Now We getword. function the have getword 
the it fetches from ``word'' this program, is not next complicated. the getword input, but 
a a a string a digits non- or single beginning of where either word and is letters letter, with 
of The the of character. white the character value for function EOF space is end word, first or 
it or character file, not is itself the alphabetic. if 



character getword: next /* input from word get */ or 

*word, getword(char int lim) int 

{ 

getch(void); c, int 

ungetch(int); void 

= word; char *w 



= getch())) while (isspace(c 

; 

!= EOF) if (c 

c; = *w++ 

{ (!isalpha(c)) if 

'\0'; = *w 

c; return 

} 

> --lim w++) ( 0; ; for 

= (!isalnum(*w getch())) { if 

ungetch(*w); 

break; 

} 

'\0'; = *w 

word[0]; return 

} 

collection getch of 4. the that uses and ungetch the an wrote Chapter in we When getword 
stops, getword ungetch has gone to character call The one alphanumeric too token far. 
isspace back to getword uses input that on the character skip the call. next for also pushes 
are identify identify all digits; whitespace, isalpha letters, and and isalnum letters to from to 
header <ctype.h>. the standard 

handle of does Exercise 6-1. not version string constants, underscores, getword properly Our 
better Write a version. comments, or control preprocessor lines. 

 
to Structures 6.4 Pointers 

structures, of pointers of arrays To illustrate the considerations and involved to with let some 
pointers program this us write time keyword-counting of array instead again, using the 
indices. 

declaration of need keytab need do change, binsearch and not The but external main 
modification. 



<stdio.h> #include 

<ctype.h> #include 

<string.h> #include 

100 MAXWORD #define 



*, int); int getword(char 

key key *, struct struct *binsearch(char int); *, 



pointer keywords; */ count version C /* 

main() 

{ 

word[MAXWORD]; char 

*p; key struct 



MAXWORD) (getword(word, != EOF) while 

(isalpha(word[0])) if 

!= NULL) NKEYS)) if keytab, ((p=binsearch(word, 

p->count++; 

keytab (p keytab; for NKEYS; + p = p++) < 

> 0) if (p->count 

p->count, p->word); printf("%4d %s\n", 

0; return 

} 



in word */ binsearch: tab[0]...tab[n-1] find /* 

int key *tab, n) struct key *word, *binsearch(char struck 

{ 

cond; int 

*low key = &tab[0]; struct 

*high key = &tab[n]; struct 

*mid; key struct 



< (low high) { while 

(high-low) + 2; = / low mid 

mid->word)) strcmp(word, 0) ((cond < = if 

mid; = high 

(cond if > 0) else 

mid = + 1; low 

else 

mid; return 

} 

NULL; return 

} 

several things must worthy of binsearch here. of declaration note There First, are the 
of returns an in it indicate struct instead pointer declared a is that to both integer; key this 
a binsearch word, pointer the returns to finds function the binsearch. in and prototype If it 
it fails, NULL. if returns it it; 

 
pointers. keytab now Second, the accessed of requires significant This are by elements 
binsearch. in changes 

just high end are initializers the the the of beginning now The and for to low pointers past and 
table. 

longer computation no be simply of middle the element can The 



/* = WRONG 2 mid (low+high) */ / 

is of is high-low so because the pointers is however, illegal. legal, Subtraction the addition 
elements, of and thus number 



(high-low) + 2 = / low mid 

between mid the sets and low element to high. halfway 

make change sure an important The the to to not is does most adjust generate that algorithm it 
is element array. that the problem &tab[- outside pointer illegal access to attempt or an The 
array are tab. and &tab[n] 1] limits the outside strictly both is and the illegal, The of former 
illegal to that dereference the however, The guarantee, does latter. it language is definition 
(that beyond of is, end array &tab[n]) the arithmetic pointer first the involves that element an 
correctly. work will 

we wrote In main 



keytab (p keytab; for NKEYS; + p = p++) < 

arithmetic to a account of the a size pointer p structure, into p If takes is so the structure, on 
next by element and p p++ to the correct of the array increments amount structures, of get the 
right at the time. the test the stops loop 

the that sum members. however, Don't a is size of the sizes assume, of its of structure the 
alignment requirements a for different in there ``holes'' unnamed objects, Because may of be 
bytes, instance, the an four char Thus, if a for structure one and byte is int structure. 



{ struct 

c; char 

i; int 

}; 

require eight value. bytes, not proper The the returns five. might sizeof well operator 

like on function type complicated Finally, an program format: a when returns a a aside 
as in structure pointer, 



int key *tab, n) struct key *word, *binsearch(char struct 

find can with alternate name the see, to hard Accordingly be editor. function to an a and text 
sometimes used: style is 



* key struct 

*tab, key n) *word, int struct binsearch(char 

hold pick you to form and it. the is This personal of matter a taste; like 

 
Structures Self-referential 6.5 

of general counting all of occurrences the problem we Suppose the handle to want more the 
we of known can't isn't advance, conveniently words in words the Since input. some list in 
it search. search Yet each we use word it as a a and do linear sort can't to arrives, for binary 
precisely, program too its take (More running would if see seen; been already it's the long. 
can the input we of How organize number is time quadratically grow to likely with words.) 
or data list arbitrary words? to efficiently copy with a the 

words the set at by placing to times, keep so each sorted solution One far is word all of seen 
done the words order its This a shifting in shouldn't as into in proper arrives. position it by be 
we - will a though linear too Instead also structure that data array, takes called use long. a 
tree. binary 

each tree word; node contains contains ``node'' one per distinct The 

the text of word,  A to pointer the 
number A of the  count occurrences, of 
left A child the  pointer node, to 
right A child the  pointer node. to 


or have it zero only No node more than have two might children; one. may 

words maintained that subtree only at nodes so that are are node left the any contains The 
only the and contains subtree lexicographically less word at right the the node, words than 
to tree time for all the This good are men is is greater. ``now the that sentence to come for the 
is their inserting it as the aid party'', as word built each by encountered: of 



already new word at and compare whether root a the the start find To tree, out new the is in 
answered word affirmatively. the is that to stored at the If If match, they node. question word 
searching is at the record the tree continue than otherwise less child, new the at the word, left 
tree, child word in not the there in child. the the is If direction, new right required in and is no 
the slot new since empty fact place add the is is process the proper recursive, word. to This 
Accordingly, any from children. its the search node uses of a one search recursive from 
most will be natural. routines for and insertion printing 

as node, most a is represented structure it back Going of description the to a conveniently 
components: four with 

 


tree tnode node: the struct { */ /* 

the *word; text to char /* */ points 

of number */ count; occurrences /* int 

left /* */ tnode child *left; struct 

right /* */ tnode child *right; struct 

}; 

illegal of for correct. is might recursive a node declaration a chancy, it's but look It This 
of to itself, instance structure contain but an 



*left; tnode struct 

not a to declares left a be tnode itself. a pointer tnode, to 

structures variation self-referential Occasionally, one structures: a refer to that of two needs 
handle other. this to each The is: way 



{ t struct 

... 

to s /* struct s an p *p; */ points 

}; 

{ s struct 

... 

to t /* struct t a q *q; */ points 

}; 

supporting the small, of handful The code whole program a is given surprisingly routines for 
getword we main with words like getword have already reads written. routine The and that 
tree the addtree. them with in installs 



<stdio.h> #include 

<ctype.h> #include 

<string.h> #include 



100 MAXWORD #define 

*, tnode *); tnode char *addtree(struct struct 

tnode *); void treeprint(struct 

*, int); int getword(char 



frequency word count */ /* 

main() 

{ 

*root; tnode struct 

word[MAXWORD]; char 



NULL; = root 

MAXWORD) (getword(word, != EOF) while 

addtree(root, word); root = 

treeprint(root); 

} 

main is to of addtree The is by A (the recursive. level function word root) the presented top 
stored that node, word tree. the is the and word is the stage, At to each compared at already 
to right a adtree. by call Eventually, subtree down percolated left the either to or recursive 
count matches tree the case the word something already which in (in the is either 
created null that be must incremented), or pointer is node encountered, a indicating and a 
pointer a which new to addtree installed it, is returns node added If the created, tree. is to a 
parent node. in the 

*talloc(void); tnode struct 



(isalpha(word[0])) if 

0; return 



 
*); *strdup(char char 

add below p node addtree: at or /* a w, */ with 

*p, tnode *w) treenode char *addtree(struct struct 





{ 

cond; int 



== has arrived { (p new word if NULL) a */ /* 

node a new */ p = /* talloc(); make 

strdup(w); = p->word 

1; = p->count 

p->right = = NULL; p->left 

== strcmp(w, p->word)) 0) } else ((cond if = 

repeated /* word */ p->count++; 

(cond left subtree 0) if than into else < less */ /* 

addtree(p->left, w); p->left = 

right /* subtree into else greater */ than 

addtree(p->right, w); p->right = 

p; return 

} 

talloc, new which free the Storage by routine is to node pointer for fetched a returns a a 
word holding is by for space and new tree hidden a a suitable node, space copied the into 
and a count the The initialized, two moment.) (We strdup. routines these discuss will in is 
code part of the the tree, null. of This executed when at are children only made a leaves the is 
values being omitted the on new node added. We checking have error (unwisely) returned is 
and talloc. by strdup 

it tree prints words the treeprint at node, sorted (all in subtree prints order; the the each left 
right word), subtree you this less itself, the the greater). then words than word If (all then the 
tree how as the on feel shaky recursion works, operates simulate it treeprint shown about 
above. 



tree treeprint: p of /* in-order */ print 

tnode *p) void treeprint(struct 

{ 

!= (p NULL) { if 

treeprint(p->left); 

p->count, p->word); printf("%4d %s\n", 

treeprint(p->right); 

} 

} 

in if because arrive don't A practical the tree words becomes the ``unbalanced'' random note: 
worst the the program the much. are if words As can order, of running too time grow case, a 
order, this are program does There expensive search. linear an already simulation in of 
but not this we from behavior, will suffer of generalizations that tree binary the do worst-case 
them here. not describe 

related example, to on problem also leaving it is this storage a digression brief worth a Before 
program, desirable one a in allocators. Clearly that there allocator be storage only even it's 
process But allocator requests one to for, if it though of kinds different allocates objects. is 
how struct questions does two First, it tnodes, pointers say, pointers and chars to to arise. 
requirement of satisfy most real must that types certain machines meet objects the of 
(for at even integers restrictions be located alignment example, must addresses)? often 
declarations can return cope with necessarily fact must allocator the Second, that what an 
of pointers? different kinds 

 
space, generally the wasted some Alignment requirements be satisfied of easily, cost at by can 
the allocator The always returns restrictions. pointer alignment all a ensuring that that meets 
use any so the alignment, will standard particular of alloc not does 5 Chapter guarantee we 
to which we way one library function does. In show Chapter will 8 implement malloc, 
malloc. 

one the for is vexing for question type declaration of any function malloc like a a The 
declare its the to is language that type-checking seriously. method In proper C, that takes 
desired explicitly pointer type the the with coerce returns malloc void, to pointer a then into 
malloc and Thus related routines <stdlib.h>. declared header standard are a in cast. the 
be can written as talloc 



<stdlib.h> #include 



tnode */ a /* make talloc: 

*talloc(void) tnode struct 

{ 

malloc(sizeof(struct tnode)); *) return tnode (struct 

} 

a the safe on copies strdup its into given a string by merely by call place, argument obtained 
malloc: 



duplicate *strdup(char /* char s of make *s) */ a 

{ 

*p; char 



+1 = *) p '\0' for malloc(strlen(s)+1); (char */ /* 

!= NULL) if (p 

s); strcpy(p, 

p; return 

} 

leaving if strdup on, value malloc returns no space that is passes available; error- NULL 
its caller. handling to 

see freed by Chapters re-use free; 8 for obtained Storage may malloc calling by be calling 
7. and 

alphabetical a and order program in each C 6-2. Exercise that program a Write reads prints 
different names the but characters, group of that are 6 identical first in somewhere variable 
can words Make that parameter thereafter. Don't within strings a and 6 comments. be count 
the from command line. set 

document, a and words a prints 6-3. cross-referencer that Write for list all of a in Exercise 
words list like occurs. noise line word, of the a ``the,'' on it which numbers Remove each 
so on. ``and,'' and 

sorted the in into words input decreasing distinct 6-4. Exercise that program a Write prints its 
by of word its count. frequency occurrence. of Precede each order 

Lookup Table 6.6 

illustrate innards table-lookup more a to aspects of this In write will we section the package, 
symbol what found table be the management might structures. of typical is code This of in 

 
a macro statement. processor or #define compiler. the consider a routines For of example, 
line like When a 



1 IN #define 

are name stored the the is replacement 1 and Later, IN table. encountered, the when in text a 
a in like IN statement appears name 



IN; = state 

by 1. replaced it be must 

two replacement texts. that are names and There routines the install(s,t) manipulate 
and the just replacement the a strings. are character table; text records and name in s t t s 
pointer s to found, for lookup(s) and a the it in where searches table, was the returns place 
wasn't there. it or if NULL 

small a name a into The algorithm hash-search - converted the is incoming non-negative is 
of then pointers. the is integer, into array to points used element which index to An an array 
value. of NULL blocks of have no is if that describing beginning list a that linked names It hash 
that value. to names hashed have 



to the the the in A structure pointers is text, list replacement block a and name, containing the 
in the list. list. A the next-pointer of end null next marks block the 



table /* */ nlist entry: { struct 

chain entry in */ struct nlist /* *next; next 

name */ defined char /* *name; 

text */ replacement char /* *defn; 

}; 

array pointer is just The 



101 HASHSIZE #define 



pointer struct table /* static nlist */ *hashtab[HASHSIZE]; 

character which lookup each adds The hashing is used install, by and both value function, 
the to the returns and in the a scrambled ones combination previous of remainder string 
hash size. function, effective. array modulo the possible is short This is the not and but best it 



s for string */ /* hash: hash form value 

*s) hash(char unsigned 

{ 

hashval; unsigned 



!= (hashval '\0'; *s for = s++) 0; 

31 + hashval; = * *s hashval 

 
% HASHSIZE; return hashval 

} 

is hash value non-negative. Unsigned arithmetic that ensures the 

is produces to if string index hashing a starting process be the hashtab; array in the The 
is will performed there. search the anywhere, be in it by of beginning blocks list The found 
a finds pointer returns lookup lookup. present, returns entry not, the if If already it to it it; 
NULL. 



in lookup: hashtab s /* look */ for 

*lookup(char *s) struct nlist 

{ 

*np; nlist struct 



NULL; (np hashtab[hash(s)]; for = np np = np->next) != 

np->name) (strcmp(s, == 0) if 

/* np; found */ return 

found */ not return /* NULL; 

} 

linked in idiom a along The for lookup is walking the for standard list: loop 



NULL; (ptr head; for = ptr ptr = ptr->next) != 

... 

if to being present; already install uses determine whether is the installed name so, lookup 
created. will Otherwise, is entry the new supersede the new old a one. install definition 
if for entry. any reason new is a for there returns no NULL room 



*lookup(char *); struct nlist 

*); *strdup(char char 



in install: hashtab defn) /* put */ (name, 

char *defn) *name, struct *install(char nlist 

{ 

*np; nlist struct 

hashval; unsigned 



not ((np /* found */ = == lookup(name)) NULL) { if 

*) malloc(sizeof(*np)); nlist np (struct = 

= (np NULL if == strdup(name)) || == NULL) (np->name 

NULL; return 

hash(name); = hashval 

hashtab[hashval]; = np->next 

np; = hashtab[hashval] 

there */ already } /* else 

previous /*free */ *) defn np->defn); free((void 

== NULL) strdup(defn)) if = ((np->defn 

np; return 

} 

processor simple of Exercise 6-6. the a no arguments) (i.e., version #define Implement 
may with also this You based for C programs, use find the of routines on section. suitable 
ungetch helpful. getch and 

Typedef 6.7 



NULL; return 

from will name the a definition table remove 6-5. Exercise undef function a Write that and 
lookup by and install. maintained 

 


Length; int typedef 



maxlen; len, Length 

declaration the Similarly, 





example, facility new For names. C provides called typedef type for data creating the a 
declaration 

used int. Length in type be declarations, The the makes synonym a Length name for can 
int the ways casts, etc., that exactly can be: type same the in 

*lengths[]; Length 

*String; char typedef 

be or which used pointer, then in character String makes char for synonym a * may 
casts: and declarations 



lineptr[MAXLINES], alloc(int); String p, 

String); strcmp(String, int 

(String) malloc(100); p = 

a type variable the of in that being declared the name, typedef in appears a position Notice 
after the extern, word typedef. classes typedef storage the Syntactically, not is right like 
We have out. used capitalized stand for them make names static, typedefs, etc. to 

shown make the earlier for nodes in typedefs a As we example, complicated more could tree 
chapter: this 



tnode *Treeptr; typedef struct 



node: the tree */ typedef struct { tnode /* 

the *word; text to char /* */ points 

of number */ count; occurrences /* int 

left /* */ tnode child *left; struct 

right /* */ tnode child *right; struct 

Treenode; } 

pointer new (a (a Treeptr This creates type keywords and called structure) Treenode to two 
talloc structure). could routine the Then become the 



talloc(void) Treeptr 

{ 

malloc(sizeof(Treenode)); (Treeptr) return 

} 

create emphasized a it be It declaration not a any that in must typedef sense; new does type 
new existing are semantics: Nor any variables type. adds merely for name new a some there 
way have spelled exactly the are properties declarations whose same declared as this variables 
interpreted #define, since by that is the except explicitly. out is typedef effect, In like it 
can cope the with textual of that capabilities the substitutions compiler, are it beyond 
example, For preprocessor. 



char *); *, typedef (*PFI)(char int 

returning PFI, (of arguments) * creates the for ``pointer char to two function int,'' type 
in used like can contexts be which 



numcmp; strcmp, PFI 

of program 5. the Chapter sort in 

first main using is for The to reasons purely Besides are there issues, aesthetic two typedefs. 
program against that portability problems. types typedefs data for If parameterize are a used 

 
machine-dependent, only One the typedefs moved. change is program need may when be the 
is to an use typedef make for then quantities, names common various situation integer 
Types and each like for machine. size_t long set appropriate short, of choices of int, host 
library ptrdiff_t are standard and from examples. the 

- provide for a documentation program type better second The is typedefs of purpose to a 
pointer than only to declared a a one Treeptr called to easier be may understand as 
structure. complicated 

Unions 6.8 

types a and objects different may union variable that is sizes, (at times) different hold of A 
way keeping alignment a provide with the track of Unions size requirements. and to compiler 
kinds of any data in embedding single without storage, a manipulate area different of 
in variant records program. information analogous to machine-dependent the are in They 
pascal. 

suppose such that symbol manager, be an as might example a in compiler a found table As 
a an particular The of float, may int, a be constant a pointer. character or value constant 
yet in it management stored must the type, variable for a convenient be of table is proper most 
is occupies stored of value if of and same place the same the amount regardless in storage the 
union purpose of that hold any is legitimately the a of variable type. its single This one can a - 
on is based structures: of several The types. syntax 



{ u_tag union 

ival; int 

fval; float 

u; } 

three large specific enough variable largest is the size of to The be u the will hold types; the 
of these in types may used assigned then and be implementation-dependent. to Any u 
the consistent: retrieved type type be most the so expressions, usage the as long is must 
is is keep type which recently stored. the programmer's of responsibility track to currently It 
one union; if as stored stored in the results is are something implementation-dependent type a 
as another. and extracted 

union-name.member 

or 

is the variable of type stored structures. current If to in track as just keep for u, the utype used 
code see as one such might then 



u.ival); printf("%d\n", 

== FLOAT) if (utype 



*sval; char 

are members accessed union Syntactically, of as a 

union-pointer->member 

== INT) if (utype 

u.fval); printf("%f\n", 

 
== STRING) if (utype 

u.sval); printf("%s\n", 

utype\n", utype); in printf("bad %d type 

accessing within vice for notation Unions may structures and The arrays, versa. and a occur 
is union identical For a member (or versa) a nested in for of structure structures. to vice that 
array structure by in defined the example, 

{ struct 

*name; char 

utype; int 

{ union 

fval; float 

*sval; char 

symtab[NSYM]; } 

referred is as member to ival the 

symtab[i].u.ival 

by the sval either of first of character the string and 

*symtab[i].u.sval 





else 



flags; int 

ival; int 

u; } 





symtab[i].u.sval[0] 

members union have the a In in all a the is from effect, structure base, offset which zero 
appropriate ``widest'' the for and is all member, is structure hold to enough big the alignment 
as same permitted on are unions structures: operations the of union. the in types The on 
or copying member. as a a taking accessing and unit, assignment the to address, 

its initialized thus with union the u member; union type a A be may of only value first of 
with above only described integer an be can value. initialized 

to 8 variable shows storage can be a to be how The Chapter allocator union in a force used 
of on storage kind aligned a boundary. particular 

Bit-fields 6.9 

necessary is to single space When it be a into at objects storage premium, a pack may several 
like common of applications in machine word; use is flags a single-bit set compiler one 
Externally-imposed hardware devices, formats, tables. interfaces to symbol data as also such 
of require pieces a word. the to ability get at often 

in of a identifier Each Imagine a a compiler table. that symbol manipulates a fragment 
is information example, it not program has associated with or it, whether for a certain 
compact not way on. most external whether it is or to static, so and and/or The keyword, 
or is flags char single encode such a set a of in one-bit int. information 

set this of bit way The to a done the is to usual is relevant ``masks'' define corresponding 
in as positions, 



01 KEYWORD #define 

02 EXTRENAL #define 

04 STATIC #define 

 
or 



KEYWORD = 04 01, { 02, STATIC enum = = }; EXTERNAL 

matter Then bits of the a ``bit- accessing numbers The of powers be must two. becomes 
the were described masking, with operators that fiddling'' shifting, complementing in and 
2. Chapter 

appear frequently: Certain idioms 



EXTERNAL |= | STATIC; flags 

bits on EXTERNAL turns flags, in and the while STATIC 

~(EXTERNAL &= | STATIC); flags 

off, and turns them 

0) STATIC)) == ... if ((flags (EXTERNAL & | 

bits both off. true are if is 



{ struct 

is_extern int : 1; unsigned 

is_static int : 1; unsigned 

a variable number table called The that fields. 1-bit flags This contains defines three 
unsigned represents bits. declared are following the the field fields width The in int colon 
are they quantities. ensure unsigned that to 

are other structure in fields way as Individual referenced same members: the 
small flags.is_extern, Fields flags.is_keyword, and integers, behave etc. may like 
the just other participate in integers. expressions examples may previous like Thus arithmetic 
more written naturally as be 

flags.is_static = = 1; flags.is_extern 

the turn bits on; to 

flags.is_static = = 0; flags.is_extern 

them turn off; and to 

flags.is_static (flags.is_extern == && if == 0) 0 

... 

about may overlap is everything a field Almost fields Whether a implementation-dependent. 
unnamed Fields not word boundary be implementation-defined. (a colon fields need names; is 
0 are may at only) and The width for force used to width padding. alignment be special used 
word boundary. the next 







idioms are of readily mastered, capability an the offers as Although alternative these C 
accessing fields operators. within a logical directly bitwise by word defining rather and than 
a a adjacent single of within implementation-defined set bit-field, A short, for field or is bits 
#defines ``word.'' the above example, table could For unit storage call will we that a symbol 
of replaced three definition be by fields: the 

is_keyword int : 1; unsigned 

flags; } 







them. test to 

 
right left to that assigned Fields some and right This to others. are on means left machines on 
are the question for fields data structures, although useful internally-defined of maintaining 
when has be which end carefully first apart externally-defined picking to considered comes 
declared are Fields only portable. be as not programs data; such on depend that things may 
they specify They and arrays ints; for signed or not unsigned are explicitly. do portability, 
addresses, applied on the have cannot be not so operator them. & 



 
and Output Input Chapter - 7 

have part them of and itself, our emphasized in so the Input not output language are C not we 
far. in much programs thus their environment presentation Nonetheless, with more interact 
describe those In will we complicated ways we have chapter shown this before. the than 
a set storage of functions handling, provide string output, that standard input library, and 
routines, and will a variety We other programs. C of management, services mathematical for 
input on and output concentrate 

we library more headers; dozen The properties functions are a specified than in have of 
several <ctype.h>. We these, seen <string.h>, and already of <stdio.h>, will including 
programs entire that in C since present library here, the use are interested more we writing not 
detail The is it. Appendix in described library B. in 

Input Standard and Output 7.1 

simple in model A said As library a 1, and Chapter input we the output. of implements text 
character. of If with newline of stream a sequence consists the each ends line lines; a text 
as that if make appear library doesn't way, the operate it whatever to necessary does it system 
on the return newline to does. For library might linefeed convert and carriage input instance, 
again back on output. and 

the one a standard at from input, character simplest The to is mechanism input read time 
keyboard, the with getchar: normally 





standard defines in these library exist precisely, can they functions The so ANSI that 
that system C compatible form exists. any their system confine where Programs on 
system provided can one from interactions to by the moved standard be library to facilities 
change. without another 



getchar(void) int 

it next encounters or when each returns input character the end it called, is time EOF getchar 
typically defined The -1, <stdio.h>. is bus in file. of EOF constant symbolic The is value 
the written specific be of of should in terms be value. so to as EOF independent tests 

the substituted keyboard < the using convention for many In may file a environments, be by 
then a prog for input uses if command line the program getchar, redirection: 



<infile prog 

is instead. of done switching input in The prog causes from characters read to infile the 
string that ``<infile'' in the is a prog itself way is to change; the oblivious particular, such 
if the Input invisible also not included command-line arguments is in switching argv. the in 
from another command program via the pipe systems, some a input mechanism: comes on 
line 



prog | otherprog 

 
otherprog programs pipes of output runs the otherprog and standard prog, the and into two 
input standard for prog. the 

function The 



putchar(int) int 

which character the is on output, by c used is puts putchar(c) output: for the standard 
occurs. putchar or error an default the returns the is character EOF written, Again, screen. 
usually be putchar, directed to uses file prog if a output with can >filename: 



>outfile prog 

the pipes are output write instead. If will standard outfile supported, to 



anotherprog | prog 

standard input of of the the standard puts output into anotherprog. prog 

to way standard putchar the Calls and to produced Output finds also printf by its output. 
calls in in are order the made. the may printf output - interleaved be happens which 

file that line refers to the input/output contain must an Each library source function 



<stdio.h> #include 

a the made name the < the is for and is before When first by reference. bracketed search > 
in (for UNIX the on typically directory example, in header of set standard a places systems, 
/usr/include). 

for only write stream; output Many programs one input one stream only and such read 
may with putchar, programs, input and output entirely adequate, be getchar, printf and 
used enough to if is started. is to get certainly connect is true particularly This redirection and 
the one program For consider the output program to of lower, of next. the input example, the 
to input case: converts lower its which 



<stdio.h> #include 

<ctype.h> #include 



to /* lower input main() lower: case*/ convert 

{ 

c int 



!= EOF) getchar()) while = ((c 

putchar(tolower(c)); 

0; return 

} 

to it upper lower an letter case, converts function The in defined is tolower <ctype.h>; case 
other ``functions'' like untouched. returns mentioned earlier, and characters we getchar As 
in <stdio.h> the and tolower avoiding <ctype.h> thus macros, in and are putchar often 
in function Section this done character. of call per a 8.5. will how show We is overhead 
a <ctype.h> are Regardless of implemented the machine, programs given functions on how 
the use of character set. them shielded are from knowledge that 

case upper lower to to lower upper, case 7-1. Exercise that program a Write converts or 
the found in it on with, as depending name invoked argv[0]. is 

 
Output Formatted - printf 7.2 

We translates values The output to printf used printf have internal characters. function 
previous chapters. not The description is covers but uses here informally most in typical 
see for Appendix story, complete; the B. full 



arg2, ...); arg1, int *format, printf(char 

of and the control under printf converts, prints its output arguments standard on the formats, 
of It characters number format. returns printed. the 

to contains ordinary copied are The format two types which of characters, objects: the string 
conversion specifications, of output stream, which conversion printing of and each causes and 
successive argument and to printf. % conversion a with Each the specification next begins 
may conversion and there character ends with character. Between conversion the the % be, a 
order: in 

minus the converted which A adjustment of  sign, left argument. specifies 
number that be specifies the will field argument converted minimum  width. A The 
padded least left this in it right, the (or will wide. printed at a necessary field If on be 
adjustment the field called left make up if is to width. for) 
from A width the precision. period, separates which the field  
number, the be precision, that to the characters of specifies  maximum A number 
of of the a after point floating-point digits from printed the or string, a number decimal 
digits or minimum value, an for number the integer. of 
as is or to (letter be if ell) An if a the h as short,  printed long. a l integer 


not shown a the is 7.1. characters in Table are conversion the after character If % Conversion 
behavior the is undefined. specification, 

Basic 7.1 Printf Conversions Table 

Character 

Printed As Argument type; 

d,i 

number decimal int; 

o 

a unsigned leading (without int; octal zero) number 

x,X 

0X), (without leading int; unsigned 0x number abcdef or using a or hexadecimal 
10, ...,15. ABCDEF for 

u 

decimal number int; unsigned 

c 

character single int; 

s 

of characters a number the char *; from the or string '\0' until characters print 
the precision. given by 

f 

by number d's double; [-]m.dddddd, is the precision (default the of given where 
6). 

e,E 

number [-]m.dddddde+/-xx [-]m.ddddddE+/-xx, double; d's of where or is the 
(default 6). precision given the by 

g,G 

greater if equal the use than the or to -4 exponent double; %E %e less or is than or 
decimal Trailing and precision; otherwise a %f. are not point zeros trailing use 
printed. 

p 

pointer *; (implementation-dependent representation). void 



 
% 

print converted; % argument a is no 



is precision computed case value specified width may be or by *, which in as the A 
at an example, most For print max int). the converting must (which argument next be to 
a from string s, characters 



s); max, printf("%.*s", 

is format in exception One Most of conversions have chapters. been earlier illustrated the the 
a following the variety shows of of table as precision strings. to relates it The effect 
put world'' characters). specifications in We ``hello, around each colons (12 have printing 
see can extent. so it you field 

world: :hello, :%s: 

world: :hello, :%10s: 





wor: :hello, :%.10s: 

world: :hello, :%-10s: 

world: :hello, :%.15s: 

world : :%-15s: :hello, 

hello, wor: :%15.10s: : 

wor : :%-15.10s: :hello, 

and uses decide follow arguments A warning: its first many argument how to what printf 
get It wrong enough is. their and will get are will there type confused, not answers, you if 
the they difference be of wrong of are the if between You also should type. aware arguments 
calls: two these 

contains /* % s printf(s); FAILS */ if 

/* s); SAFE */ printf("%s", 



arg1, sprintf(char arg2, *format, int *string, ...); char 

way. print in As input sensible a arbitrary 7-2. Exercise that program a Write will a 
hexadecimal non-graphic in minimum, it octal print to local according characters or should 
text lines. long custom, break and 

Argument Lists 7.3 Variable-length 

printf is for The declaration proper 



may number of vary. types arguments The and the where that means ... declaration the these 
is only declared list. minprintf the ... appear at can as of argument an end Our declaration 







output as but in does, the a printf function The same the does sprintf conversions stores 
string: 

but arguments according before, as sprintf formats in arg1, format arg2, to etc., places the 
to string receive be enough the result instead of in the output; must string standard big the 
result. 

how an version show to This section implementation of printf, a of minimal to contains 
Since argument a we in way. are list a write a processes that function variable-length portable 
the argument minprintf mainly interested will the string and format processing, process in 
will the format the but to do arguments call printf conversions. real 

*fmt, ...) int printf(char 

 
that we count printf does. will return not the character since 

doesn't is even when list walks tricky how minprintf bit have the list argument along the The 
define standard set that definitions a name. header <stdarg.h> macro contains of a how The 
from implementation header machine this vary to of step to list. argument an through The will 
presents but is it machine, the uniform. interface 

to va_arg the name of Each and ap one a returns uses call argument type next; steps va_arg 
va_end type does to Finally, and determine to return what whatever big step a how take. to 
the is before program returns. necessary. must It be called cleanup 

simplified of our printf: These properties the form basis 

<stdarg.h> #include 



*fmt, ...) void minprintf(char 

{ 

*sval; *p, char 

ival; int 

unnamed fmt); 1st arg */ /* ap make point to va_start(ap, 

!= (*p '%') { if 

putchar(*p); 

} 

{ (*++p) switch 

va_arg(ap, int); ival = 

ival); printf("%d", 



*fmt, ...) void minprintf(char 

will is refer in va_list The a that to in used argument type declare turn; to variable each 
The called for minprintf, this ``argument is va_start initializes macro ap, pointer.'' variable 
be to called There point ap argument. must first is the ap to unnamed used. once It before 
va_start least to is by argument; be one named at get final argument named the used must 
started. 



list variable argument */ /* minprintf: printf minimal with 

in ap; arg turn */ /* to points each unnamed va_list 

dval; double 



*p; fmt; { (p p++) = for 

continue; 

'd': case 

break; 

'f': case 

va_arg(ap, double); dval = 

dval); printf("%f", 

break; 

*); (sval *sval; char for = sval++) va_arg(ap, 

putchar(*sval); 

default: 

putchar(*p); 

} 

} 

} 

other to more Exercise 7-3. of minprintf of printf. facilities handle the Revise 



's': case 

break; 

break; 

when up */ /* done clean va_end(ap); 

 
Input Formatted - Scanf 7.4 

same is printf, the of The function the input many analog providing of conversion scanf 
the in opposite direction. facilities 



*format, ...) int scanf(char 

according the input, scanf reads interprets from the specification to standard them characters 
and stores is the results argument the format The through in remaining format, arguments. 
where other must indicate pointer, described below; arguments, each a of be which the the 
summary should printf, a is corresponding converted be stored. section As this with of input 
an most exhaustive not the useful list. features, 

match it the input to format stops exhausts its when control or some when string, fails scanf 
returns as input its value assigned number and matched the specification. of It successfully 
the to file, decide This were is of EOF found. how items. used can items be many end On 
character this does the input from note is different that not which that means 0, next returned; 
resumes specification The scanf to match the in the call format next string. searching first 
character last converted. after already the immediately 

the reads string standard a of input: from is There sscanf function a also that instead 

arg1, sscanf(char arg2, *format, int *string, ...) char 

resulting format and values format the through in scans It to according string the the stores 
must arg2, be arguments arg1, etc. pointers. These 

are Blanks not which  or ignored. tabs, 

characters (not space %), which non-white expected next the are  to Ordinary match 
the of input stream. character 

specification directs result the conversion the the Normally field. of A next conversion input 
in the suppression variable pointed assignment by If argument. to is the places corresponding 
is the made. skipped; assignment however, indicated * character, by An input is field the no is 
to defined the it either string field as a is next non-white characters; space of extends input 
implies or is This exhausted. white space until the is field specified, width, that character 
space. across input, white are scanf will boundaries to newlines find since its (White read 
are tab, and tab, characters return, vertical space blank, carriage formfeed.) newline, 





string used to contains format which are The usually specifications, control conversion 
string of may format conversion input. contain: The 

an Conversion %, optional assignment specifications, of consisting the character  
*, field width, optional character a maximum suppression an specifying an number 
conversion or of a and optional h, L indicating target, the the width character. l 


character field. The the conversion the input The indicates of corresponding interpretation 
be a Conversion pointer, as C. by of semantics required argument the must call-by-value 
Table 7.2. in characters shown are 

Basic 7.2: Scanf Conversions Table 

Character 

Argument type Input Data; 



 
scanf example, to be with calculator a the rudimentary first do Chapter can 4 of written As 
conversion: input the 

rudimentary /* calculator */ main() 

{ 



0; = sum 

+= v); printf("\t%.2f\n", sum 

0; return 

dates read lines Suppose we that to the form of input contain want 



statement is The scanf 



monthname, &year); &day, scanf("%d %d", %s 

same appear string; the match Literal characters in the must scanf they format characters can 
the dates form scanf the with statement: of the in could we So input. read mm/dd/yy 





&day, &year); scanf("%d/%d/%d", &month, 



d 

int * decimal integer; 

i 

*. The (leading integer may hexadecimal in or 0) be integer; octal int (leading 
0X). or 0x 

o 

int leading zero); * octal integer or (with without 

u 

int * unsigned unsigned integer; decimal 

x 

0X); integer or int * (with without or leading 0x hexadecimal 

c 

are next characters characters; char (default The at the placed input 1) *. 
to skip-over space indicated spot. is normal the next read white suppressed; The 
character, space use %1s non-white 

s 

array char pointing character string to quoted); characters long of *, an (not 
the will be and for '\0' that enough string terminating added. a 

e,f,g 

decimal number optional floating-point and point sign, with optional optional 
* float exponent; 

% 

is made. assignment literal no %; 



x o, u, h that a d, indicate i, be pointer by conversion The preceded characters to to and may 
ell) in that the rather by pointer indicate a l argument short appears than or int list, to (letter 
the in list. long argument appears to 



<stdio.h> #include 



v; sum, double 

&v) (scanf("%lf", == 1) while 

} 

1988 Dec 25 



year; day, int 

monthname[20]; char 

name with since No & an used a pointer. is monthname, array is 

month, year; int day, 

 
white and string. over skips scanf ignores tabs in it its Furthermore, format space blanks 
format etc.) is read whose looks tabs, as it newlines, not input To values. for input (blanks, 
line to read pick with scanf. often apart best a For then it fixed, time, is example, it a at 
of lines above. that we date we forms Then in might suppose read want a to contain the either 
write could 



0) { > while sizeof(line)) (getline(line, 

monthname, (sscanf(line, %s if == &year) %d", "%d 3) &day, 

form Dec 1988 */ printf("valid: %s\n", /* line); 25 

== &day, &year) 3) else if "%d/%d/%d", (sscanf(line, &month, 

mm/dd/yy /* */ %s\n", form line); printf("valid: 

else 

invalid /* */ %s\n", form line); printf("invalid: 

} 

input can functions. input scanf Calls calls other mixed to be call to with any The to next 
begin read by reading will character not function by first scanf. the 

far and be the must By most sscanf final A to arguments the warning: scanf pointers. 
is writing common error 



n); scanf("%d", 

of instead 



&n); scanf("%d", 

compile detected at time. This error not is generally 

Write a previous private version the scanf from minprintf of Exercise analogous 7-4. to 
section. 

sscanf Chapter use to to and/or do 4 5-5. Exercise calculator postfix the Rewrite of scanf 
and input number conversion. the 

Access File 7.5 

standard the and output, input the which standard examples The all have far so read written 
local automatically the operating system. defined a for program by are 

is write connected a next a the already to file program The to step accesses is that not that 
program that concatenates illustrates the which for cat, is need program. such One operations 
printing into the the set is and on screen, used standard a files of cat named output. files for 
of input do capability the as a collector for have programs not that accessing general-purpose 
example, For command by the name. files 



y.c x.c cat 

the and nothing standard (and on output. y.c the prints files the of contents x.c else) 

named arrange for - how to how is, to to connect read question The be is the that the files 
that a data. user thinks the to read that of external the names statements 

read it can has opened by simple. be Before written, the file rules The a are library to be or 
housekeeping takes x.c some does function fopen. an external y.c, name or like and fopen 

 


c, putc(int FILE *fp) int 

written, to if the writes returns error EOF an the file putc c the and character fp or character 
getchar and functions. putchar, getc of putc instead macros and occurs. may Like be 

C program opening is started, for operating responsible is the When system a environment 
the providing files input, standard three files pointers for the them. are These standard and 
the standard and error; the stdout, file stdin, called corresponding output, pointers and are 
are declared and in <stdio.h>. keyboard stdin the to Normally stderr, is and connected 

the operating a system (details returns which and us), of negotiation needn't with concern 
be of the in to or writes pointer used reads file. subsequent 

about the a information contains This pointer, file pointer, that points structure to the called 
buffer, the whether position the a such location of as the the character current buffer, in file, 
end read of need being file whether or written, Users or occurred. is and don't file errors have 
<stdio.h> because definitions to know obtained details, a structure include the from the 
FILE. The by only declaration exemplified for is pointer needed declaration a called file 



*fp; FILE 

*name, *fopen(char char *mode); FILE 

a a pointer a a FILE. fp to is and Notice returns says This fopen that that pointer to FILE, 
defined like typedef. int, is tag; of a (Details it not FILE name, a structure type a with is 
can be 8.5.) implemented on Section UNIX in given the how system fopen are 

a call program in The to is fopen 



fopen(name, mode); fp = 

file. of The name the a first fopen is argument second string the containing character of The 
use mode, the one to character is also a the file. which how indicates string, intends argument 
include ("a"). Some ("r"), modes and append Allowable read ("w"), systems write 
to and the must appended for between binary files; text mode latter, "b" a the be distinguish 
string. 

writing that or possible. file If is for not created does is a exist if appending, opened it 
while the to opening contents discarded, for old an Opening writing for file existing causes be 
not Trying exist may them. appending file does read and to error, preserves a there is that an 
when as have well, other read If don't permission. a like be error causes to of trying you file 
precisely; error, see be more return is fopen will any the (The can error NULL. identified there 
1 at end discussion of of functions Appendix B.) in the Section error-handling 

returns way once to is read needed open. next getc the is thing write file The or next the it a 
a file; file. it needs which file it tell the character pointer from to 



*fp) getc(FILE int 

returns from end the returns by file for of fp; stream getc character the to next referred EOF it 
error. or 

an is output function: putc 

 
*fp; FILE 

*, filecopy(FILE FILE *) void 



standard (argc copy input */ == /* 1) no args; if 

stdout); filecopy(stdin, 

else 

0) > while(--argc 

== ((fp NULL) "r")) if = { fopen(*++argv, 

open can't %s\n, *argv); printf("cat: 

1; return 

{ else } 

stdout); filecopy(fp, 

fclose(fp); 

} 

0; return 

} 



ofp to file */ /* filecopy: file copy ifp 

*ifp, filecopy(FILE FILE *ofp) void 

{ 

c; int 



!= EOF) getc(ifp)) while = ((c 

ofp); putc(c, 

} 

are objects FILE constants, type They however, of file The stdout and stdin pointers are *. 
assign variables, to to them. so is it not possible not 

function The 



*fp) fclose(FILE int 

and the the the between pointer external connection the is it fopen, of inverse breaks file 
Since established file file. another name that by fopen, for freeing pointer the most was 
may number that have files program open of systems operating on limit some have the a 

be stderr redirected and may to 7.1stdout are connected and to screen, stdin but the stdout Section 
described as . or in pipes files 

stdout terms putc, as getc, and follows: of and getchar defined be can putchar in stdin, 

getc(stdin) getchar() #define 

putc((c), stdout) #define putchar(c) 

be the and used. fscanf may These functions formatted For of output or input files, fprintf 
pointer scanf that is file except identical and printf, to specifies the argument first that a are 
to be argument. read or second the the is written; the format file string 



*format, ...) char int *fp, fscanf(FILE 

*format, ...) char int *fp, fprintf(FILE 

to the program way, these in to the cat a we With of preliminaries now out are write position 
programs. design been many for concatenate files. is one convenient that found has If The 
and they interpreted there are as arguments, in order. processed are filenames, command-line 
standard there no If is input arguments, are processed. the 



<stdio.h> #include 



version files, */ cat: 1 concatenate /* 

char *argv[]) main(int argc, 

{ 



 
when good they we a simultaneously, the pointers to needed, idea longer it's free as are file no 
for also another file flushes the There it is on buffer output in did an cat. in - reason fclose 
when collecting automatically file open which putc output. fclose each is for called a is 
needed. (You stdout not are program terminates can close they stdin if and They normally. 
function the library freopen.) can also reassigned be by 

ideal. cat is if the files errors of in trouble can't that treatment The is of be one not The 
concatenated printed end output. the the That at for accessed diagnostic the reason, some is of 
file is if going going to if into be a but the acceptable screen, not might a into or it's output 
via program a pipeline. another 

to situation stream, assigned is To handle better, a stderr, second called output a this 
stderr same stdout on written program in way that Output stdin are. and normally the 
output on standard is redirected. the even screen if the appears 

on to its Let us error cat standard error. the write messages revise 



<stdio.h> #include 



version files, */ cat: 2 concatenate /* 

char *argv[]) main(int argc, 

{ 

*fp; FILE 

*, filecopy(FILE FILE *); void 

name *prog argv[0]; char errors for /* = */ program 



== standard input ) (argc args; copy if 1 no */ /* 

stdout); filecopy(stdin, 

else 

> 0) while (--argc 

== ((fp NULL) "r")) if = { fopen(*++argv, 

can't "%s: open %s\n", fprintf(stderr, 

*argv); prog, 

exit(1); 

{ else } 

stdout); filecopy(fp, 

fclose(fp); 

} 

{ (ferror(stdout)) if 

stdout\n", prog); writing fprintf(stderr, error "%s: 

exit(2); 

} 

exit(0); 

} 

signals errors fprintf in two by First, produced output ways. The the program diagnostic 
screen so instead or stderr, goes way the finds a it down to its pipeline of to disappearing 
so file. if in message, the an We included output this name, argv[0], from program the into 
used error is others, is of an program with source identified. the 

program which terminates the the function exit, Second, uses library program standard 
process of available called is whatever this exit when execution The called. is it argument to 
be success tested this the one, the can failure that or program so of uses by program another 
is value signals well; 0 all non-zero of as one a Conventionally, sub-process. a return that 

 
signal abnormal to situations. exit file, fclose output open calls values for usually each 
any out buffered output. flush 

it exit(expr). the can has that be exit main, Within equivalent is expr return to advantage 
a to be pattern-searching can with program it from called that and functions, other calls found 
in those Chapter 5. like 

on non-zero an The function error returns stream fp. the if occurred ferror 



*fp) ferror(FILE int 

if are a production errors Although occur example, they so rare, up), output do a disk (for fills 
as well. this program check should 

of ferror; non-zero file returns end has it function The analogous is *) feof(FILE to if 
the on specified file. occurred 



*fp) feof(FILE int 

but not in programs, illustrative We have worried about small exit our status any generally 
useful program sensible, status values. should care take to return serious 

Input Line and Output 7.7 

to output that the fgets similar getline routine standard The input an provides library and is 
in that earlier used function we chapters: have 



maxline, int *fp) *fgets(char FILE *line, char 

the the file character from into array newline) reads fgets line input next the (including fp 
with maxline-1 The terminated is line; at characters will line be resulting read. '\0'. most 
getline line; returns returns (Our of fgets on end returns the or it error file NULL. Normally 
means a useful line length, value; is of file.) end more zero which 

to function a contain newline) a output, fputs writes the file: (which not need string a For 



*line, fputs(char FILE *fp) int 

occurs, returns if It non-negative and an EOF otherwise. error 

operate similar and on fgets but stdin to library The puts and gets functions are fputs, 
Confusingly, puts adds deletes stdout. '\n', and and gets terminating it. the 

here about fgets they like fputs, are, functions show To nothing is there that special and 
on from our library copied the system: standard 



chars fgets: at /* iop from most get */ n 

n, int *iop) *fgets(char FILE *s, char 

{ 

c; int register 

*cs; char register 



s; = cs 

= (--n 0 while != getc(iop)) && > EOF) (c 

 
== '\n') c) if = ((*cs++ 

break; 

'\0'; = *cs 

== NULL : && (c s) ? return EOF == s; cs 

} 



iop on file */ /* fputs: string put s 

*s, fputs(char FILE *iop) int 

{ 

c; int 



= *s++) while (c 

iop); putc(c, 

: 0; EOF return ? ferror(iop) 

} 

obvious reason, fputs. the standard and different ferror for specifies For return no values 

from our getline fgets: It is to easy implement 



return getline: length line, /* read */ a 

*line, getline(char int max) int 

{ 

== NULL) stdin) if max, (fgets(line, 

0; return 

else 

strlen(line); return 

} 

where two the they printing line differ. files, 7-6. Exercise to program a Write compare first 

to the take of Modify Exercise of 5 finding a pattern from 7-7. program set its Chapter input 
Should if the the input. are files no files or, file as from arguments, named standard named 
is matching line found? name be when printed a 

new to a print 7-8. files, page, on new starting a Exercise program Write of a set one each 
for a count each file. title a and running page with 

Functions Miscellaneous 7.8 

brief of section synopsis This a of functions. standard The wide a provides library variety is 
Appendix More functions in found the most details and be many can other B. useful. 

Operations String 7.8.1 

strcat, the functions We have strlen, mentioned strcmp, found and string strcpy, already 
n the are and and and <string.h>. following, s In ints. are *'s, char t c in 

strcat(s,t) 

of s end concatenate to t 

strncat(s,t,n) 

of to end s concatenate n of characters t 

strcmp(s,t) 

> or t, s t, return negative, positive for == s s < t zero, 

strncmp(s,t,n) 

n in first characters same as but strcmp only 

strcpy(s,t) 

to s copy t 

strncpy(s,t,n) 

to of t s copy at n most characters 

strlen(s) 

of s return length 



 
strchr(s,c) 

to if not c pointer or NULL return first s, present in 

strrchr(s,c) 

to if not c pointer or NULL return last s, present in 



and Conversion Testing 7.8.2 Class Character 

from In the perform functions and conversions. Several <ctype.h> tests following, character 
unsigned int char int. an c represented an can function that The is be returns or as EOF. 

isalpha(c) 

0 if if alphabetic, non-zero c not is 

isupper(c) 

if case, 0 not non-zero if is c upper 

islower(c) 

if case, 0 not non-zero if is c lower 

isdigit(c) 

0 if if digit, non-zero c not is 

isalnum(c) 

0 if if isdigit(c), non-zero isalpha(c) not or 

isspace(c) 

formfeed, if return, vertical tab c blank, is tab, newline, non-zero 

toupper(c) 

upper case to return converted c 

tolower(c) 

lower case to return converted c 



Ungetc 7.8.3 

library provides we a rather that version ungetch function restricted The of standard the 
is in called it wrote Chapter ungetc. 4; 



c, ungetc(int FILE *fp) int 

EOF onto error. file the either one an Only c, fp, pushes back character returns c and for or 
of ungetc used the be any input may of character per guaranteed is pushback file. with 
or getchar. getc, functions scanf, like 

Execution Command 7.8.4 

the executes command The function contained *s) string s, character the in system(char 
on The s the of strongly local contents resumes then current the of execution program. depend 
systems, system. UNIX the statement As trivial a example, on operating 



system("date"); 

of be the run; the date output. on standard and it causes to program the date prints day time 
executed. integer from system returns the system-dependent the UNIX In status command a 
value the return system, by returned is status exit. the 

Management Storage 7.8.5 

blocks functions and The memory of calloc malloc dynamically. obtain 



n) *malloc(size_t void 

cannot to be if request of a n bytes pointer satisfied. storage, NULL or uninitialized the returns 



n, *calloc(size_t size_t size) void 

an free space of size, or to specified enough of NULL objects a returns n pointer if the for array 
initialized request is to zero. cannot satisfied. be The storage the 

 
object has alignment in proper the question, the pointer The or malloc by returned calloc for 
type, it appropriate as in must cast be into the but 



*ip; int 



calloc(n, sizeof(int)); *) ip (int = 

was space originally malloc the free(p) p, p to call pointed a frees by to obtained where by 
freed, restrictions is on calloc. which ghastly it a space the or no There in are order but is 
malloc to calling or calloc. free not something obtained by error 

A to incorrect use is has of but piece been something It error also it an after typical freed. 
items is loop code a from that this list: frees 



p->next) p NULL; for (p p head; WRONG */ /* != = = 

free(p); 

needed right is before freeing: way to is save whatever The 



= (p p q) { = p head; != NULL; for 

p->next; = q 

free(p); 

} 

shows the allocated implementation of which storage in malloc, a Section allocator 8.7 like 
in freed order. may any be blocks 

Functions Mathematical 7.8.6 

more than of twenty mathematical some declared are here functions There in are <math.h>; 
a used. two returns and the more Each takes arguments one double or double. frequently 

sin(x) 

in radians x sine x, of 

cos(x) 

in radians x cosine x, of 

atan2(y,x) 

y/x, of in radians arctangent 

exp(x) 

ex function exponential 

log(x) 

of logarithm (x>0) (base x e) natural 

log10(x) 

of logarithm (x>0) (base x 10) common 

pow(x,y) 

xy 

sqrt(x) 

of root x (x>0) square 

fabs(x) 

of x absolute value 



Number generation 7.8.7 Random 

rand() computes to a sequence zero pseudo-random range the of The integers function in 
is produce random in which way to RAND_MAX, defined One floating-point <stdlib.h>. 
than than one equal greater but less numbers or zero is to 



/ (RAND_MAX+1.0)) rand() #define ((double) frand() 

likely already floating-point is it (If your provides a numbers, function random for to library 
than properties one.) better this statistical have 

 
portable the for The function rand. sets of rand implementation seed The srand(unsigned) 
appears srand by and Section in the suggested 2.7. standard 

save like to to or Exercise 7-9. isupper can space be save implemented time. Functions 
possibilities. both Explore 

 


UNIX The Interface 8 System - Chapter 

which through of are set calls, in a UNIX The its provides system operating services system 
within the This operating system programs. may user by that effect be functions called 
C the system programs. important from If most describes chapter some use to how of calls 
to helpful, is employ it necessary system for use you be should this UNIX, directly sometimes 
is efficiency, not you maximum calls some that to Even or library. for access if in facility the 
insight a into able glean system, C different operating on C you be should however, to use 
code examples; details programming from vary, these be found will although similar studying 
UNIX Since facilities, cases on C any the ANSI system. this is many in library modeled on 
the may your code as library understanding help well. of 

is divided allocation. into three storage parts: and system, major This input/output, chapter file 
two parts UNIX assume a of familiarity characteristics external modest The with first the 
systems. 

is with input/output Chapter 7 interface concerned across operating uniform an that was 
be of library written standard to in the On systems. the system particular any routines have 
we facilities will next sections the of provided by the describe system. the In host few terms 
how calls parts be system the output, show input library for standard UNIX and can of and the 
them. with implemented 

Descriptors File 8.1 

or and done writing is reading files, output the In all system, operating UNIX input by 
system. devices, are file the because all even keyboard in and files screen, This peripheral 
a between a homogeneous that all communication means single handles program interface 
devices. peripheral and 

must before system you the a your the of file, read In case, most write general and inform you 
If so, write opening also do file a you intent called may file. to on are the it a to going process 
your create right The checks to necessary it or to to its contents. previous discard system be 
have exist? Do and is well, the all file to returns it?) so do access (Does to if you permission 
output small file or input the program non-negative integer Whenever called descriptor. a is a 
file. the the file to descriptor on identify be the instead the done used of to is file (A name file, 
standard to library, of analogous descriptor used the file file the the is pointer handle or by to 
user about maintained the system; MS-DOS.) All an open the file by is program information 
file by the descriptor. refers to file the only 

so involving and Since input screen output special arrangements common, keyboard is and 
make this program, convenient. When a command runs ``shell'') the exist interpreter to (the 
input, open, the called standard descriptors files with file are standard 1, 2, and 0, the three 
reads If a and can do standard it error. and input 1 and output, writes the and 2, program 0 
opening files. about output worrying without 

< I/O from and and with >: to user The can program a of redirect files 



>outfile <infile prog 

 
the the file the case, In default for changes 1 shell and this the to descriptors assignments 0 
messages file to error so named files. descriptor 2 screen, remains the attached can Normally 
all observations cases, a In input there. hold for Similar the output with associated or pipe. go 
does not program. not the program know by assignments file the by changed are shell, The 
input where it its file output comes 0 its for long from input so as where goes, 1 and uses nor 
for output. and 2 

Read Low and - 8.2 Level Write I/O 

from write which C calls, accessed programs system and Input read the uses output and are 
a For first file the is descriptor. both, two through and read called functions write. argument 
is character to array second where to go or the in The a argument program is your to data 
to number number be the bytes transferred. is from. come is argument third The the of 



int char *buf, n); int n_read read(int = fd, 

int char *buf, n); int n_written write(int = fd, 

number a of On the the call count of returns bytes of transferred. bytes number reading, Each 
implies less end of bytes number may than the be of A value return requested. zero returned 
writing, indicates the of -1 file, some For error the an is and of number return sort. value 
an error requested. has occurred number this the to if bytes isn't written; equal 

one bytes call. 1, of Any or in be values can common number read are The written most 
or (``unbuffered''), number 4096 a 1024 that and means which a at character one time like 
be a Larger more device. will efficient peripheral to corresponds size block physical a on sizes 
will calls made. fewer be system because 

to together, copy the facts Putting a program can its we to these write output, its simple input 
copy file Chapter will program equivalent of copying program This written 1. for anything the 
or the be file any to anything, input and to output redirected can device. since 



"syscalls.h" #include 



to input */ /* output copy main() 

{ 

buf[BUFSIZ]; char 

n; int 



BUFSIZ)) ((n > buf, while = 0) read(0, 

n); buf, write(1, 

0; return 

} 

syscalls.h function calls called file We have prototypes for a the into system so collected 
not of This standard, chapter. is however. this can we the in it include programs name 

for is the a size in parameter also defined BUFSIZ local its is value syscalls.h; good The 
will is smaller not If BUFSIZ, of a number some a system. size the of file multiple return read 
will next read return to that zero. call to bytes write; by written be the after 

higher-level to routines used construct read is see how instructive like write be can and to It 
unbuffered For version does that getchar, putchar, example, here getchar is of a input, etc. 
character reading standard by a at input the time. one 



 
"syscalls.h" #include 



character single */ getchar: input unbuffered /* 

getchar(void) int 

{ 

c; char 



&c, c : == (read(0, (unsigned char) return 1) ? EOF; 1) 

} 

pointer. a Casting the be c needs character because char char, unsigned must read in c a to 
of statement sign problem return eliminates extension. any 

characters of one hands the input second getchar does version at big and chunks, in out The 
time. a 



"syscalls.h" #include 



version */ buffered /* simple getchar: 

getchar(void) int 

{ 

buf[BUFSIZ]; char static 

*bufp char = buf; static 

n int = 0; static 



buffer (n 0) if empty is { == */ /* 

sizeof buf); buf, n read(0, = 

buf; = bufp 

} 

char) (--n 0) return : *bufp++ ? >= EOF; (unsigned 

} 

would of compiled it included, If these getchar were <stdio.h> to with be be versions 
#undef the macro. name getchar a case as implemented in necessary it to is 

Creat, Open, Close, Unlink 8.3 

files and must in you open order error, than Other input, standard default the output explicitly 
and two for creat calls open [sic]. system read to There them. write or are this, 

returning like a that of discussed is the fopen rather file Chapter except 7, in instead open 
int. a open occurs. returns pointer, is an descriptor, any file if it which error returns just -1 



<fcntl.h> #include 



fd; int 

flags, int perms); open(char int *name, int 



open(name, = flags, perms); fd 

The the character filename. the As with name argument containing is string a second fopen, 
is an to are is argument, how file that main int the flags, specifies values be the opened; 

O_RDONLY 

reading only open for 

O_WRONLY 

writing only open for 

O_RDWR 

and writing reading open both for 



 
are defined <sys/file.h> in <fcntl.h> in System and systems, on These V constants UNIX 
(BSD) versions. on Berkeley 

file existing reading, open for an To 



open(name, O_RDONLY,0); fd = 

will is uses we that The perms always zero open for of the discuss. argument 

is to exist. open system a error call is creat does to an that not It file to provided The try 
re-write new old to create files, ones. or 



*name, creat(char int perms); int 



creat(name, perms); fd = 

file was -1 able not. to descriptor If a the file, if file the and returns create exists, already if it 
not it an contents; is length, will to zero truncate error discarding previous its thereby it creat 
that file exists. creat already a to 

by does the the specified exist, the not already file perms creates with it creat permissions If 
the UNIX associated file system, information are permission of there argument. nine In bits 
of read, for write a for owner's file, the the and with control file access that execute the owner 
specifying all octal for convenient group, and others. Thus is a number three-digit the for 
permission specifies write permissions. For and 0775 the owner, for read, execute example, 
and read group everyone else. and permission execute for the and 

one is file cp, copies version illustrate, a simplified here to the program UNIX of which To 
to copies be the argument file, Our only one version a does permit not it second another. 
copying instead of them. directory, and invents it permissions 



<stdio.h> #include 

<fcntl.h> #include 

"syscalls.h" #include 

owner, PERMS /* #define others group, RW 0666 */ for 



*, ...); void error(char 



to f1 */ cp: f2 copy /* 

char *argv[]) main(int argc, 

{ 

f2, n; int f1, 

buf[BUFSIZ]; char 



!= 3) if (argc 

from to"); error("Usage: cp 

0)) ((f1 == O_RDONLY, if = -1) open(argv[1], 

open can't %s", argv[1]); error("cp: 

PERMS)) creat(argv[2], -1) ((f2 == = if 

mode %03o", %s, error("cp: create can't 

PERMS); argv[2], 

BUFSIZ)) ((n > buf, while = 0) read(f1, 

!= n) n) if buf, (write(f2, 

file on argv[2]); write %s", error error("cp: 

0; return 

} 

 
stat the permissions the With This program output file 0666. with of fixed system creates 
of Section an the in call, determine mode we thus 8.6, and described can give existing the file 
to mode the copy. same 

printf. function variable like much Notice that error is lists called argument with The the 
error illustrates The how to family. another printf the use implementation member of of 
function vprintf is is like list except argument variable printf standard that library the 
a single macro. argument that va_start been the calling has replaced initialized by by 
fprintf vfprintf and match Similarly, and sprintf. vsprintf 



<stdio.h> #include 

<stdarg.h> #include 



die message and */ /* error: an print error 

*fmt, ...) void error(char 

{ 

args; va_list 



fmt); va_start(args, 

"); "error: fprintf(stderr, 

args); fmt, vprintf(stderr, 

"\n"); fprintf(stderr, 

va_end(args); 

exit(1); 

} 

program limit may files a 20) is (often about a open the of number on that There 
any files must that Accordingly, process many simultaneously. program to be intends 
re-use breaks the descriptors. to close(int fd) prepared file function connection The 
the descriptor file other file between file, frees an with and use a open some descriptor and for 
buffer to to there no the it fclose in corresponds flush. library that except standard is file; 
all return main open the closes files. from of Termination exit via program a or program 

the removes file The function name *name) system. It file the from unlink(char 
library standard remove. to function the corresponds 

and the 7 open, write, Exercise 8-1. program cat read, from using Chapter close Rewrite 
their determine the library of experiments to instead standard Perform relative equivalents. 
the of two versions. speeds 

Access Random - Lseek 8.4 

position are in place a each and normally sequential: output the or takes write read at Input 
file the can any after file necessary, a one. written previous or right When in be however, read 
a a move file to in without way order. arbitrary lseek call system The provides around 
writing or any data: reading 



offset, long origin); lseek(int int fd, long 

fd position to to current sets whose is the taken in is the file relative offset, descriptor which 
specified by position. origin. Subsequent that or at begin reading the writing location will 
be or the 2 can offset from from beginning, is to origin 1, be that 0, specify measured to 
respectively. or For file position, the of file the to from append current end a example, the to 
end in before seek the shell, redirection the UNIX >> writing: "a" fopen), for or to (the 



2); 0L, lseek(fd, 

 
the to (``rewind''), get beginning back To 



0); 0L, lseek(fd, 

written could also just if lseek argument; 0 it (long) is or the Notice 0 0L properly as be as 
declared. 

at to of treat lseek, less access. price slower like files With possible it or is more the arrays, 
place number from in bytes arbitrary a of example, For reads function following the any any 
or It the file. on -1 number returns error. read, 



"syscalls.h" #include 



position read pos from /*get: n */ bytes 

int char *buf, n) int get(int long fd, pos, 

{ 

to (lseek(fd, get pos */ pos, >= 0) 0) /* if 

buf, n); return read(fd, 

else 

-1; return 

} 

if a in long file, that from or return -1 new lseek value the position The gives error an the is 
first library to the that occurs. The function fseek except is lseek similar argument standard 
if and return is a is * error occurred. an the non-zero FILE 

and of Fopen Getc 8.5 Example An - implementation 

implementation pieces by of together an the fit us Let of some how illustrate these showing 
and getc. fopen standard routines library 

than in described rather pointers Recall that the standard file library by are file files 
pieces to that of structure several information a A descriptors. a is pointer file pointer contains 
count a read buffer, large so a chunks; the a can pointer file: file be about the the of in to 
in left the next position buffer; of in the characters buffer; pointer the to a character number 
error file mode, status, etc. descriptor; flags and describing read/write the 

be is <stdio.h>, included in must (by contained data The a describes that structure file which 
It source from library. input/output #include) in file that standard uses the routines is any 
typical functions the a from also included in that excerpt library. following In <stdio.h>, by 
an intended underscore library with only that for use are so functions the of by begin names 
user's likely program. all less they names a collide used to is are with by This in convention 
routines. library standard 



0 NULL #define 

(-1) EOF #define 

1024 BUFSIZ #define 

open OPEN_MAX /* #define once at max 20 */ #files 



_iobuf { typedef struct 

left */ characters int /* cnt; 

character next */ *ptr; position /* char 

of location */ *base; buffer /* char 

file flag; access of int /* */ mode 

descriptor */ file int /* fd; 

FILE; } 

 
_iob[OPEN_MAX]; FILE extern 



(&_iob[0]) stdin #define 

(&_iob[1]) stdout #define 

(&_iob[2]) stderr #define 



{ _flags enum 

reading open for */ _READ = /* 01, file 

writing open for */ _WRITE = /* 02, file 

is = unbuffered file _UNBUF 04, */ /* 

this = on file */ 010, EOF /* has occurred _EOF 

on = /* _ERR file this error 020 */ occurred 

}; 



*); _fillbuf(FILE int 

FILE *); int _flushbuf(int, 



_EOF) & 0) feof(p) != ((p)->flag #define 

_ERR) & 0) ferror(p) != ((p)->flag #define 

((p)->fd) fileno(p) #define 



0 \ >= #define (--(p)->cnt getc(p) 

: _fillbuf(p)) *(p)->ptr++ ? char) (unsigned 

0 \ >= #define (--(p)->cnt putc(x,p) 

: _flushbuf((x),p)) (x) ? = *(p)->ptr++ 



getc(stdin) getchar() #define 

putc((x), stdout) #define putcher(x) 

pointer, decrements count, The getc advances normally returns the and the the macro 
count a with the If character. (Recall long #define backslash.) is a continued goes that 
the the _fillbuf negative, however, to calls re-initialize the buffer, function replenish getc 
and returned unsigned, a contents, characters are structure return The which character. 
will characters positive. that be all ensures 

putc we the to included of show have we Although any discuss not will details, definition 
when in its a _flushbuf same it much the operates buffer as calling getc, way function that 
and have the and status macros full. also included We file accessing error the for end-of-file is 
descriptor. 

getting Most is the fopen with file of function The be now can fopen written. concerned 
the at proper bits indicate place, and the right positioned state. setting flag the and to opened 
by allocate _fillbuf read. not fopen this done buffer is any file does space; first when is the 



<fcntl.h> #include 

"syscalls.h" #include 

owner, PERMS /* #define others group, RW 0666 */ for 



*name, *fopen(char char *mode) FILE 

{ 

fd; int 

*fp; FILE 



!= *mode != && (*mode 'w' && if 'r' != 'a') *mode 

NULL; return 

_iob (fp _iob; for OPEN_MAX; + fp = fp++) < 

_WRITE)) ((fp->flag == | if & 0) (_READ 

slot */ free break; found /* 

free (fp no slots */ >= + _iob OPEN_MAX) /* if 

NULL; return 

 


== 'w') if (*mode 

creat(name, PERMS); fd = 

'a') { == else (*mode if 

0)) ((fd == O_WRONLY, if = -1) open(name, 

creat(name, PERMS); fd = 

2); 0L, lseek(fd, 

else } 

open(name, = O_RDONLY, 0); fd 

name couldn't access */ if (fd -1) == /* 

NULL; return 

fd; = fp->fd 

0; = fp->cnt 

NULL; = fp->base 

: ? _READ _WRITE; fp->flag = == (*mode 'r') 

fp; return 

} 

of all access the the possibilities standard, of version This not does fopen of handle mode 
not would In does fopen though adding not take our much particular, code. recognize them 
nor that on the meaningless systems, ``+'' is ``b'' the access, binary signals that since UNIX 
and writing. reading that both permits 

zero, for a a first a of forces call count particular The getc call finds to file which of 
returns is for EOF open it immediately. not If _fillbuf. the that finds _fillbuf file reading, 
is allocate buffer Otherwise, it (if to be buffered). to a reading tries 

and is pointers, sets count calls the established, _fillbuf buffer and to it, fill read the Once 
will the calls find Subsequent _fillbuf a buffer. the returns beginning the at character of to 
allocated. buffer 



"syscalls.h" #include 



input _fillbuf: buffer fill /* allocate */ and 

*fp) _fillbuf(FILE int 

{ 

bufsize; int 



!= _READ) if ((fp->flag&(_READ|_EOF_ERR)) 

EOF; return 

: ? 1 BUFSIZ; bufsize = & (fp->flag _UNBUF) 

yet no buffer */ if (fp->base NULL) == /* 

malloc(bufsize)) ((fp->base == *) if = NULL) (char 

get can't */ EOF; buffer /* return 

fp->base; = fp->ptr 

read(fp->fd, = fp->ptr, bufsize); fp->cnt 

< (--fp->cnt 0) { if 

== -1) if (fp->cnt 

_EOF; |= fp->flag 

else 

_ERR; |= fp->flag 

0; = fp->cnt 

EOF; return 

} 

char) *fp->ptr++; return (unsigned 

} 

must everything The be started. _iob defined gets only The is end loose remaining how array 
stdout stdin, stderr: initialized and for and 



stderr stdin, stdout, */ FILE _iob[OPEN_MAX] { = /* 

 
_READ, 0, 0, 0 }, (char 0, *) (char *) { 

_WRITE, 0, 0, 1 }, (char 0, *) (char *) { 

| 0, *) { 0, 0, *) 2 } _UNBUF, (char _WRITE, (char 

}; 

to part stdout of initialization that to read, is stdin the The flag of shows the structure be is 
written to be unbuffered. be written, stderr and is 

of and with Exercise 8-2. fields fopen bit operations. explicit _fillbuf instead Rewrite 
execution speed. and Compare size code 

and _flushbuf, fflush, fclose. Exercise 8-3. and Design write 

library function standard Exercise The 8-4. 



offset, long origin) fseek(FILE int *fp, int 

a that and fp identical pointer value descriptor return instead is is except to file lseek a file of 
fseek Write sure coordinates Make your properly fseek. an is a not status, int position. that 
of the functions the library. buffering for done the other with 

- Example Listing Directories 8.6 

kind of information file system determining is - for interaction A sometimes different called 
UNIX A such command program the ls directory-listing a about it what not file, contains. as 
optionally, - other a and, the an it prints example information, of in files names directory, is 
dir and on. such as The permissions, is analogous. command so MS-DOS sizes, 

ls just a to filenames. But directory the is only is it a Since read UNIX is retrieve file, need 
about a a On use necessary access information call its system as to to size. file, other such 
access system filenames; MS- a other needed to may case call the systems, be on this even is 
a provide the relatively to in system- access for DOS want we What instance. is information 
may way, though independent highly be the even system-dependent. implementation 

called some fsize. of illustrate We writing program this special of a will by form fsize a is 
list. of of all that its files one the commandline files ls sizes prints in the named If argument 
no to If arguments directory. are at that a is itself applies fsize directory, recursively there 
current directory. the all, processes it 

system with structure. that begin Let of file short a a is us review file A UNIX directory 
The indication they ``location'' where located. is of a contains and filenames of list some are 
is another where for file the index table called into all list.'' inode The ``inode a an 
consists is directory of A generally only kept. about information its except file the name entry 
an items, inode and two the number. filename 

all and versions the on of the precise contents format of directory not are a same Regrettably, 
pieces we to parts. So the task two divide the will isolate system. the non-portable try into to 
readdir, defines Dirent opendir, routines The outer a structure three called and a and level 
provide system-independent directory access to a name in number the closedir and to inode 
implement write these show to this We fsize with will on Then will we interface. how entry. 
UNIX; as and variants 7 V are Version that systems directory same the use structure System 
exercises. as left 

 
of contains the length maximum The Dirent the inode The number name. and a structure 
is opendir returns which component system-dependent value. filename NAME_MAX, a a is 
readdir to is and which by closedir. FILE, to pointer DIR, called structure a analogous used 
called a file dirent.h. This information collected is into 



filename NAME_MAX component; longest #define 14 */ /* 

*/ system-dependent /* 



directory struct entry portable typedef { */ /* 

number */ inode long /* ino; 

'\0' name[NAME_MAX+1]; terminator + char /* */ name 

Dirent; } 



no struct /* typedef etc. buffering, minimal { */ DIR: 

directory for the */ int fd; file /* descriptor 

directory the */ d; entry /* Dirent 

DIR; } 



*dirname); *opendir(char DIR 

*dfd); *readdir(DIR Dirent 

*dfd); closedir(DIR void 

of stat the that call The and all a inode takes the system filename for information returns in 
an or if file, That error. there -1 is, is 



*name; char 

stbuf; stat struct 

stat *); struct int *, stat(char 



&stbuf); stat(name, 

structure stbuf for The name. fills the with the file inode the information describing structure 
typically stat in the value <sys/stat.h>, by like this: looks is and returned 



stat returned by */ struct stat inode /* information 

{ 

of device */ st_dev; inode /* dev_t 

number */ inode ino_t /* st_ino; 

bits */ mode short /* st_mode; 

file links to */ short st_nlink; number /* of 

user owners */ st_uid; id /* short 

group owners */ st_gid; id /* short 

special for */ st_rdev; files /* dev_t 

in st_size; characters size off_t /* */ file 

last time */ st_atime; accessed /* time_t 

last time */ st_mtime; modified /* time_t 

originally time */ st_ctime; created /* time_t 

}; 

dev_t the The and fields. like ino_t comment of Most explained are values these by types 
included must be too. are defined <sys/types.h>, in which 

definitions flags file. are the flag also describing st_mode The set a contains entry of The 
deals need the included in part we file type: with only that <sys/types.h>; 



of S_IFMT file: type #define 0160000 */ /* 

directory */ /* #define 0040000 S_IFDIR 

character /* */ S_IFCHR special 0020000 #define 

block /* */ S_IFBLK special 0060000 #define 

regular */ /* #define 0010000 S_IFREG 

*/ ... /* 

 
stat ready indicates mode from the we to write are that fsize. the If program obtained Now 
at not printed the a is the If hand a then is is file directly. and size name a be can directory, 
file we at turn then directory, that one to may have it however, process in a directory time; 
process the recursive. sub-directories, is so contain 

routine deals function with command-line the it to argument arguments; The hands main each 
fsize. 



<stdio.h> #include 

<string.h> #include 

"syscalls.h" #include 

write read and */ #include <fcntl.h> flags /* for 

/* <sys/types.h> typedefs */ #include 

by <sys/stat.h> stat returned #include /* */ structure 

"dirent.h" #include 



*) fsize(char void 



file print name */ /* 

char **argv) main(int argc, 

{ 

directory default: current */ if (argc 1) == /* 

fsize("."); 

else 

> 0) while (--argc 

fsize(*++argv); 

0; return 

} 

the prints file first fsize The the If size however, the directory, function of fsize is file. a 
how handle the are to calls in Note the and all S_IFMT dirwalk files S_IFDIR flag it. names 
precedence a matters, of Parenthesization the & directory. to used file the if decide is because 
of ==. that is than lower 



stat *); struct int *, stat(char 

(*fcn)(char *)); void void *, dirwalk(char 



"name" of file */ /* fsize: the print name 

*name) fsize(char void 

{ 

stbuf; stat struct 



-1) { == if &stbuf) (stat(name, 

%s\n", name); access fprintf(stderr, can't "fsize: 

return; 

== S_IFDIR) S_IFMT) if & ((stbuf.st_mode 

fsize); dirwalk(name, 

stbuf.st_size, name); printf("%8ld %s\n", 

} 

function is to It dirwalk The that a general a a in function routine directory. each applies file 
then loops closes function each, files the through the directory, the it, the calling in on opens 
returns. Since call fsize calls functions on two the dirwalk directory each and directory, 
recursively. other each 



1024 MAX_PATH #define 



files dirwalk: fcn /* dir in to apply */ all 

(*fcn)(char *)) void void *dir, dirwalk(char 

 
name[MAX_PATH]; char 

*dp; Dirent 

*dfd; DIR 



== opendir(dir)) { ((dfd NULL) = if 

%s\n", dir); open fprintf(stderr, can't "dirwalk: 

return; 

} 

!= readdir(dfd)) { ((dp NULL) = while 

".") (strcmp(dp->name, == 0 if 

"..")) strcmp(dp->name, || 

and self */ /* parent skip continue; 

%s %s long\n", "dirwalk: too name fprintf(stderr, 

dp->name); dir, 

{ else 

dir, dp->name); sprintf(name, "%s/%s", 

(*fcn)(name); 

} 

} 

closedir(dfd); 

} 

the readdir next are to Each to for a when returns NULL call pointer there file, information or 
its entries called parent, itself, and ".."; for files no always directory Each left. contains ".", 
program must skipped, these loop will or be forever. the 

formatted. is how The of are next independent to Down the level, last this code directories 
specific present readdir, a for step is minimal versions closedir of and opendir, system. to 
use and UNIX the V they directory System following The Version for are routines 7 systems; 
like which looks this: information in header the <sys/dir.h>, 



DIRSIZ #ifndef 

#endif 

directory /* */ direct entry { struct 

number */ inode ino_t /* d_ino; 

not d_name[DIRSIZ]; long char '\0' have name /* */ does 

}; 

of the complicated system permit more longer a have much Some names versions and 
structure. directory 

into is the be ino_t The describes index typedef happens a It type that to inode the list. 
of the information not sort use short systems we on to but is this regularly, the unsigned 
different program; system, A a embed different a might is it typedef in be better. so on the 
in is found <sys/types.h>. complete set ``system'' of types 

the directory, system (this by the opens verifies that the call is directory a file time opendir 
allocates it a a to descriptor), directory applies which fstat, except stat like is that file 
records and the information: structure, 



stat *); struct int fd, fstat(int 



calls for readdir */ /* opendir: a open directory 

*dirname) *opendir(char DIR 

{ 

fd; int 

stbuf; stat struct 

 
*dp; DIR 

0)) ((fd == O_RDONLY, if = -1 open(dirname, 
&stbuf) fstat(fd, == -1 || 
!= S_IFDIR S_IFMT) || & (stbuf.st_mode 
malloc(sizeof(DIR))) (dp == *) || = NULL) (DIR 

NULL; return 
fd; = dp->fd 
dp; return 

} 
the and frees space: closedir closes directory the file 

by closedir: opendir opened /* close */ directory 
*dp) closedir(DIR void 
{ 

{ (dp) if 
close(dp->fd); 
free(dp); 

} 
} 
not read currently directory is each readdir to read uses in entry. a If directory slot Finally, 
position file is zero, this removed), (because has been a skipped. inode is number the and use 
pointer number to structure a are the and name inode that in static a placed and Otherwise, 
to the one. user. Each previous overwrites the from call is the returned information 

directory local */ <sys/dir.h> structure /* #include 

in readdir: sequence entries /* read */ directory 
*dp) *readdir(DIR Dirent 
{ 

directory direct structure local struct dirbuf; */ /* 
portable Dirent structure return: static d; */ /* 

&dirbuf, sizeof(dirbuf)) *) while (char (read(dp->fd, 
{ sizeof(dirbuf)) == 
not (dirbuf.d_ino 0) if use in /* == */ slot 

continue; 
dirbuf.d_ino; = d.ino 
DIRSIZ); dirbuf.d_name, strncpy(d.name, 
ensure /* */ = termination '\0'; d.name[DIRSIZ] 
&d; return 

} 
NULL; return 
} 
fsize program important is rather of it couple a specialized, Although does the illustrate 
many programs is are not that programs''; information use ``system ideas. they First, merely 
include such those standard and programs, representation it the headers programs that only information For that by maintained appear system. crucial in is operating the ofthe headers, 
embedding the care declarations in with The that is themselves. instead second of observation 
relatively to system-dependent itself is it is create an that interface objects to system- possible 
library The of independent. good are the functions examples. standard 

the the the in contained Exercise 8-5. fsize program information to other print inode Modify 
entry. 

Storage Allocator A 8.7 - Example 
that we stack-oriented version The In Chapter presented a allocator. vary storage limited we 5, 
order; is malloc occur any to now unrestricted. Calls write calls and may free malloc in will 

 
will a fixed-size Rather than array, from space from request compiled-in malloc allocating 
request as in also may the operating needed. Since program other the activities space system 
Thus allocator, manages contiguous. be without calling the space not that may malloc its this 
free a list a pointer to kept a as Each the contains storage free block is next size, of blocks. 
address, space and of storage blocks and itself. The the the kept order in are increasing block, 
to block the points last (highest first. address) 



is is found. a block free a made, the request This is until scanned list big-enough When 
the with which smallest fit,'' for block ``best is algorithm by fit,'' ``first called contrast looks 
the the size the satisfy that block exactly If unlinked request. is will the from requested is it 
block user. If is the proper to and the too amount it and list big, returned is split, the is 
free user list. found, the returned remains the the block while big-enough to residue is If on no 
free is system the into another large obtained by linked the and operating list. chunk 

place of the the also find being insert block the free Freeing search causes to a list, to proper 
to freed is either is coalesced block it being free with on If freed. block the it side, adjacent a 
single bigger the block, so Determining does fragmented. too storage into not a become 
easy because address. the free decreasing is of order list adjacency maintained is in 

storage we returned ensure the in problem, alluded to which by 5, to is Chapter that One 
Although that stored machines be it. vary, will is malloc the for properly aligned objects in 
type a stored most each the a be at most restrictive for is machine if there type: can restrictive 
restrictive also. machines, type some most is On address, particular may types other all be the 
or double; long int a on suffices. others, 

of to a the of next contains the free size the a block in chain, A block block, the record pointer 
called control the the at is ``header.'' information then and itself; space free the the beginning 
header of size, is header the aligned the simplify To are blocks all alignment, multiples and 
and achieved contains structure header properly. This by a desired union the that an is 
the most long: restrictive alignment a which made arbitrarily type, instance we of have 



to long /* typedef boundary long for Align; */ alignment 



block /* */ header header { union 

 
{ struct 

free header on list */ *ptr; next /* block if union 

this size; block of unsigned /* */ size 

s; } 

of x; blocks alignment Align /* */ force 

}; 



header Header; typedef union 

on is a to aligned it Align never used; field worst-case forces header each just be The 
boundary. 

number is to of up proper header-sized rounded malloc, In in size requested the characters the 
unit, that for is block units; contains more be and will itself, the allocated this the one header 
malloc in points pointer by field value the size recorded at the The header. of returned the 
can not do but space, the itself. user the space at the free header requested, anything The with 
to allocated list be the likely scrambled. space anything if of outside written is the is 



be blocks malloc contiguous by not - controlled size The because necessary is field the need 
sizes is possible it pointer by to not arithmetic. compute 

call get it started. at If is the variable first NULL, used base is as The freep malloc, of is to 
zero, is to created; a block In points itself. of it then list degenerate one free contains and size 
block is size then case, for at adequate begins a searched. any list the search free The of free 
the where found; keep helps the point the last strategy block this was list (freep) 
the is this found, If is the in way returned the homogeneous. block a end too-big tail user; to 
adjusted. original In to the header have size only pointer needs the of to returned all its cases, 
beyond to the begins unit space user the free points header. the which block, within one the 



to Header /* static started get empty base; */ list 

free Header of list */ *freep NULL; = /* start static 



allocator */ storage /* general-purpose malloc: 

nbytes) *malloc(unsigned void 

{ 

*prevp; *p, Header 

*moreroce(unsigned); Header 

nunits; unsigned 



(nbytes+sizeof(Header)-1)/sizeof(header) = + 1; nunits 

free == { if ((prevp /* freep) yet */ list NULL) no = 

prevptr = &base; = = freeptr base.s.ptr 

0; = base.s.size 

} 

 
= = p->s.ptr) ; (p p, p for prevp->s.ptr; = { prevp 

enough /* big */ if (p->s.size nunits) >= { 

/* nunits) */ (p->s.size exactly == if 

p->s.ptr; = prevp->s.ptr 

tail allocate */ { end /* else 

nunits; -= p->s.size 

p->s.size; += p 

nunits; = p->s.size 

} 

prevp; = freep 

*)(p+1); (void return 

} 

around (p freep) if list free /* == */ wrapped 

== NULL) morecore(nunits)) if = ((p 

left */ none return /* NULL; 

} 

} 

it obtains system. how of The function storage from details the The operating does morecore 
a system the is memory this vary to system. for Since system asking comparatively from 
so that call morecore every malloc, requests on operation. expensive to want don't we do to 
setting units; the as After block least this larger NALLOC size be up chopped will needed. al 
inserts by calling additional morecore the arena field, the into free. memory 

sbrk call returns bytes storage. a UNIX sbrk(n) returns system -1 to more n pointer of The 
design. even must though there been cast -1 be a NULL if space, was have no could The better 
make so the value. casts be char it can * function with return the compared Again, to 
to the still details of is representation There machines. pointer relatively on immune different 
by pointers different one assumption, blocks that can be sbrk to returned however, 
This which permits not compared. the standard, meaningfully is by pointer guaranteed 
within an among array. Thus only version portable is this comparisons of only malloc 
comparison for is pointer machines which meaningful. general 



request #units to */ #define NALLOC /* 1024 minimum 



more morecore: memory for /* ask */ system 

*morecore(unsigned nu) static Header 

{ 

*sbrk(int); *cp, char 

*up; Header 



< NALLOC) if (nu 

NALLOC; = nu 

== at all *) (cp no space if (char /* */ -1) 

(Header = *) cp; up 

nu; = up->s.size 

*)(up+1)); free((void 

freep; return 

freep, thing. the It itself list, to for place starting scans free last is free the the looking at 
two is either the the list. block. of This blocks In at the insert or free any end between existing 
blocks adjacent neighbor, are either adjacent combined. to if case, freed being block the is the 
the pointing right sizes the and correct. to only The the keeping are troubles pointers things 



list in free */ /* free: block put ap 

*ap) free(void void 

{ 

 
*p; *bp, Header 



(Header block header - = point to bp *)ap /* */ 1; 

= freep; p->s.ptr) !(bp > = && p p->s.ptr); p for bp (p < 

>= bp < && (p p || if p->s.ptr > p->s.ptr)) (bp 

of /* end arena */ freed at block start or break; 



to == { if (bp /* bp->size nbr */ upper p->s.ptr) join + 

p->s.ptr->s.size; += bp->s.size 

p->s.ptr->s.ptr; = bp->s.ptr 

else } 

p->s.ptr; = bp->s.ptr 

to == { if (p /* p->size nbr */ lower bp) join + 

bp->s.size; += p->s.size 

bp->s.ptr; = p->s.ptr 

else } 

bp; = p->s.ptr 

p; = freep 

} 

above storage code illustrates how allocation intrinsically is machine-dependent, the Although 
of confined very the a part program. to machine the controlled be can dependencies and small 
of typedef appropriate and union an alignment supplies sbrk handles The (given use that 
arrange that a pointer conversions with made cope even are pointer). explicit, Casts and 
interface. related to though system here are badly-designed Even details storage the 
situations the other as well. general is approach applicable to allocation, 

The standard of library function objects returns n to calloc(n,size) Exercise a 8-6. pointer 
or the Write malloc calling size size, storage initialized by to calloc, zero. by with 
it. modifying 

its a request Exercise 8-7. without accepts free believes plausibility; size checking malloc 
valid it size they block that free a asked routines is these the to so field. contains Improve 
error checking. with make pains more 

of will arbitrary n any p characters free 8-8. Exercise bfree(p,n) routine a Write that block 
user by a malloc the using or add static bfree, and into maintained free By list free. can a 
any list at time. external array the to free 

 


- A Reference Manual Appendix 

Introduction A.1 

on the the ANSI to This manual C language submitted specified draft by 31 describes 
for Systems - as 1988, for Information October, approval Standard programming ``American 
X3.159-1989.'' The the manual is not interpretation standard, proposed an Language of C, the 
to to a the it guide language. make itself, standard been has care although taken reliable 

which the of in outline standard, turn broad the For document this part, most follows the 
in this the detail. although differs Except book, that follows edition first the of of organization 
tokens few the lexical the for renaming productions, and of not definitions formalizing or a 
that the is of proper to the language preprocessor, the here given grammar the for equivalent 
standard. 

this and smaller is. in as Most written this Throughout is material commentary manual, indented type, 
language ANSI differs defined C the by Standard these often in ways highlight comments which from 
edition of compilers. this book, various from in introduced or the refinements first subsequently 

Conventions Lexical A.2 

translated of in files. is more program one or consists several units in stored translation It A 
are do low-level in which first phases phases, described The lexical Par.A.12. 
with introduced the transformations, carry lines directives # character, the by beginning out 
macro of Par.A.12 and perform the preprocessing and definition When is expansion. 
sequence the a of tokens. program been has reduced to complete, 

Tokens A.2.1 

string of identifiers, There are keywords, classes operators, and literals, tokens: constants, six 
Blanks, and comments and separators. newlines, formfeeds other horizontal tabs, as vertical 
(collectively, they separate space'') below except as described ``white ignored tokens. are 
space identifiers, keywords, required white otherwise adjacent Some is separate and to 
constants. 

character, been token separated the to the next is a into If has input up stream tokens the given 
a could constitute token. longest string characters of that 

Comments A.2.2 

the a which The characters terminates introduce */. Comments characters comment, with /* 
nest, and literals. they do character occur or string not do within not a 

Identifiers A.2.3 

a a letter; character be letters identifier sequence of is the digits. first The and must An 
Identifiers as lower different. are underscore _ a letter. letters Upper case and may counts 
are and least characters 31 have any for internal first identifiers, the at significant; length, 

 
significant. implementations take some identifiers Internal more may include characters 
names and (Par.A.11.2). all other linkage that external have names preprocessor do macro not 
external linkage the are more as implementations few as restricted: Identifiers may with make 
case may ignore distinctions. first six significant, characters and 

Keywords A.2.4 

be are as not may The following reserved for and the keywords, use used identifiers 
otherwise: 



int struct auto double 

long switch break else 

register typedef case enum 

return union char extern 

short unsigned const float 

signed void continue for 

sizeof volatile default goto 

static while do if 

and words fortran asm. Some implementations reserve also the 

and signed, with enum standard; The keywords and volatile ANSI are the new void const, 
entry, the formerly no since are in use; edition, used, first never new but is reserved common but 
reserved. longer 

Constants A.2.5 

the has type; basic data discusses types: a are There constants. of kinds several Each Par.A.4.2 

constant: 
integer-constant 
character-constant 
floating-constant 
enumeration-constant 

Constants Integer A.2.5.1 

octal a begins sequence integer taken 0 it with to of An of constant is consisting digits if be 
A otherwise. sequence 8 9. do zero), Octal constants decimal of contain digits the not or (digit 
integer. 0x The be hexadecimal (digit preceded or 0X by hexadecimal is to taken zero) a digits 
a or 15. A through through or 10 values f digits F include with 

letter suffixed by specify is unsigned. may it be or It to integer An U, constant may that the u 
is by L it that also be the letter specify l to or long. suffixed 

Par.A.4 an for and (See depends type integer constant of a its value form, on suffix. The 
of is in unsuffixed of has its types which the and discussion it types). it If decimal, these first 
unsuffixed, unsigned If octal int. is or long can value long int, represented: be int, it 
has the int, first possible long these int, unsigned of hexadecimal, types: it int, 
U, If then If int. unsigned by or is long it unsigned long suffixed int. unsigned u int, 
If or constant L, is unsigned suffixed integer is long then it l suffixed int, by long an int. 
unsigned long. is by it UL, 

edition, the goes first the The elaboration types of beyond integer considerably constants which of 
U constants be merely caused long. integer are new. suffixes to The large 

 
Constants Character A.2.5.2 

quotes is as enclosed single of character a sequence constant in or characters more one in A 
value of of is numeric constant The a character value the only character one with the 'x'. 
the machine's multi-character character set a execution of value at character time. in The 
implementation-defined. is constant 

represent character in them, newlines; to and or constants Character the contain not do ' order 
sequences other the certain be may following characters, used: escape 

newline 

(LF) NL 

\n 

backslash 

\ 

\\ 

tab horizontal 

HT 

\t 

mark question 

\? 

tab vertical 

VT 

\v 

quote single 

' 

\' 

backspace 

BS 

\b 

quote double 

" 

\" 

return carriage 

CR 

\r 

number octal 

ooo 

\ooo 

formfeed 

FF 

\f 

number hex 

hh 

\xhh 

alert audible 

BEL 

\a 





2, consists or taken \ooo The followed 1, the which of digits, escape backslash are 3 by octal 
construction character. example is common this \0 A specify to the of value the desired of 
consists the The of NUL. \xhh the character followed (not which digit), a by specifies escape 
by x, the followed by specify digits, to taken hexadecimal backslash, which followed are 
the desired number is the value no on There the character. but of is behavior of limit digits, 
either resulting of For character. undefined if character value largest exceeds the that octal the 
escape characters, the if the signed, treats as type implementation or the hexadecimal char 
the cast not to is the of is one character char value if sign-extended If as type. \ following 
is undefined. behavior those the specified, 

represented there of be cannot In some is an that extended characters set in implementations, 
written A with L'x', type. the extended is in for constant L, char this example a set preceding 
an Such has integral constant wchar_t, type a is and character wide a called constant. type 
ordinary in with character constants, the header standard <stddef.h>. As defined 
exceeds be undefined value specified hexadecimal escapes used; the the effect if is that may 
wchar_t. with representable 

the sequences new, Some of in escape character representation. hexadecimal are particular these 
and also commonly Americas the Extended characters new. The in character used sets western are 
the encoded main to be Europe the type; fit wchar_t to adding can in was intent char in 
languages. Asian accommodate 

Constants Floating A.2.5.3 

part, an or integer floating part, an e E, a part, A of constant decimal consists a an fraction 
of exponent f, integer integer optionally type one an L. and or signed optional The F, suffix, l, 
or both the the part, a fraction consist of parts fraction of Either digits. sequence integer and 
or may the both) both) part the point missing; exponent be the (not either (not e decimal and 
l determined makes by float, the The L be or or type missing. F f may suffix; it makes it is 
is double. it long otherwise double, 

Constants Enumeration A2.5.4 

 
of declared constants type int. as (see enumerators Par.A.8.4) are Identifiers 

Literals String A.2.6 
surrounded constant, sequence by a characters double is string A a called also literal, string of 
class type characters'' static of storage (see ``array as quotes string A "...". in has and 
Whether initialized the Par.A.3 below) given is string literals identical with characters. and 
alter implementation-defined, a to attempts are distinct and the that behavior program of a is 
is undefined. string literal 

literals are null concatenated into a single concatenation, any a Adjacent string. string After 
string the its string \0 that String find end. scan so byte to is programs appended that can the 
not contain the newline or them, characters; represent to double-quote literals in do order 
are character constants available. same escape as sequences for 

with constants, extended written are As with string literals set in character an a character 
as type ``array L"...". L, literals have preceding in string ofwchar_t.'' Wide-character 
is string literals undefined. Concatenation of and ordinary wide 

and literals not The specification be string prohibitionagainst modifyingthem, the need distinct, that 
literals. is of Wide-character concatenation string string the new are standard, ANSI the in as adjacent 
new. are literals 

Notation Syntax A.3 
italic notation syntactic by indicated In the used in are this categories manual, type, syntax 
categories characters typewriter and literal style. and usually listed are in Alternative words 
of in narrow line, lines; on a set few on a presented separate cases, one alternatives long is 
the phrase the ``one of.'' carries optional symbol nonterminal An marked terminal by or 
for example, that, subscript so ``opt,'' 

} expressionopt { 

is enclosed braces. means an The expression, in Par.A.13. summarized in syntax optional 

book, given the and grammar Unlike edition this the makes in here the first precedence one of given 
expression of operators explicit. associativity 

of Identifiers A.4 Meaning 
unions, refer things: structures, of Identifiers, or to a tags variety functions; of and names, 
typedef members constants; names; and of or structures unions; enumeration enumerations; 
its sometimes a and storage, objects. An called a in variable, location is interpretation object, 
class class type. determines its storage the and on depends its attributes: main two storage The 
the storage meaning associated with the identified determines type the lifetime object; of the 
scope, the the identified the also of is region has object. of in values name found A which a 
same which name determines the known, program it is in in a which linkage, and whether the 
discussed to function. are linkage another scope the same and object Scope or in refers 
Par.A.11. 

Class Storage A.4.1 
 
keywords, classes: and There are static. storage with the together automatic Several two 
to object's class. local are context of declaration, specify objects its Automatic storage a an 
block are the a within block (Par.9.3), discarded on Declarations exit block. from create and 
specifier no mentioned, auto the automatic objects storage class if specification or is is if 
registers register (if fast in used. Objects are automatic, stored and possible) are of declared 
machine. the 

but to case a objects to their either retain all block Static local may external be or in blocks, 
including functions Within a blocks. block, block and across values reentry and from exit to a 
keyword code objects the with that provides for a declared function, are static static. the 
are outside same definitions, function The objects all blocks, as at level the always declared 
the be static by of to They made local may keyword; particular unit translation a use static. 
omitting internal to by program this gives linkage. They entire become an global an them 
class, or linkage. by using external keyword them gives the explicit extern; storage this 

Types Basic A.4.2 

several described in types. are header <limits.h> There fundamental standard Appendix The 
implementation. largest each local the B defines and smallest in values type of The the 
the given Appendix numbers acceptable smallest B in magnitudes. show 

the characters to of member Objects declared (char) are any large store enough execution as 
stored a in is If character that is character its genuine object, set. from value a set char 
may integer and quantities Other equivalent to code for non-negative. the is character, be the 
the variables, of whether especially stored into but the and available values, range value char 
is implementation-dependent. is signed, 

of char the Unsigned characters same unsigned as plain space consume amount declared 
signed but appear characters, declared characters non-negative; always signed explicitly 
plain space as characters. char likewise the take same 

but appear common in char of signed in use. this the unsigned not type edition does first is book, 
new. is char 

and types, long short int, three the up to char int, of declared integer, sizes int, Besides 
Plain int machine objects have host natural the by the are size available. suggested 
other sizes at are provided provide meet integers Longer to architecture; special the needs. 
much storage integers as shorter plain but make may ones, least the as implementation 
signed short The represent all equivalent to integers, or types long int integers. values either 
otherwise. specified unless 

laws the unsigned, Unsigned integers, obey using arithmetic modulo of keyword the declared 
arithmetic bits representation, on the thus unsigned in where 2n number the is n of and 
in non-negative can a that stored signed values can quantities set The overflow. never of be 
unsigned subset object, in corresponding values is of the a and can stored be that the object 
the values is same. the representation the for overlapping 

floating floating (float), Any of double precision (double), and point point precision single 
in point synonymous, later ones extra precision (long double) the may but be the floating 
those precise as before. list are least at as 

 
the made equivalent locution float double; has long double long first The new. is edition to 
withdrawn. been 

with that integral Enumerations are values; types enumeration is each have associated unique 
common named like is it a set constants (Par.A.8.4). but Enumerations integers, behave for of 
is issue object enumeration particular a compiler a warning a when of an assigned to 
expression of constants, something other or one its type. of its an than 

referred interpreted they to numbers, be as as objects Because can types these of be will 
sign, all with and each without also sizes, types. arithmetic int and char, Types of or 
types be integral enumeration types, types. collectively double, and float, called The will 
called be types. double floating will long 

is specifies used functions type The of It empty returned an type void set by as values. the 
no value. that generate 

types Derived A.4.3 

constructed types, infinite types derived Beside the there is of a class conceptually from basic 
the in ways: fundamental following types the 

a of type; of given objects arrays 
a of type; returning given objects functions 
a of type; to given objects pointers 
various objects of types; structures containing sequence a of 
objects any one unions capable of containing various types. of of several of 

be general can applied recursively. these of methods constructing objects In 

Qualifiers Type A.4.4 

type may its have additional that Declaring announces const qualifiers. An an object's object 
not be properties changed; declaring special volatile has it it value announces will that 
values qualifier the relevant to range Neither arithmetic properties or affects of optimization. 
discussed the in are of object. Par.A.8.2. Qualifiers 

and Lvalues A.5 Objects 

is a an An is An storage; lvalue region an named to Object of object. expression an referring 
storage an identifier and type obvious example lvalue expression suitable is with an class. of 
type, lvalues, is if are expression lvalue *E an of E There yield operators an that is then pointer 
from the points. comes ``lvalue'' expression referring object to name which The E the to 
an the E1 lvalue operand be expression. left expression assignment in E2 = E1 which must 
of each it operator specifies whether it and operands whether The expects discussion lvalue 
lvalue. an yields 

Conversions A.6 

may, depending an on their of cause value the operands, Some conversion operators of 
expected section result from the be such explains from operand another. to type one This to 

 
ordinary Par.6.5 most operators; it summarizes conversions the demanded by conversions. 
of be discussion each operator. supplemented required as by the will 

either short signed of a A integer all or an integer, or character, an object or bit-field, not, 
If be an may used. an type, used in may int wherever integer an expression be enumeration 
to the int; value converted the represent values of all otherwise type, the then original is can 
is to int. the value This converted integral promotion. called unsigned process is 

Conversions Integral A.6.2 

non-negative converted type smallest the Any integer to a finding given by unsigned value is 
that one the can than value be more is that integer, that to congruent modulo largest 
the unsigned to type. In equivalent two's is this a represented complement in representation, 
zero-filling bit type to and left-truncation if pattern of narrower, the is unsigned unsigned the 
type and unsigned is wider. sign-extending values signed if the values 

value is is represented integer When signed the to can converted it any a be unchanged type, if 
is the implementation-defined and in new otherwise. type 

and Floating A.6.3 Integer 

is of discarded; the part is a floating type value if to type, integral converted fractional When 
undefined. cannot integral is behavior the resulting be represented the in type, the In value 
result of not converting negative is values types integral floating particular, to the unsigned 
specified. 

in of the the is is a integral type value representable to and floating, converted value When 
higher not or either next then but exactly representable, is next result be may the the range 
value. If undefined. the result is out behavior the is lower of representable range, 

Types Floating A.6.4 

floating precise type, or precise is a floating value less the to equally an converted more When 
less floating converted precise is a floating value is value more a When unchanged. precise to 
next value higher be the representable and is within the or the may result range, either type, 
behavior result of is out the undefined. is next the If value. representable lower the range, 

Conversions Arithmetic A.6.5 

effect types similar is a The to in operators Many yield and conversions cause result way. 
type a of called into bring is the type, pattern common This operands which is the also result. 
arithmetic conversions. the usual 

long either the to converted  First, operand is is long other double, double. if 

is operand double,  Otherwise, the either to double. converted is other if 

is operand float,  Otherwise, the either to float. converted is other if 

operands; promotions performed  Otherwise, on integral if either then, are both the 
to int, other operand is is long long int. unsigned the converted unsigned 

 
int, int other the the unsigned effect and Otherwise,  is operand one if long is 
int; represent of if values unsigned so, all on depends int long a whether can an 
converted operand int; are both the unsigned is converted not, to if long to int 
int. long unsigned 

long one the to converted  Otherwise, operand is is long other int, int. if 

if either unsigned operand is to int, converted is unsigned  the Otherwise, other 
int. 

have operands int. Otherwise, type both  

in on may single operands done precision, float are There First, here. changes two arithmetic be 
precision. the all double was rather than first edition arithmetic specified floating that Second, double; 
the when signed propagate not shorter unsigned combined with do a type, larger unsigned types, 
new result rules always The the to type; in the are edition, unsigned the first dominated. property 
complicated, but unsigned reduce somewhat an surprises when occur the slightly that more may 
compared Unexpected when is expression quantity meets results may unsigned still an occur to signed. 
the of size. signed same expression a 

and Integers A.6.6 Pointers 

subtracted integral from case of An added or may such type in expression be a a to pointer; 
expression is operator converted as addition in the of specified the the integral discussion 
(Par.A.7.7). 

same objects array, is to Two type, the the the of subtracted; pointers same result may in be 
an integer (Par.A.7.7). as specified operator the subtraction the in converted discussion to of 

void expression *, cast type 0, integral with value constant may such expression an or to An 
any a type. a of assignment, converted, cast, by by This by to comparison, or pointer be 
pointer pointer of to null produces to null is but that type, a equal unequal the another same 
function a object. pointer or to any 

permitted, other involving Certain have but pointers conversions implementation-defined are 
operator, specified an aspects. They explicit be cast (Pars.A.7.5 or by type-conversion must 
A.8.8). and 

enough be to is may A integral large to required converted the pointer an size hold type it; 
is function implementation-dependent. The also mapping implementation-dependent. 

pointer one to may to A converted a may resulting type The pointer be pointer another to type. 
suitably if not object an cause addressing the subject to pointer refer does aligned exceptions 
converted that pointer a storage. object an a to may pointer in guaranteed It an is to to be 
type requires without less or again strict back and equally object storage whose alignment 
of ``alignment'' implementation-dependent, change; the but of char types the is objects notion 
strict alignment be requirements. As also in may pointer described have Par.A.6.8, least a 
back to void converted without again * type change. and 

for be the the except another pointer converted to may addition whose is type pointer same A 
pointer the to refers. type the If object removal or A.8.2) (Pars.A.4.4, qualifiers of of which 
restrictions equivalent old implied the for by to are qualifiers pointer new the added, is except 
the qualifiers removed, the new operations If object remain underlying are on qualifiers. 
its to actual in subject the declaration. qualifiers 

 
function to type. pointer another may a a function pointer Calling converted a to be to Finally, 
specified however, if the function is implementation-dependent; the by pointer the converted 
the reconverted the to identical converted pointer to its is original result type, original is 
pointer. 

Void A.6.7 
used of in nor value The may be void neither a and (nonexistent) object explicit any not way, 
denotes any applied. expression void implicit conversion non-void type a may Because be a to 
not used the required, where is for only value, nonexistent may expression an such be value 
comma expression the a of example as statement (Par.A.9.2) operand or left as operator an 
(Par.A.7.18). 

void be cast For a type expression converted to may documents by cast. a void example, An 
of the statement. value of expression function an as a the call discarding used 

become edition book, common this has since. of did void the in appear not first but 

to Void A.6.8 Pointers 
void an * the to Any converted type may information. object of pointer be If without to loss 
recovered. back type, is pointer result is to the original original the pointer Unlike converted 
require pointer-to-pointer generally an explicit conversions in discussed Par.A.6.6, which the 
may be be void and and pointers assigned to may compared pointers type of from *, cast, 
them. with 

roleof * char the played This interpretation pointers is pointers new; * previously, generic ofvoid 

object meeting * pointers void with in of The pointer. blesses specifically standard ANSI the pointers 

other and for pointer mixtures. relationals, requiring while explicit casts assignments 

Expressions A.7 
major same order subsections the the of as precedence The is operators expression of the of 
highest precedence the first. Thus, as example, to referred for this the section, expressions 
+ Pars.A.7.1-A.7.6. Within are of defined in operands (Par.A.7.7) expressions each those 
right-associativity the precedence. subsection, the Left- have specified in is same or operators 
given operators therein. each subsection The the Par.13 incorporates in discussed grammar for 
of associativity operators. precedence the and the 

evaluation associativity specified, of order The precedence of operators the is but fully of and 
with subexpressions involve exceptions, is, if the expressions certain even side undefined, 
are unless operator operands its effects. That the definition that of guarantees the evaluated is, 
or order, even in order, is a the implementation particular to to operands evaluate free any in 
evaluation. produced by each their the values interleave However, combines its operator 
it way of which in operands in compatible with expression the the parsing appears. a 

previous associative. are This but expressions and change to that canfail the reorder computationally The affects only be revokes associative, to withoperators freedom mathematicallycommutative rule 
near the possible. limits of is accuracy, overflow where their floating-point and computations situations 

of overflow, not divide check, is other evaluation expression and The exceptions handling in 
the language. of Most existing evaluation of in overflow implementations defined C by ignore 
not assignments, this signed integral behavior and Treatment of guaranteed. but is expressions 

 
0, implementations; sometimes all by varies among division and exceptions, it floating-point 
non-standard a function. adjustable library by is 

Conversion Pointer A.7.1 

some expression then or the of value T, the T,'' subexpression If an type ``array of is type for 
first pointer to and of the is type a in expression array, the of the expression is the the object 
is to in if expression conversion to T.'' This ``pointer the not place take does the altered 
the operator, of or of sizeof, assignment operand an or of operand & the --, unary ++, left as 
the . except operator. Similarly, T,'' expression returning ``function an operator of or type 
function the returning to to the used operand of as T.'' operator, converted is & ``pointer when 

Expressions Primary A.7.2 

or expressions identifiers, Primary in expressions constants, are parentheses. strings, 

primary-expression 
identifier 
constant 
string 
(expression) 

is a discussed primary expression, as it declared suitably provided An has identifier been 
if by to its Its is object refers an an declaration. below. specified type identifier is An it lvalue 
union, and structure, or pointer. if type its is arithmetic, (Par.A.5) 

discussed type its in on as Par.A.2.5. depends constant A expression. primary a is Its form 

char'' Its originally (for is of wide-char type string A primary a is literal expression. ``array 
of wchar_t''), usually but following is rule this Par.A.7.1, the strings, given ``array in 
a to pointer the ``pointer modified the is (wchar_t) character char'' first to and in to result the 
conversion initializers; see does The in certain string. also occur Par.A.8.7. not 

expression is to a primary identical whose are value expression A type parenthesized and 
the unadorned the expression. The whether of affect not precedence those parentheses of does 
an lvalue. expression is 

to group left right. The operators postfix in expressions 

postfix-expression: 
primary-expression 
postfix-expression[expression] 
postfix-expression(argument-expression-listopt) 
postfix-expression.identifier 
postfix-expression->identifier 
postfix-expression++ 
postfix-expression-- 

 
argument-expression-list: 
assignment-expression 
assignment-expression , assignment-expression-list 

References Array A.7.3.1 

expression followed expression by an postfix in a is expression A square postfix brackets 
``pointer array two type have denoting a reference. One must of expressions the to subscripted 
have is integral subscript T T'', the must type, of some type where and the type; other the 
definition) expression is expression is identical The *((E1)+(E2)). See to E1[E2] (by T. 
further discussion. Par.A.8.6.2 for 

Calls Function A.7.3.2 

call is parentheses a postfix by called followed designator, expression, A the function function 
of a empty, containing expressions assignment comma-separated possibly (Par.A7.17), list 
the arguments an to the of If consists expression function. which the constitute postfix 
which no implicitly declaration exists is the identifier the in identifier current for scope, 
if as the declaration declared 

identifier(); int extern 

given in expression the innermost postfix containing The call. block had the been function 
be and generation, (after possible Par.A7.1) declaration type ``pointer of pointer must explicit 
value T,'' of T. returning to T, the some has for call function type type the and function 

* type required was the and call was to an restricted In the first ``function,'' edition, to operator explicit 
compilers functions. the existing some through pointers The ANSI of standard practice blesses by to 
pointers. functions functions The to by older and the permitting calls for syntax same to specified 
still usable. syntax is 

term is parameter function the an term used for argument is passed a by expression call; The 
described input in function or its for object (or an a received a by identifier) definition, used 
(parameter)'' declaration. terms function ``formal and ``actual The argument argument 
same for the distinction. (parameter)'' respectively sometimes are used 

argument; the all made each a preparing call to for argument-passing a is copy function, of In 
objects, change of which values parameter are the strictly is function A value. by may its 
the argument the expressions, but of changes values the these copies cannot of affect 
the is pointer that understanding arguments. However, possible to the pass on a function it 
the the pointer of change to which may value object points. the 

the styles types the style, functions are in which two of be In declared. may new There 
declaration and os function; a of are are part explicit also type the of the such parameters 
function prototype. Function In the specified. style, not are old called parameter a types 
Pars.A.8.6.3 in A.10.1. is and issued declaration 

argument a old-style, promotion is default is call the If scope in declaration function for then 
is as integral applied to promotion argument on each performed follows: (Par.A.6.1) each 
effect argument to of converted The the is of argument each and type, integral float double. 
parameters arguments the in with of the disagrees is call number the if undefined of number 
with function, that after disagrees the of or if the of of argument an type promotion definition 
parameter. function's definition agreement corresponding whether the the Type on is depends 

 
promoted then is type comparison the of the or new-style is it If old-style. old-style, between 
definition the is parameter, the the arguments call, and of new- type the of promoted if the 
itself, type be parameter the style, the of the of argument that must without promoted 
promotion. 

arguments a new-style, are is the converted, call the If scope in declaration function for then 
function's assignment, the the of as if to the parameters types corresponding of prototype. by 
described arguments as explicitly of The number must be number the the same parameters, of 
that the (, case, notation In the ellipsis the unless ends list parameter declaration's with ...). 
of equal exceed number of the must trailing arguments parameters; or number arguments 
as parameters default beyond the argument typed in the described suffer promotion explicitly 
of the is type the preceding paragraph. definition of then the old-style, function each If 
the has undergone after in parameter's type parameter definition, definition argument the 
promotion. 

old- must a and to of new-style cater rules These because complicated especially are they mixture 
avoided Mixtures if be functions. are possible. to 

of evaluation differ. of arguments compilers unspecified; various that is The take order note 
arguments evaluated, including the the are completely However, and designator all function 
before the permitted. function is are Recursive function any entered. side calls effects, to 

References Structure A.7.3.3 

postfix followed identifier expression. an a The by postfix A a by followed expression dot is 
must or and name union, identifier a a operand first a be must expression structure the 
structure structure or member the The of or union. the union, is named the value of member 
member. type of lvalue first expression is the the expression is an its and is type an if the The 
if the type. type of array second an not the lvalue, expression and is 

and followed >) a expression A (built - an identifier by an postfix arrow is followed from by 
or be to union, pointer structure and a expression. postfix expression operand first The must a 
to name the The refers of identifier a member must named structure union. or the result the 
type structure is points, the to of or union the the the expression pointer which and member 
an member; array type not is of the result the type. lvalue the if an is type 

expression E1->MOS discussed is the are as unions and same Thus (*E1).MOS. the Structures 
Par.A.8.3. in 

the edition name it to first an such rule In book, had already the in that was expression of member a this 
admitted structure that however, note mentioned to or union the this the expression; postfix in a belong 
not do enforce enforced. was and ANSI, rule firmly compilers, it. Recent 

Incrementation Postfix A.7.3.4 

is followed a the expression A or operator a value by The postfix ++ of postfix -- expression. 
is value incremented noted, operand operand. is of the the ++ the is value After the expression 
discussion must lvalue; of an the additive be decremented or The 1. by -- operand see 
and the operand (Par.A.7.17) (Par.A.7.7) constraints on operators assignment further and for 
is of operation. details an not The the lvalue. result 

Operators Unary A.7.4 

 
group right-to-left. operators Expressions unary with 

unary-expression: 
expression postfix 
expression ++unary 
expression --unary 
cast-expression unary-operator 
unary-expression sizeof 
sizeof(type-name) 

one of unary operator: 
~ ! - & + * 

Incrementation Operators A.7.4.1 Prefix 

The followed operand a expression. ++ unary by a expression is -- is operator or unary A 
value decremented after expression the 1. ++ -- by or the value the of The is incremented 
The the discussion must (decrementation). lvalue; see incrementation operand an of be 
constraints operators further on the (Par.A.7.7) assignment and (Par.A.7.17) for additive 
details not an the and result is operands of The lvalue. operation. 

Operator Address A.7.4.2 

an & lvalue operand be address unary takes the operator referring its The operand. of must The 
register, bit-field or The a neither object as to function nor of to an type. must declared be 
function the object lvalue. type of pointer the to to the the is result by a operand If or referred 
``pointer T, is to T.'' the of type the result is 

Operator Indirection A.7.4.3 

which operator the to function The unary denotes indirection, or and object returns its * 
a is pointer structure, It operand the is lvalue of an object points. if arithmetic, to operand an 
the the type T,'' of the type. type If is result to or union, ``pointer pointer is the of expression 
T. 

Plus Operator A.7.4.4 Unary 

type, the and of of The must arithmetic + the unary is operand operator value the have result 
is integral The result the the operand. operand undergoes of integral type promotion. the An 
the of promoted operand. type 

was is added -. + The ANSI It with the new with unary the unary for standard. symmetry 

Minus Operator A.7.4.5 Unary 

is the the and result operator operand unary - of negative have type, arithmetic must the The 
The integral undergoes of its integral An of an negative operand promotion. operand. 
of computed value value largest unsigned quantity by subtracting the the from promoted the is 
the but the negative type The of is type type zero promoted one; and zero. adding is result of 
operand. promoted the 

Complement Operator A.7.4.6 One's 

 
the the one's the is must operand ~ operator of complement integral and type, have result The 
the performed. operand result the unsigned, is If its of promotions integral The operand. are is 
If largest the the of type. operand value by computed from value the subtracting the promoted 
the result corresponding is computed the converting to operand by is the signed, promoted 
type. ~, The the applying unsigned to signed converting result and the type, back is type the of 
the of promoted operand. type 

Negation Operator A.7.4.7 Logical 

Operator Sizeof A.7.4.8 

store yields an its operator The bytes to number type the the sizeof of of object required of 
parenthesized is is a or operand. The either an evaluated, expression, not which type operand 
the to a applied array, the is an applied is result when When name. 1; sizeof is to char, result 
or in result the total to the the is a array. the bytes number applied of When union, structure 
tile in an make object including of the object, bytes array: padding to required any the number 
may n of elements element. is an The size operator the array of times size the n be not one of 
a function result type, to type, an The is or or applied of an incomplete operand of bit-field. to 
The integral implementation-defined. standard header constant; particular the type is unsigned 
as this type size_t. <stddef.h> (See B) appendix defines 

Casts A.7.5 

of preceded of conversion causes A unary by the type parenthesized a name the expression 
the of named to value the type. expression 

cast-expression: 
expression unary 
cast-expression (type-name) 

effects called are The Par.A.8.8. This construction a cast. in The described names of is 
described in lvalue. Par.A.6. An an with not is expression conversions a are cast 

Operators Multiplicative A.7.6 

group and % left-to-right. The multiplicative *, operators /, 

multiplicative-expression: 
cast-expression * multiplicative-expression 
cast-expression / multiplicative-expression 
cast-expression % multiplicative-expression 

the * operands type. of The have type; / have and must operands must integral of arithmetic % 
of conversions operands, type the The usual are performed predict on and the the arithmetic 
result. 

denotes multiplication. operator The * binary 

 
the operator division the of quotient, binary yields the / of the operator % and remainder, The 
is by undefined. 0, result if first the second; operand Otherwise, second is operand the the the 
both (a/b)*b non-negative, + is to the are then a. a%b it that always equal true is operands If 
only divisor, it that not, guaranteed the if is remainder than smaller and non-negative the is 
of the divisor. remainder is the than of value smaller absolute the value absolute 

Operators Additive A.7.7 

type, + If arithmetic have The additive and - operands group the left-to-right. the operators 
conversions type possibilities performed. arithmetic some additional usual are are for There 
operator. each 

additive-expression: 
multiplicative-expression 
multiplicative-expression + additive-expression 
multiplicative-expression - additive-expression 

the the an the a of an in operands. The is and of result object A sum array + to pointer operator 
address integral offset converted an be of type may any by The is latter added. to value 
to of the The a pointer the is size the of points. it multiplying pointer by the sum object which 
same points object array, another the appropriately to type same pointer, original the as and in 
object Thus array, if from pointer expression an the to P offset object. the a original is in an 
in the next sum outside the pointer points to array. bounds the is P+1 If a of pointer object the 
is at the result the the array, the first end, location high beyond undefined. except 

It beyond common the provision array for a idiom is end The just for an pointers of legitimizes new. 
of elements array. over an the looping 

value operator integral is result the may any type operands. the The - of of the difference of A 
for a same as conditions be subtracted pointer, and and then conversions the addition from 
apply. 

subtracted, to the value pointers If same are of signed objects a two the integral result type is 
to the pointers successive objects displacement the between pointed-to objects; representing 
the result as standard defined in header is by differ of type The 1. the ptrdiff_t 
value is same undefined unless the pointers within objects the <stddef.h>. point The to 
has P value array, (P+1)-P the however, points to if 1. member an of last then array; 

Operators Shift A.7.8 

must << For operand each The shift and >> operators, group both left-to-right. be operators 
that subject of the is the and to integral is the The of type promotions. result integral, 
or if operand greater right negative, than the left promoted is result The operand. undefined is 
to left expression's number equal in the or the bits type. of 

shift-expression: 
additive-expression 
additive-expression << shift-expression 
additive-expression >> shift-expression 

pattern) E1<<E2 left-shifted of of The as bit E1 the is in value (interpreted absence E2 a bits; 
E1 equivalent The is E1>>E2 overflow, this to multiplication of by value 2E2. right-shifted is 

 
to shift is E1 or it The unsigned right by has if bit E2 2E2 positions. a is equivalent division 
result the implementation-defined. value; is otherwise non-negative 

Operators Relational A.7.9 

parsed group is is a<b<c The relational left-to-right, but useful; this not fact as operators 
0 and or either (a<b)<c, evaluates 1. to 

relational-expression: 
shift-expression 
shift-expression < relational-expression 
shift-expression > relational-expression 
shift-expression <= relational-expression 
shift-expression >= relational-expression 

or (greater), <= or yield 0 (less), all > and if (greater operators The >= < the equal) (less equal) 
is 1 if the int. The false is and The usual of relation specified type is arithmetic result it true. 
of arithmetic Pointers conversions are to on same type the operands. objects performed 
in may depends locations relative (ignoring any be compared; the the on result the qualifiers) 
of the is parts for address space pointed-to objects. only Pointer defined comparison the of 
equal; the object, if simple compare the same object; same point pointers two if to they 
in members pointers later declared pointers are of the objects same to structure, the to 
comparison if members the array, structure compare the pointers an refer of to is higher; 
last subscripts. points member P the of If to equivalent the the of comparison corresponding to 
the P+1 even outside points an array, compares higher P+1 than though P, array. then 
comparison pointer is undefined. Otherwise, 

comparison liberalize the permitting by These rules the restrictions edition, stated first in of slightly 
a members pointer legalize with structure to of a different just union. also They or comparison pointers 
an array. of off end the 

Operators Equality A.7.10 

equality-expression: 
relational-expression 
relational-expression == equality-expression 
relational-expression != equality-expression 

the to) relational are to != == and the (equal operators equal operators to) (not analogous The 
c<d lower have whenever and a<b for precedence. (Thus their the c<d 1 is == a<b except 
truth-value.) same 

operators follow additional the same permit as but operators, rules The the equality relational 
or may to with 0, to a be compared pointer a constant expression integral a value possibilities: 
void. to See Par.A.6.6. pointer 

AND Operator A.7.11 Bitwise 

AND-expression: 
equality-expression 
equality-expression & AND-expression 

 
of conversions is function AND The usual are performed; bitwise the the result the arithmetic 
to The integral only operands. operator operands. applies 

Exclusive Bitwise OR Operator A.7.12 

exclusive-OR-expression: 
AND-expression 
AND-expression ^ exclusive-OR-expression 

the are the The usual result conversions exclusive OR bitwise performed; is arithmetic 
to of only integral operands. the The operands. operator applies function 

Inclusive Bitwise OR Operator A.7.13 

inclusive-OR-expression: 
exclusive-OR-expression 
exclusive-OR-expression | inclusive-OR-expression 

the are the The usual result conversions inclusive OR bitwise performed; is arithmetic 
to of only integral operands. the The operands. operator applies function 

AND Operator A.7.14 Logical 

logical-AND-expression: 
inclusive-OR-expression 
inclusive-OR-expression && logical-AND-expression 

unequal 1 its to both compare zero, if && The It left-to-right. groups operator returns operands 
first && left-to-right 0 otherwise. evaluation: &, is evaluated, operand guarantees the Unlike 
the it 0. is all the the is Otherwise, value equal including if side 0, effects; to expression of 
0, evaluated, the 1. is right is to if 0, and is operand it otherwise expression's equal value 

must not have pointer. need The type, each the be have or operands same a arithmetic but type 
is int. The result 

OR Operator A.7.15 Logical 

logical-OR-expression: 
logical-AND-expression 
logical-AND-expression || logical-OR-expression 

compare 1 of unequal either operands to if || The It left-to-right. groups operator returns its 
0 otherwise. is Unlike |, operand guarantees first the || zero, left-to-right and evaluation: 
0, side the 1. all evaluated, is to if expression effects; the including it is value unequal of 
unequal operand to 1, right Otherwise, if is evaluated, value is expression's the and is 0, it the 
0. otherwise 

must not have pointer. need The type, each the be have or operands same a arithmetic but type 
is int. The result 

Operator Conditional A.7.16 

 
conditional-expression: 
logical-OR-expression 
expression ? : conditional-expression logical-OR-expression 

to side it 0, if unequal the effects; first The including evaluated, is expression all compares 
Only value one the expression. second is of the the of otherwise of that expression, third result 
are third the operands third the second operands is and evaluated. second If arithmetic, and 
and bring a that to type, type them usual the performed are conversions arithmetic to common 
are result. If unions same type, of the the or or or the is structures type pointers of both void, 
has type, the one pointer and the a same common the If objects to type. of other is result the 
one converted result to that the the type. constant If and 0 0, type, the the pointer a is has is 
other and pointer to void pointer another the other a the to to is pointer is pointer, converted 
the type of result. void, and is that the 

to type in which (Par.A.8.2) type the qualifiers the In pointers, for comparison type any the 
of insignificant, inherits arms both pointer points but the from result qualifiers type the are 
conditional. 

Expressions Assignment A.7.17 

all are group operators; There several right-to-left. assignment 

assignment-expression: 
conditional-expression 
assignment-expression assignment-operator unary-expression 

of one assignment-operator: 
&= *= >>= ^= |= /= += %= -= <<= = 

must lvalue be an an All and lvalue left not as must require operand, be modifiable: the it 
a not function. be must array, type, be an must have type and incomplete not Also, or its 
it if must recursively, const; qualified structure union, is member it any with a or, not or have 
its const. assignment of that submember qualified The type is of expression an left with 
assignment value has operand the value and is the the taken in left the stored after operand, 
place. 

of value expression the the that object of the In =, with assignment simple the replaces 
operands the be have must both arithmetic following to referred One lvalue. the by of true: 
the right the operand in the or by assignment; type is type, the which to case converted left of 
or structures one the are both the type; unions pointer or a operands of and operand same is 
left void, or and operand is pointer right to is a pointer is other a a constant the the operand 
whose are functions types to objects are pointers with expression both or 0; value operands or 
right for const the in the same the possible volatile absence or of operand. except 

is E1 op= E1 except that the (E2) form to E1 = expression An E1 of is op E2 equivalent 
once. only evaluated 

Operator Comma A.7.18 

expression: 
assignment-expression 
assignment-expression , expression 

 
of expressions the and value a pair separated by of left is left-to-right, evaluated comma the A 
are The the right discarded. expression of result and of type value is value the type the and 
left-operand from evaluation operand. All of effects completed before are the the side 
a of contexts given is beginning the the right comma operand. where In special evaluation 
and lists function meaning, for arguments in of initializers lists of (Par.A.7.3.2) example 
so unit an (Par.A.8.7), the assignment syntactic comma operator the is expression, required 
grouping, only for parenthetical appears in example, a 



t+2), c) f(a, (t=3, 

the three has value 5. arguments, second the of which has 

Expressions Constant A.7.19 

a is expression Syntactically, a restricted expression of operators: subset an to constant 

constant-expression: 
conditional-expression 

as to in case, after Expressions that a constant contexts: are several required array evaluate 
and lengths, an initializers, in bounds and as the constant, value enumeration of in bit-field 
expressions. preprocessor certain 

increment expressions not Constant decrement or contain may operators, assignments, 
or comma constant operators; except the an If sizeof. in function operand calls, of 
consist be its expression is operands to integer, enumeration, of integral, must required 
type, casts specify character, and an constants; any floating and must integral floating 
out to This constants must necessarily cast indirection, address-of, arrays, integer. rules be 
permitted structure is for sizeof.) member (However, operations. any operand and 

is permitted be for the may expressions operands the constant More of latitude initializers; 
be constant, applied and of any & may the static and or type unary objects, to operator external 
operator static constant & unary to external arrays subscripted The with expression. a can and 
applied and functions. by be unsubscripted arrays also implicitly of Initializers appearance 
external to or a declared or evaluate a constant either static the of address to previously must 
a constant. minus object or plus 

after for integral Less latitude constant allowed sizeof expressions, #if; the expressions is 
See not permitted. Par.A.12.5. enumeration constants, casts and are 

Declarations A.8 

do given each Declarations specify identifier; interpretation necessarily reserve not to they the 
with are called identifier. associated reserve storage storage the that definitions. Declarations 
the form Declarations have 

declaration: 
init-declarator-listopt; declaration-specifiers 

in being declared; init-declarator declarators the identifiers The the contain the list 
storage consist and class specifiers. of sequence a of type declaration-specifiers 

 
declaration-specifiers: 
declaration-specifiersopt storage-class-specifier 
declaration-specifiersopt type-specifier 
declaration-specifiersopt type-qualifier 

init-declarator-list: 
init-declarator 
init-declarator , init-declarator-list 

init-declarator: 
declarator 
initializer = declarator 

names later they Declarators will contain discussed declared. A being (Par.A.8.5); the be 
a or specifier structure type declare tag, its must declaration one least at have declarator, must 
tag, or permitted. the members not an are declarations of a enumeration; union empty 

Class Specifiers A.8.1 Storage 

class storage specifiers are: The 

specifier: storage-class 
auto 
register 
static 
extern 
typedef 

were meaning the The in discussed storage of Par.A.4.4. classes 

and register may specifiers give and declared class, storage the The objects auto automatic 
storage within serve cause and be used functions. Such definitions declarations as also to only 
that register an hints but be reserved. declaration is declaration, equivalent auto to the A 
will be into accessed frequently. placed a actually are Only declared few objects objects 
restrictions and the are implementation-dependent. only types certain are eligible; registers, 
applied object to may be register, if is declared an it, unary operator & the not However, 
implicitly. or explicitly 

declared illegal actually to rule of to but taken an calculate The is that address it the register, object 
is new. be auto, 

used gives storage be may The static the declared and objects class, static either specifier 
allocated, functions. specifier be to inside or Inside a storage function, causes this and outside 
a function, see for as outside a serves definition; effect Par.A.11.2. its 

the extern, specifies for storage A declaration used inside the a that function, declared with 
defined function, see for is outside a objects elsewhere; effects Par.A.11.2. its 

specifier and a only called class for is typedef The reserve not does specifier storage storage 
discussed is Par.A.8.9. convenience; in it syntactic 

 
a storage declaration. rules one At be in specifier given, class is most may these If given none 
declared are be within to functions a taken used: are a inside declared objects function auto; 
are and outside taken declared function to functions are function extern; be to taken objects a 
See static, Pars. linkage. be with A.10-A.11. external 

Specifiers Type A.8.2 

are type-specifiers The 

be of specified is one At or may words the the int; most long meaning together short with 
with int double. be together mentioned. same is not if At word may long The specified the 
with signed int or of most be together unsigned its or of one may short or specified any 
is appear which understood. in int The alone varieties, long Either char. with or may case 
is objects a permissible carry it but to specifier signed forcing for useful is char sign; 
other with integral types. redundant 

type-specifier one in the If Otherwise, at type-specifier may declaration. be a given is most 
taken from declaration, missing be to it a int. is 

also be declared. qualified, to being special objects the indicate Types properties may of 

type-qualifier: 
const 
volatile 

initialized, specifier. object but const be not A qualifiers Type any with appear may type may 
implementation-dependent assigned There thereafter for semantics are to. volatile no 
objects. 

const volatile is The of new const properties are and to the standard. ANSI with purpose The 
opportunities may memory, increase to announce objects be placed perhaps in and read-only for that 
purpose of that volatile is optimization force suppress to to optimization. an The implementation 
to For with pointer a could otherwise example, for input/output, a memory-mapped machine a occur. 
the be compiler order prevent a register declared as might from to in volatile, pointer to device 
it through pointer. removing apparently Except references diagnose explicit should the that redundant 
ignore to may these qualifiers. change objects, const a compiler attempts 

and Structure Union Declarations A.8.3 

 
types. an A members various of structure object consisting is union sequence named of a of A 
various that any of members is an contains, at several different of times, types. object 
the and same have Structure union form. specifiers 

struct-or-union-specifier: 
struct-declaration-list } struct-or-union identifieropt{ 
identifier struct-or-union 

struct-or-union: 
struct 
union 

is a or sequence of structure for the of declarations A the struct-declaration-list members 
union: 

struct-declaration-list: 
declaration struct 
declaration struct struct-declaration-list 

struct-declarator-list; specifier-qualifier-list struct-declaration: 

specifier-qualifier-list: 
specifier-qualifier-listopt type-specifier 
specifier-qualifier-listopt type-qualifier 

struct-declarator-list: 
struct-declarator 
struct-declarator , struct-declarator-list 

or for of union. member structure A a a Usually, a just is struct-declarator declarator a 
is also also Such member a member consist of may called number bits. of specified a structure 
by length a the name off bit-field; is set its colon. the for declarator from field a 

struct-declarator: 
: constant-expression declarator declaratoropt 

the form of A specifier type 

{ identifier struct-declaration-list } struct-or-union 

or to union subsequent identifier declares of structure the list. be the the tag A specified the by 
may an inner type the tag same using or to in same in declaration the the a by scope refer 
the list: specifier without 

identifier struct-or-union 

tag tag declared, but a appears incomplete not an when without If a specifier list with a is the 
mentioned Objects or be may type is with an type incomplete union structure in specified. 
their size for is not definitions), for (not declarations needed, contexts example where in 
becomes or but type The specifying a for creating otherwise. a not typedef, complete pointer, 
list. a tag, declaration a on occurrence subsequent specifier containing with and that Even of 

 
incomplete or being within type is the union specifiers in the list, a with structure declared 
terminating and } the specifier. becomes only complete at the list, 

impossible not incomplete is it A structure contain a Therefore, member type. of to may 
a or of giving besides declare a union containing However, an itself. instance name structure 
structure or definition a structures; to the union type, self-referential tags of allow or structure 
incomplete instance because types itself, to may of may union to pointer a contain an pointers 
declared. be 

declarations very rule A the of applies special form to 

identifier; struct-or-union 

Even structure if and declarators. but declare or union, a the no list declaration have no that 
(Par.A.11.1), structure declared scope outer identifier is or union an tag in already this a 
in identifier new, union or declaration makes the tag structure of incompletely-typed a the the 
scope. current 

declared new in with structures It recondite with ANSI. is an intended deal to is mutually-recursive This 
in tags already inner scope, be whose outer scope. the might declared but 

but with a unique can be union it specifier tag referred a structure A creates or to type; list no 
is only it a part. in declaration the of which directly 

ordinary members variables. other with do names and tags of A conflict each with not or The 
the the or same structure but member same name member twice appear not may in union, 
or different structures unions. name may used be in 

structure edition and with first In the of this not of were the book, associated union names members 
However, this standard. association became ANSI in the before common their compilers parent. well 

field of member object A or non-field a structure member (which may any have union type. A 
unsigned may has int, unnamed) int, or be not need and declarator a have thus type 
length is in of specified an int, interpreted as and bits; of type integral object the signed 
int implementation-dependent. Adjacent is an signed is whether field as field treated 
units of storage in an structures packed are into implementation-dependent members 
not field another implementation-dependent direction. field a into a fit following will When 
be between the padded. or may An units, storage partially-filled be may it unit, split unit 
will forces the this field the of at edge next padding, unnamed 0 with that width so begin field 
allocation unit. the next 

It makes than edition. first The ANSI fields even the more did implementation-dependent is standard 
read as ``implementation-dependent'' language to storing bit-fields advisable the for without rules 
to as way reduce portable attempting the a Structures qualification. be may bit-fields with used of 
space, probable increasing and of instruction time, cost required storage (with structure a for the the 
storage or at as to to bit- known the describe a needed fields), access way the non-portable layout a 
the necessary the local understand of implementation. to In level. it case, second the is rules 

declarations. a in their of The members structure have order addresses the increasing A of 
its a an on depending non-field member structure is boundary aligned addressing at type; of 
a holes cast in there a the is to pointer a therefore, unnamed may If be structure. structure to 
first pointer the the to type of to its refers first result member, member. a 

 
begin of 0 as union of whose offset and whose a A thought may all be structure at members 
members. any of the be stored to can contain most in of is size one sufficient a members its At 
of the a the union to cast is any to a at a If pointer a time. pointr type member, union result to 
that member. refers to 

structure simple declaration a A example is of 



{ tnode struct 

tword[20]; char 

count; int 

*left; tnode struct 

*right; tnode struct 

similar array integer, to pointers which contains of 20 two characters, and an structures. an 
given, this the bene Once declaration declaration has 



s, *sp; struct tnode 

and be pointer the given to structure a sp declares of the sort, s to to given of a a be structure 
the expression declarations, sort. these With 

sp->count 

the which sp field to structure to refers count the points; of 



s.left 

structure to the s, and the subtree left pointer of refers 



s.right->tword[0] 

of first member subtree right refers to character of the the of tword s. the 

value a union union general, inspected been the has unless may In of a be member not of the 
simplifies member. one assigned using special same use of the However, guarantee the 
and union share sequence, initial unions: if contains several common structures a that the a 
the it to common permitted to initial is currently union these of one contains structures, refer 
legal of example, a is part of the contained following structures. the For fragment: any 



{ union 

{ struct 

type; int 

n; } 

{ struct 

type; int 

intnode; int 

ni; } 

{ struct 

type; int 

floatnode; float 

nf; } 

u; } 

... 

FLOAT; = u.nf.type 

3.14; = u.nf.floatnode 

... 

== FLOAT) if (u.n.type 

... sin(u.nf.floatnode) ... 

Enumerations A.8.4 

 
unique types called with values constants over named of ranging Enumerations a are set 
that an specifier enumerators. The borrows of structures and of enumeration from form 
unions. 

enum-specifier: 
{ identifieropt enumerator-list } enum 
identifier enum 

enumerator-list: 
enumerator 
enumerator , enumerator-list 

enumerator: 
identifier 
constant-expression = identifier 

and declared of may constants int, appear as identifiers The list enumerator an in are type 
of required. = values the wherever constants If no then enumerations appear, with the are 
from at left declaration read increase constants 0 and begin to 1 the as by is corresponding 
the = the right. An associated with specified; subsequent value gives identifier enumerator 
the continue assigned from identifiers the value. progression 

and all from from distinct other ordinary be names Enumerator scope same the in must each 
be need not distinct. variable names, the but values 

to the that a of The enum-specifier analogous in tag identifier structure role the in of is the 
names enum-specifiers with particular it rules for struct-specifier; a The and enumeration. 
specifiers, as structure except for union that those tags without the are lists and same or 
an not the incomplete enumeration tag do without an enum-specifier exist; of types 
with list specifier a list. must to refer an in-scope enumerator 

part first language edition are but some the for have of Enumerations the new book, since this of been 
years. 

Declarators A.8.5 

the syntax: Declarators have 

declarator: 
direct-declarator pointeropt 

direct-declarator: 
identifier 
(declarator) 
constant-expressionopt ] direct-declarator [ 
parameter-type-list ) direct-declarator ( 
identifier-listopt ) direct-declarator ( 

pointer: 
type-qualifier-listopt * 
pointer type-qualifier-listopt * 

 
type-qualifier-list: 
type-qualifier 
type-qualifier type-qualifier-list 

and resembles of The structure indirection, declarators expressions; the array that function, of 
the same. grouping is 

of Declarators A.8.6 Meaning 

specifiers. declarators of class storage A list appears after and a type sequence Each of 
alternative one as of appears first the that declares declarator identifier, main unique a the the 
direct-declarator. to this storage for apply directly production The specifiers identifier, class 
A depends declarator that type but of declarator. the an on as its form assertion is its read 
it appears yields as declarator, expression its in an identifier an the form same of the when 
the of specified type. object 

the type particular parts of a declaration and A.8.2) the Considering specifiers only (Par. 
where form ``T and a declarator. has is the is The type a declarator, a declaration type D D,'' T 
using identifier of inductively described attributed to in the is various declarator forms this the 
notation. 

identifier, T the T. declaration In is unadored where identifier D the a D is type an of 

D a T In the has D declaration form where 



) D1 ( 

not in of D1 The is of parentheses the do as the type same that then the the alter D. identifier 
complex binding of declarators. type, but change may the 

Declarators Pointer A.8.6.1 

D a T In the has D declaration form where 

D1 type-qualifier-listopt * 

D1 of is the type and the T identifier type the the the in of ``type-modifier declaration T,'' 
Qualifiers ``type-modifier pointer identifier of to is * apply following type-qualifier-list T.'' D 
which than the to pointer object rather pointer points. the to to itself, 

consider example, the declaration For 



*ap[]; int 

ap the the (below) give D1; ap[] role of plays type declaration ap[]'' ``int a would Here, 
of.'' empty, type-modifier Hence the ``array the and of ``array list type-qualifier the int,'' is is 
pointers declaration to to int.'' gives the ap type ``array actual 

examples, other the declarations As 



cpi *const &i; i, = *pi, int 

3, *pci; = const ci int 

 
of a pointer pointer an pi. may constant cpi The to declare and integer integer i an the value 
location, it although refers changed; not to same always which will to be point it the the value 
it The may be (though is be integer ci altered. be and not may constant, changed may 
itself The may int,'' pci pci as type of here.) be ``pointer const to is and initialized, 
which to it by point changed the to place, be another not to but altered points value may 
pci. through assigning 

Declarators Array A.8.6.2 

D a T In the has D declaration form where 

[constant-expressionopt] D1 

D1 of is the type and the T identifier type the the the in of ``type-modifier declaration T,'' 
it T.'' constant-expression must the present, have If of identifier array ``type-modifier is D of is 
bound value the the specifying integral type, greater than expression 0. constant If is and 
an has type. the incomplete array missing, 

a arithmetic a structure from from or type, array An from constructed be may an pointer, 
which another multi-dimensional from type union, or array (to Any generate array). a an from 
of must incomplete array structure it is be complete; constructed type. not an be must of array 
missing. for the be may This implies a multi-dimensional dimension array, first only The that 
declaration object is complete, another, type of of incomplete by aray completed type for an 
it object or the For (Par.A.8.7). by (Par.A.10.2), example, initializing 



*afp[17]; fa[17], float 

numbers. of array float to declares an float numbers pointers and of an Also, array 



x3d[3][5][7]; int static 

In three-dimensional complete 5 7. integers, a array of static detail, rank X 3 with X declares 
latter items: five each each item array of is the array of an an of x3d is is arrays arrays; three 
x3d, integers. of an array the seven x3d[i][j], x3d[i][j][k] x3d[i], Any expressions of 
last first type has have the type three reasonably may expression. an in appear The ``array,'', 
array x3d[i][j] of x3d[i] an array More is an specifically, 5 7 and integers, of is int. 
7 integers. arrays of 

is is so The array that operation to *(E1+E2). identical defined E1[E2] subscripting 
is despite asymmetric Therefore, commutative a appearance, its operation. subscripting 
to conversion arrays is the Because to and that if rules A.7.7), of apply E1 (Pars.A6.6, + A.7.1, 
of E2 refers member E2-th an array an integer, the then to E1[E2] E1. and 

k). is to In the *(x3d[i][j] x3d[i][j][k] first subexpression The equivalent + example, 
Par.A.7.7, by to by integers,'' x3d[i][j] is Par.A.7.1 to of type array ``pointer the converted 
rules an follows that It the arrays integer. involves addition size the by multiplication of from 
in fastest) the the that subscript declaration and stored are subscript (last rows by varies first 
other by but part array, no in an determine helps storage of amount the consumed plays 
calculations. subscript 

Declarators Function A.8.6.3 

new-style has the declaration a where D In function D form T 

 
(parameter-type-list) D1 

type of of is the in the the identifier type the declaration D1 T the ``type-modifierT,'' and 
arguments ofD ``type-modifier identifier returning parameter-type-list function is T.'' with 

parameters is the The of syntax 

parameter-type-list: 
... parameter-listparameter-list, 

parameter-list: 
parameter-declarationparameter-list,parameter-declaration 

parameter-declaration: 
abstract-declaratoropt declaratordeclaration-specifiers declaration-specifiers 

As declaration, the parameters. the In the the parameter of list types specifies a new-style 
parameter declarator with a has special case, for a parameters new-style no function list the 
of accept of with parameter may ...'', described, number explicitly more the list void. keyword soley ``, ellipsis than thenthe the ends parameters an function arguments the If consisting 
Par.A.7.3.2. see 

in or altered accordance are pointers, with functions types The are that parameters of arrays to 
storage conversions; Par.A.10.1. the rules The parameter specifier permitted class see only for 
parameter's declaration function is register, the this unless ignored and in specifier a is 
a in the definition. heads the declarators declarator function if parameter Similarly, 
head the declarator declarations contain does and function definition, a function not identifiers 
go out the of scope mention Abstract not do immediately. the declarators, identifiers which 
discussed are in Par.A.8.8. identifiers, 

old-style has the declaration an where D In function D form T 

D1(identifier-listopt) 

type of of is the in the the identifier type the declaration D1 T the ``type-modifierT,'' and 
have arguments Theparameters the T.'' present) form returning ofD identifier of function ``type-modifier is unspecified (if 

identifier-list: 
identifieridentifier-list,identifier 

used declarator, in the is list the the identifier old-style the be unless absent must declarator In 
parameters function about the of head of definition (Par.A.10.1). types No the information is a 
the declaration. supplied by 

the declaration For example, 

 
*fpi(), (*pfi)(); int f(), 

an f integer, a to integer, a returning an function and function returning fpi a pointer declares 
the to parameter of are returning pointer a function pfi types integer. none In an these a 
are old-style. specified; they 

new-style declaration In the 



char const rand(void); strcpy(char *source), *dest, int 

pointer, two first and the character the arguments, is strcpy int, returning function a with a 
are constant The second a parameter to comments. The effectively characters. names pointer 
returns arguments and int. second function takes rand no 

most prototypes by Function declarators far, parameter language change important are, the with 
of an the the over declarators first advantage by introduced They standard. ANSI the offer ``old-style'' 
a error-detection across at but edition by and coercion calls, of function arguments cost: providing 
confusion during Some their introduction, forms. the both accomodating and turmoil necessity and of 
explicit of void marker namely an of compatibility, ugliness syntactic the for required was sake as 
without parameters. new-style functions 

new, ``, and, the notation The functions also for macros ...'' the ellipsis variadic in together is with 
<stdarg.h>, forbidden but a header was officially standard formalizes that unofficially mechanism 
the in first edition. condoned 

the notations C++ from These were language. adapted 

the is specify for value When an declared, its initial init-declarator an may identifier object 
a initializer list an or by declared. is preceded The of and either is =, expression, being 
for end comma, neat a nicety formatting. with nested initializers list A braces. in may a 

initializer: 
assignment-expression 
} initializer-list { 
, } { initializer-list 

initializer-list: 
initializer 
initializer , initializer-list 

constant in expressions array be for the the initializer expressions as static or object a must All 
object The for register or described in expressions in auto the an initializer or Par.A.7.19. 
likewise be However, constant expressions list. the brace-enclosed a if array initializer must is 
be for a it not object the an automatic initializer constant a expression, single is need if 
must to the have but for assignment expression, merely type object. appropriate 

The did automatic arrays. or The first not countenance unions, initialization structures, of ANSI edition 
by but a can expressed constant allows only by it, simple unless initializer the constructions be standard 
expression. 

were not assigned (or members) is static explicitly initialized object the as it if initialized its A 
The initial undefined. value of is automatic intialized explicitly an constant object 0. not 

 
expression, a perhaps is single an initializer pointer or for in of type arithmetic object a The 
to The the assigned braces. expression object. is 

a a brace-enclosed same or either initializer structure is for list expression the of an type, The 
are its bit-field and ignored, of initializers members in are order. members Unnamed not for 
structure, the members the than the trailing list If initialized. initializers fewer are there in of 
initialized with Unnamed 0. There members. not than initializers may members be are more 
are ignored,and initialized. members not are bit-field 

If an the for members. a initializer array is for array list initializers of brace-enclosed its The 
and determines of its size array, type the unknown has of number the size, initializers the 
not size, of exceed number may the the complete. becomes has array the If fixed initializers 
are there the initialized fewer, members with are of number array; the of members if trailing 
0. 

literal; may by successive initialized string characters be a As character a case, special array a 
string initialize literal successive members character the wide a of of array. the Similarly, 
size, an If unknown has (Par.A.2.6) may array of array type the wchar_t. the initialize 
null the including number of the in determines its character, string, terminating characters 
counting size the the not the if is fixed, its terminating of in characters number string, size; 
size character, not null the of exceed must array. the 

or a a the type, either initializer union is for brace-enclosed single of expression a same The 
of for the member initializer the union. first 

``first-member'' did rule to edition The of The allow is not but first initialization hard is unions. clumsy, 
least to initialized a explicitly at primitive be without generalize allowing Besides syntax. new unions in 
ANSI rule initialized. makes definite explicitly semantics not unions the way, of this static 

aggregate If contains type, aggregate of the an aggregate An or structure a is array. members 
apply recursively. if Braces may follows: elided as initialization be initialization in rules the 
a itself aggregate left an with brace, is initializer the member aggregate's an for that begins 
succeding members of list the initializes the then comma-separated initializers the of 
however, erroneous more If, members. subaggregate; it for there than to initializers be the is 
enough with brace, elements left only from a for initializer not does subaggregate a begin then 
remaining taken members any subaggregate; the list into account the for of the members are 
is initialize a which subaggregate member left the next to part. the of aggregate of the are 

example, For 



3, x[] 5 1, int = }; { 

size x with no since declares and as a members, 1-dimensional three array was initializes 
three initializers. are specified there and 



= { float y[4][3] 

3, 1, 5 }, { 

4, 2, 6 }, { 

5, 3, 7 }, { 

}; 

the 5 first array the of y[0], initialize a is 3 1, initialization: completely-bracketed and row 
lines y[0][2]. the namely y[0][0], next and y[1] and initialize Likewise two y[0][1], 
with ends elements initialized are y[2]. The early, and y[3] therefore of the 0. initializer 
achieved have been by Precisely the effect same could 

 


= { float y[4][3] 

5, 6, 3, 7 1, 3, 2, 5, 4, 

}; 

not; y therefore for does a initializer begins with for three brace, that but left y[0] The 
for the are y[1] three successively and next from elements used. are list the Likewise taken 
Also, y[2]. for 



= { float y[4][3] 

}, { 4 2 1 3 }, { { { } }, 

}; 

the as array) rest two-dimensional leaves 0. a the initializes y of column first (regarded and 

Finally, 



on msg[] line error char = %s\n"; "Syntax 

includes array with size its shows a whose members string; are a initialized the character 
character. null terminating 

names Type A.8.8 

contexts (to parameter specify type declare explicitly to cast, conversions In with several a 
supply of is the it to name sizeof) in types as and declarators, function argument necessary 
a type. declaration which syntactically accomplished a This is data for a name, type using is of 
of object name the object. of type that omitting the an 

type-name: 
abstract-declaratoropt specifier-qualifier-list 

abstract-declarator: 
pointer 
direct-abstract-declarator pointeropt 

direct-abstract-declarator: 
) abstract-declarator ( 
[constant-expressionopt] direct-abstract-declaratoropt 
(parameter-type-listopt) direct-abstract-declaratoropt 

possible to identifier identify uniquely the location where abstract-declarator the It in is the 
is the then The type a appear construction were if the in declaration. a declarator named would 
hypothetical as type same For identifier. of the example, the 



int 

* int 

*[3] int 

(*)[] int 

*() int 

(*[])(void) int 

the types integers,'' ``integer,'' ``pointer to integer,'' pointers 3 to name ``array respectively of 
an unspecified parameters number to ``function of ``pointer unspecified integers,'' returning of 
integer,'' and no ``array, of with size, functions to unspecified pointer of to pointers 
returning each an integer.'' parameters 

 
Typedef A.8.9 

declare specifier typedef Declarations whose do class instead they objects; is not storage 
called identifiers are typedef names. that types. name These identifiers define 

typedef-name: 
identifier 

the each its usual among in way name typedef A type a attributes declaration to declarators 
equivalent such name (see Par.A.8.6). is each a type to typedef syntactically Thereafter, 
associated type. the specifier for keyword 

after example, For 



Blockno, *Blockptr; typedef long 

theta; struct } r, typedef { Complex; double 



b; Blockno 

*zp; z, Complex 

of b ``pointer is long,'' long, The and legal that bp type declarations. of is are that is z to of 
such specified to a structure. structure; is zp a pointer the 

specified introduce for be could typedef does new types, that only types synonyms in not 
In the object. example, b long the any as has another same way. type 

of inner a type but set specifiers scope, names Typedef in redeclared be may an non-empty 
given. be For example, must 



redeclare not Blockno, but does 



Blockno; int extern 

does. 

Equivalence Type A.8.10 

type they same specifiers, the of taking contain type Two equivalent are lists specifier if set 
alone some by long example, into account specifiers can (for be others implied implies that 
Structures, unions, tagless and enumerations a different and distinct, with long tags int). are 
a structure, unique specifies union, or type. enumeration 

are the typedef same if any abstract expanding after their Two declarators types (Par.A.8.8), 
equivalence any the the to types, and function parameter up specifiers, same are of deleting 
types specifier parameter are significant. lists. sizes Array and function type 

Statements A.9 

are are in Except as sequence. statements for their executed executed Statements described, 
into and fall several groups. do have not values. They effect, 

 
statement: 
labeled-statement 
expression-statement 
compound-statement 
selection-statement 
iteration-statement 
jump-statement 

Statements Labeled A.9.1 

carry may label prefixes. Statements 

labeled-statement: 
statement : identifier 
: statement case constant-expression 
statement : default 

identifier of label use an declares label an identifier consisting is identifier. only The the of A 
Because of labels the function. scope a goto. The target have the is identifier of current as 
be space, with cannot and their own they do identifiers not other interfere redeclared. name 
Par.A.11.1. See 

and default constant labels are The with (Par.A.9.4). statement used Case the labels switch 
have must type. of integral case expression 

of the flow control. Labels themselves not do alter 

Statement Expression A.9.2 

the which have form Most statements expression are statements, 

expression-statement: 
expressionopt; 

side assignments function Most expression calls. are from the effects or All statements 
completed before missing, the next is is expression the statement expression executed. are If 
used called to an is the it often null body a empty construction statement; to supply is an 
a label. place iteration to statement 

Statement Compound A.9.3 

statement statements one compound the So that can be expected, used is where (also several 
is provided. statement. The body compound a a is of called function ``block'') definition 

compound-statement: 
statement-listopt } { declaration-listopt 

declaration-list: 
declaration 
declaration declaration-list 

 
statement-list: 
statement 
statement statement-list 

outer in the declaration outside the is scope an If declaration-list the in identifier was block, 
the block identifier (see Par.A.11.1), An which force. its after suspended it within resumes 
in only the apply identifiers the be once in declared same block. rules These same to may 
(Par.A.11); treated as in space spaces are name identifiers name distinct. different 

the time is top, block at and the of Initialization performed is objects automatic each entered 
is If into executed, jump block these a in proceeds the of order the declarators. the 
not performed only Initialization are objects are initializations performed. static once, of 
program the begins execution. before 

Statements Selection A.9.4 

of several flows control. Selection statements one choose of 

selection-statement: 
statement (expression) if 
statement (expression) else statement if 
statement (expression) switch 

or the must pointer which arithmetic type, expression, both In if the of forms statement, have 
the if unequal first compares 0, substatement it evaluated, is effects, side all including and to 
expression second executed is is the 0. substatement executed. is form, second the In the if 
else-less is else encountered last The else resolved by the connecting with an if ambiguity 
nesting level. block at same the 

statement causes depending control to statements transferred several of be The to switch one 
controlled of have substatement The on the an expression, type. which integral must by value 
is typically with compound. Any labeled within be may statement a the switch substatement 
more undergoes integral labels or controlling expression one case The promotion (Par.A.9.1). 
of to type. these promoted two case the and (Par.A.6.1), are constants case the converted No 
with the There same switch conversion. have after value may constants the associated same 
be at nested; switch. may default also most one be a associated a with label Switches may 
switch is with case or the label contains it. that associated smallest default 

switch statement effects, is executed, side expression all including its When is the evaluated, 
equal constant. value If compared case the the of constants one and case with the each of to is 
case to matched no If expression, control the statement label. of case the constant passes 
the and default to passes matches the if there control is label, a labeled expression, 
the case substatements then of if If matches, and no of is default, no there none statement. 
is executed. the swtich 

case edition constants, switch, the book, the of this first were controlling of expression the and In 
have to int type. required 

Statements Iteration A.9.5 

specify looping. Iteration statements 

 
iteration-statement: 
statement (expression) while 
while (expression); do statement 
expressionopt; (expressionopt; expressionopt) statement for 

as substatement repeatedly the executed long value is the In statements, do and while the so 
pointer remains expression or arithmetic of the unequal to have 0; must the type. expression 
the test, each including all before effects occurs expression, side With from while, the 
follows of test each iteration. the with statement; do, the execution 

initialization statement, evaluated specifies thus In the the first and expression once, is for for 
have its second arithmetic The must or type. loop. the restriction no is There on expression 
it is becomes is it pointer iteration, if before the evaluated 0, type; each for equal and to 
third expression re- is evaluated a each specifies thus after terminated. iteration, The and 
each loop. on from Side-effects initialization for There is type. no its restriction expression the 
immediately does not its completed the substatement are after If contain evaluation. 
statement a continue, 

expression2; (expression1; expression3) statement for 

to equivalent is 



expression1; 

{ (expression2) while 

statement 

expression3; 

} 

the three the expressions may makes dropped. expression second be Any A of missing 
a test non-zero testing implied equivalent element. to 

statements Jump A.9.6 

transfer statements control unconditionally. Jump 

jump-statement: 
identifier; goto 
continue; 
break; 
expressionopt; return 

the statement, a in located In the the identifier (Par.A.9.1) must label be current goto 
the to statement. Control labeled transfers function. 

to may iteration control causes A continue appear only It within statement. an pass statement 
loop-continuation statement. More of the enclosing such to portion smallest precisely, the 
of each the statements within 



for (...) (...) { while { { do 

... ... ... 

contin: ; ; contin: contin: ; 

while } (...); } } 

 
goto contained statement as same a continue in a the smaller is iteration contin. not 

followed the When by statement. is an return function A caller its to returns by return 
is caller function. converted, the expression as of the expression, to returned is value the The 
in type by by assignment, the the it appears. which returned function to 

a end return case, the Flowing is to a In of expression. off function either with equivalent no 
value returned is undefined. the 

Declarations External A.10 

called input a a of The C is to consists provided it unit the of translation compiler unit; 
or of declarations function definitions. external which declarations, are either sequence 

translation-unit: 
external-declaration 
external-declaration translation-unit 

external-declaration: 
function-definition 
declaration 

which external they translation in to scope declarations persists of are end the of the unit The 
of the the to end declarations just effect of as block. the persists blocks within the declared, 
that external only all except the syntax declarations is of at as of that same declarations, The 
be for functions given. this level the may code 

Definitions Function A.10.1 

have definitions the form Function 

function-definition: 
declaration-listopt compound-statement declaration-specifiersopt declarator 

storage-class are extern allowed only declaration specifiers The specifiers the or among 
distinction see between the static; Par.A.11.2 them. for 

union, return a a may A a a arithmetic but an void, function type, not pointer, structure, or 
that array. function explicitly specify function or The declarator must in declaration a the an 
forms function must the of declared identifier type; that one is, contain it (see has 
Par.A.8.6.3). 

parameter-type-list ) direct-declarator ( 
identifier-listopt ) direct-declarator ( 

direct-declarator is must an identifier it a particular, In or where parenthesized the identifier. 
a means of typedef. not achieve type function by 

 
together a and with function, parameters, their new-style the In definition the form, first is its 
declaration-list its type types, are list; in the function's following parameter the declared 
showing absent. list void, of declarator must Unless the solely parameter consists type that be 
contain no the must list the function parameters, each type declarator parameter in an takes 
be parameter called the may ends If type list the with ``, then ...'' with function identifier. 
than in the the arguments mechanism defined more parameters; macro standard va_arg 
the described be to refer header <stdarg.h> in Appendix to B used must extra and 
least Variadic must arguments. named one have functions parameter. at 

parameters, form, the the names In the the definition list is identifier old-style: while second 
parameter, attributes its given a them. declaration types to list type no is declaration If for the 
in list only the declare named list, must taken is The int. be to declaration parameters 
not possible is and is storage-class specifier initialization permitted, only register. the 

just of are declared be In both function definition, to the understood parameters after styles 
of the same compound statement the the thus and constituting the function's beginning body, 
like redeclared (although identifiers must they be identifiers, be other there may, not 
of is have type,'' to ``array the declared in redeclared a If blocks). inner parameter type 
declared type;'' a to if is have similarly, is declaration ``pointer read to adjusted to parameter 
read the is type ``function adjusted type,'' to function ``pointer declaration to returning 
necessary the the as converted returning type.'' call to are a arguments function, and During 
see Par.A.7.3.2. parameters; assigned the to 

change are in also small the function new with definitions the standard. is There ANSI a New-style 
were the the parameters float details of first edition of specified declarations that adjusted promotion; 
generated The within a is noticable read difference becomes double. a a to pointer when parameter to 
function. 

definition new-style function is A complete of example a 



b, int c) max(int int a, int 

{ 

m; int 



: ? a b; m = > (a b) 

m (m : ? return > c; c) 

} 

the the int is c) Here int declaration specifier; int max(int b, a, function's is 
The ... corresponding for function. the and } is { old- giving code the block the declarator, 
would be style definition 



b, c) int max(a, 

b, c; int a, 

{ 

*/ ... /* 

} 

c; c) declaration is now int for the list a, the where b, int and max(a, declarator, is b, 
parameters. the 

Declarations External A.10.2 

specify other identifiers. characteristics declarations functions and External the objects, The of 
refers to with their location connected functions, directly not outside term and ``external'' is 

 
empty, the externally-declared left be the extern storage class may for object an or keyword; 
extern may or as it be static. specified 

declarations for unit the same translation may same the identifier Several exist external within 
is in at identifier. agree if and there and for type definition they linkage, the most if one 

under are agree the to type rule deemed declarations Two or object an for function in 
Par.A.8.10. In an addition, if is declarations type one the discussed differ in because 
union, other is enumeration structure, and the incomplete or (Par.A.8.3) the type 
Moreover, with types agree. to corresponding completed the same taken tag, are the if type 
array an type, is completed type type incomplete array is the and other the (Par.A.8.6.2) a one 
specifies to if an Finally, type old-style agree. if types, also are identical, otherwise taken one 
the with parameter an and new-style function, function, other identical declarations, otherwise 
to agree. taken the are types 

specifier, external or static the If the declarator for includes a object function the first 
Linkage otherwise has identifier has external linkage; discussed in is it linkage. internal 
Par.11.2. 

An for external has initializer. is external an object declaration object definition it if a an An 
specifier, and contain is not extern a does that declaration an have not does initializer, the 
any a appears unit, translation tentative definition. definition for a an in object tentative If 
treated merely appears as redundant object If the for declarations. definitions no are definition 
initializer unit, become with definition in the all its single tentative a definitions 0. translation 

must have rule exactly one this For linkage, internal definition. Each objects object with 
are translation because applies separately internally-linked each to a unique unit, objects to 
to with linkage, translation unit. it objects entire program. the external applies For 

book, rule it edition this somewhat the is formulated one-definition is in first the differently of Although 
the to notion it generalizing stated effect the one identical of Some relax implementations here. by in 
recognized is UNIX as in and a usual definition. tentative formulation, alternate the In which systems 
by the object, Standard, all linked tentative externally an the common definitions extension for 
in program, together each considered of translation are all throughout of units translation the the instead 
definitions a the tentative the unit separately. definition occurs then somewhere program, in become If 
a if all become definitions merely declarations, no definition tentative appears, its then definition but 
0. initializer with 

and Linkage A.11 Scope 

may be in compiled program the files kept several source at A all need time: not one be text 
loaded translation be from libraries. units, precompiled and routines may containing 
calls functions be through both Communication among of a out program carried may and the 
of manipulation external data. through 

of to the an first, scope identifier consider: there Therefore, of kinds two are scope lexical 
the region are of the characteristics text identifier's the program which within is which 
functions scope with understood; and objects the external linkage, with associated and second, 
compiled determines separately translation units. the between connections identifiers in which 

Scope Lexical A.11.1 

 
the several not another; one Identifiers fall name spaces with that interfere do same into 
uses used are scope, the purposes, may for different be in in same the even if identifier 
spaces. names, and classes name functions, typedef different These objects, enum are: 
and structures unions, constants; labels; and of of each members or enumerations; tags 
union individually. structure or 

of ways Labels from rules the not manual. did first those These several differ in in described this edition 
unions own each in their previously of and space; space, name separate have tags and had structures a 
the putting of same kinds into space different implementations some as did tags enumerations well; tags 
first restriction. edition union new is departure the most structure The each a important or is from that 
the name same different separate creates members, that for in space appear a its several name so may 
practice This has structures. several for been rule years. common 

begins function an at in declaration the identifier lexical The object an of scope or external 
the declarator translation The its end the of persists it and which of to appears. unit end in 
block parameter defining start the function of of a a the begins the at definition of scope 
function through of a in function, and the function; parameter the a scope declaration persists 
at the of declarator. at an block head a identifier The ends of the of end scope the declared 
a declarator, the and The persists end scope at of end of the the of begins to is label block. its 
union, the or of structure, which whole function in of enumeration appears. scope The it a the 
persists enumeration to type and at or constant, begins an the appearance a in its specifier, tag, 
the (for the declarations of level) (for of block or at end unit a external translation the end to 
a function). declarations within 

block is constituting block, the at an explicitly declared identifier a head a of the including If 
end the suspended of is the the block any function, identifier the of declaration outside until 
block. 

Linkage A.11.2 

translation unit, with all declarations identifier the function or of Within same a object 
to to that function unique thing, linkage the same refer translation the or object and is internal 
refer for function linkage external unit. All the same with object identifier or to declarations 
thing, and program. the object entire function the by or the is same shared 

in Par.A.10.2, identifier the first the declaration gives identifier external As for discussed an 
declaration the external a If internal linkage static specifier otherwise. is linkage used, for if 
identifier include specifier, has extern the no the identifier an does block a within not then 
an If include external does and declaration it and linkage the to unique is function. extern, 
the in identifier the active for the then scope linkage the same is surrounding as has block, the 
external object but declaration function; no is or declaration, external the to refers and same if 
linkage its is external. visible, 

Preprocessing A.12 

inclusion preprocessor and of named performs substitution, macro conditional compilation, A 
space, #, preceded files. Lines by with with this communicate perhaps white beginning 
language; independent rest they the the may of The preprocessor. lines these of syntax is of 
of have of end the appear anywhere effect that until lasts scope) (independent the and 
analyzed are each translation unit. line boundaries (bus see individually significant; is Line 
token, to or is language To for adjoin lines). how a preprocessor, token a the any Par.A.12.2 
giving a addition, file name in in (Par.A.12.4); directive as character the sequence #include 

 
of as However, white token. effect spaces a character any is defined otherwise not taken the 
within than undefined preprocessor lines. space horizontal and tab is other 

takes place particular in several a successive in may, logically Preprocessing phases itself that 
condensed. be implementation, 

sequences by their described trigraph are replaced First, as Par.A.12.1 equivalents. in 
characters the newline are introduced operating environment system require it, Should 
the of file. the source lines between 
of a this backslash character deleted, followed is newline \ Each by occurrence a 
(Par.A.12.2). lines splicing 
is characters; comments into program by white-space The split separated are tokens 
a obeyed, and space. by directives are replaced single preprocessing macros Then 
expanded. are (Pars.A.12.3-A.12.10) 
(Pars. character and 4. Escape string in A.2.6) are A.2.5.2, constants literals sequences 
string by equivalents; replaced are literals then their concatenated. adjacent 


result is by translated, then libraries, together and programs linked 5. with The other 
external the connecting functions and necessary and programs data, and collecting 
to references their definitions. object 

Sequences Trigraph A.12.1 

is is seven-bit a within but superset contained character The source C of set programs ASCII, 
represented 646-1983 in programs be Set. the Invariant Code ISO the order enable to In to of 
are of following reduced set, trigraph occurrences by the replaced the sequences all 
before single This corresponding other any replacement character. processing. occurs 



??< { [ ??= ??( # 

??> } ] ??/ ??) \ 

??- ~ | ??' ??! ^ 

the sequences ANSI with Trigraph are standard. new 

Splicing Line A.12.2 

backslash \ by and folded the the are that Lines backslash the with end character deleting 
into before division tokens. following newline This character. occurs 

Definition Macro and Expansion A.12.3 

the form of A line control 

identifier token-sequence # define 

identifier replace instances causes the of to the given with subsequent the preprocessor 
tokens; leading discarded. and trailing is space sequence token white sequence around of the 
sequence for erroneous token second A second the same the identifier unless is is #define 
the first, equivalent. where all be space to taken white identical separations to are 

of line the form A 

identifier define (identifier-list) token-sequence # 

 
macro no definition (, a the there space between is with identifier the and first is where 
trailing with form, white first and space the given parameters list. identifier the by As leading 
with sequence macro only redefined arround the is discarded, be and may the a token 
which the is number and sequence, of token the spelling definition parameters, in and 
identical. 

the form of A line control 

identifier undef # 

identifier's preprocessor apply definition to to forgotten. erroneous not be causes It the is 
an to unknown identifier. #undef 

of the subsequent the form, instances macro second a When defined been has macro in textual 
tokens then a separated (, of by by followed identifier space, white optional by and sequence 
The ) arguments comma- a commas, of macro. a are constitute call and call the of the the 
sequences; commas not that are do or parentheses nested quoted separated protected token by 
The arguments. macro-expanded. number of During arguments collection, are not separate 
After call of definition. the arguments in must match in the parameters number the the 
isolated, leading the and trailing Then space them. from white arguments is are removed 
each each is token sequence substituted from occurrence of unquoted argument for resulting 
parameter's of the in corresponding token sequence the identifier replacement macro. the 
or in preceded preceded or Unless the the replacement #, sequence by is followed parameter 
necessary, argument macro as expanded by ##, tokens are and examined calls, for just the 
insertion. before 

an the process. Two special First, influence of a occurrence replacement if operators 
the replacement (") token sequence quotes immediately string #, is parameter preceded in by 
around the parameter corresponding parameter, the then and # and are both placed the 
" by or inserted each argument. are the quoted replaced \ \ is character A before identifier 
appears surrounding, the or inside, in string constant character a character literal that or 
argument. 

## either macro operator, of a then kind if Second, sequence token definition the for contains 
white ## together space deleted, any on is after just parameters, the of replacement each with 
The as effect a token. the side, to concatenate so is tokens form and adjacent new either 
of tokens processing on order or if are produced, invalid of the depends result if the undefined 
a Also, replacement or of not ## ## may operators. token at beginning the appear end the 
sequence. 

kinds of more macro, the for token rescanned repeatedly replacement In sequence both is 
However, once expansion, a given given has a in identifier defined been identifiers. replaced 
is up rescanning; left during it unchanged. again is it it if replaced not turns instead 

expansion of a it taken to final not value with be #, if Even with the a is macro begins 
directive. preprocessing 

standard described in than precisely ANSI in more details The process macro-expansion the of are the 
of The the make edition. the is addition important operators, most ## first change which # the and 
concatenation especially those Some and new rules, quotation admissible. the involving of 
example below.) (See concatenation, bizarre. are 

 
``manifest-constants,'' example, for as in this may facility be used For 



100 TABSIZE #define 

table[TABSIZE]; int 

definition The 



(a)-(b) ABSDIFF(a, : ? #define b) (b)-(a)) ((a)>(b) 

arguments. value difference Unlike the its a of a defines the return to macro absolute between 
any arguments value arithmetic returned have type and to function thing, same the do the may 
evaluated pointers. might are effects, or even Also, the side arguments, have which twice, be 
to for test once the produce and the value. once 

definition the Given 



#dir "%s" #define tempfile(dir) 

call macro tempfile(/usr/tmp) yields the 



"%s" "/usr/tmp" 

a will be which string. single catenated subsequently After into 



## y x #define y) cat(x, 

cat(var, cat(cat(1,2),3) is yields call the call the 123) However, undefined: var123. 
expanded. of call Thus outer being it the presence the the prevents ## of arguments from 
token string produces the 



2 )3 , cat 1 ( 

the the of last )3 first second) token the argument token and of (the the catenation of first with 
a legal introduced, token. If is second definition macro a is level not of 



y) cat(x,y) #define xcat(x, 

more 123, because xcat(xcat(1, work does produce things smoothly; 3) the 2), 
involve of itself expansion ## the does xcat operator. not 

expected, the result. ABSDIFF(ABSDIFF(a,b),c) fully-expanded produces Likewise, 

Inclusion File A.12.4 

the form of A line control 

<filename> include # 

filename. the of The contents file characters entire the causes line that of replacement by the 
and filename the contains name in > newline, not if must undefined the include it effect or is 
is ', searched implementation-defined ", any The file or sequence \, a of /*. of for named in 
places. 

of line form a the control Similarly, 

"filename" include # 

 
in (a deliberately with first source file searches association original implementation- the 
as search fails, The using ', if of that the \, form. phrase), dependent first and or effect then in 
but in filename /* is > remains the permitted. undefined, 

the form of Finally, directive a 

token-sequence include # 

sequence is expanding as by token for interpreted matching not previous the of one forms the 
"..." of must as one normal with or two then the is text; forms treated result, <...> and 
described. previously 

may files be nested. #include 

Compilation Conditional A.12.5 

to may compiled Parts of conditionally, program following schematic the be according a 
syntax. 

preprocessor-conditional: 
elif-parts text else-partopt #endif if-line 

if-line: 
constant-expression if # 
identifier ifdef # 
identifier ifndef # 

elif-parts: 
text elif-line 
elif-partsopt 

elif-line: 
constant-expression elif # 

else-part: 
text else-line 

else-line: 
#else 

line. directives #endif) a on Each of (if-line, elif-line, alone else-line, appears and The the 
in #if an and subsequent until lines order in #elif constant are expressions evaluated 
value non-zero is with zero found; with value is a discarded. following line a text a expression 
to the treated refers here The text successful directive ``Text'' line normally. is any following 
may lines, of it structure; material, including that is conditional not the part be preprocessor 
text line found processed, been its succeeding has Once empty. or #if successful a #elif and 
expressions text, If are discarded. the zero, are and #elif with together lines, #else their all 
Text following is controlled #else normally. by the there and the #else, an is text treated 
of the conditionals. conditional is of except nesting the ignored inactive for arms checking 

 
to #if #elif The constant is in macro replacement. ordinary and subject expression 
the form of Moreover, expressions any 

identifier defined 

or 

(identifier) defined 

constant expression not (Par.A.7.19) is may it and integral, restricted: The must resulting be 
an sizeof, enumeration or contain a constant. cast, 

lines control The 

identifier #ifdef 
identifier #ifndef 

to equivalent are 

defined identifier # if 
! if defined identifier # 

respectively. 

some although been preprocessors. has is The it is #elif first the since new edition, available 
also new. is defined operator preprocessor 

Control Line A.12.6 

of of the line one that the other preprocessors benefit forms C a programs, generate in For 

constant "filename" # line 
constant line # 

number of that of diagnostics, line the error the causes for believe, to compiler purposes the 
and is the by line next decimal constant by is given file source the named current integer input 
change. the the not does the identifier. quoted filename name is remembered absent, Macros If 
is before it interpreted. in the are line expanded 

Generation Error A.12.7 

the form of A line preprocessor 

token-sequenceopt error # 

includes write diagnostic causes the message to token sequence. the a that preprocessor 

 
Pragmas A.12.8 

the form of A line control 

token-sequenceopt pragma # 

implementation-dependent the to causes An action. perform preprocessor unrecognized an 
ignored. is pragma 

directive Null A.12.9 

the form of A line control 

# 

effect. no has 

names Predefined A.12.10 

information. and to Several identifiers produce predefined, and also They, expand special are 
undefined preprocessor be or redefined. expansion defined, operator may not the 

__LINE__ 

line current source number. A decimal containing constant the 

__FILE__ 

file string the being compiled. literal the containing name of A 

__DATE__ 

literal containing yyyy" the date dd compilation, "Mmmm form of A in string the 

__TIME__ 

literal the form the string compilation, in A containing of "hh:mm:ss" time 

__STDC__ 

only It in to 1 that constant is intended 1. standard- identifier defined be this be The 
implementations. conforming 

are are standard; macros preprocessor #error and new with predefined the the ANSI new, #pragma 
available some them but some in have of implementations. been 

Grammar A.13 

part that throughout of given earlier this was is Below the of recapitulation a grammar the 
has in different the It but is appendix. exactly content, order. same 

character-constant, symbols integer-constant, floating- The grammar undefined has terminal 
typewriter identifier, and constant, words style enumeration-constant; string, and the 
terminals transformed mechanically literally. are can be symbols given grammar into This 
Besides acceptable an input whatever adding automatic for syntactic parser-generator. 
the productions, necessary ``one is expand of'' it is marking alternatives indicate to used in to 
(depending to duplicate the and the parser-generator) constructions, on of each rules 
one opt symbol With without. production with symbol, once once with and the further an 
making namely and typedef-name a deleting production the typedef-name: identifier change, 
this grammar one is acceptable only the has It to terminal YACC symbol, parser-generator. 
if-else ambiguity. the conflict, by generated 

translation-unit: 
external-declaration 
external-declaration translation-unit 

 
external-declaration: 
function-definition 
declaration 

function-definition: 
declaration-listopt compound-statement declaration-specifiersopt declarator 

declaration: 
init-declarator-listopt; declaration-specifiers 

declaration-list: 
declaration 
declaration declaration-list 

declaration-specifiers: 
declaration-specifiersopt storage-class-specifier 
declaration-specifiersopt type-specifier 
declaration-specifiersopt type-qualifier 

one of storage-class specifier: 
static register extern typedef auto 

one of type specifier: 
float char double long void short signed int 
enum-specifier typedef-name unsigned struct-or-union-specifier 

of one type-qualifier: 
volatile const 

struct-or-union-specifier: 
{ identifieropt struct-declaration-list } struct-or-union 
identifier struct-or-union 

of one struct-or-union: 
union struct 

struct-declaration-list: 
declaration struct 
declaration struct struct-declaration-list 

init-declarator-list: 
init-declarator 
init-declarator init-declarator-list, 

init-declarator: 
declarator 
initializer = declarator 

struct-declaration: 
struct-declarator-list; specifier-qualifier-list 

 
specifier-qualifier-list: 
specifier-qualifier-listopt type-specifier 
specifier-qualifier-listopt type-qualifier 

struct-declarator-list: 
struct-declarator 
struct-declarator , struct-declarator-list 

struct-declarator: 
declarator 
constant-expression : declaratoropt 

enum-specifier: 
{ identifieropt enumerator-list } enum 
identifier enum 

enumerator-list: 
enumerator 
enumerator , enumerator-list 

enumerator: 
identifier 
constant-expression = identifier 

declarator: 
direct-declarator pointeropt 

direct-declarator: 
identifier 
(declarator) 
constant-expressionopt ] direct-declarator [ 
parameter-type-list ) direct-declarator ( 
identifier-listopt ) direct-declarator ( 

pointer: 
type-qualifier-listopt * 
pointer type-qualifier-listopt * 

type-qualifier-list: 
type-qualifier 
type-qualifier type-qualifier-list 

parameter-type-list: 
parameter-list 
... , parameter-list 

parameter-list: 
parameter-declaration 
parameter-declaration , parameter-list 

 
parameter-declaration: 
declarator declaration-specifiers 
abstract-declaratoropt declaration-specifiers 

identifier-list: 
identifier 
identifier , identifier-list 

initializer: 
assignment-expression 
} initializer-list { 
, } { initializer-list 

initializer-list: 
initializer 
initializer , initializer-list 

type-name: 
abstract-declaratoropt specifier-qualifier-list 

abstract-declarator: 
pointer 
direct-abstract-declarator pointeropt 

direct-abstract-declarator: 
) abstract-declarator ( 
[constant-expressionopt] direct-abstract-declaratoropt 
(parameter-type-listopt) direct-abstract-declaratoropt 

typedef-name: 
identifier 

statement: 
labeled-statement 
expression-statement 
compound-statement 
selection-statement 
iteration-statement 
jump-statement 

labeled-statement: 
statement : identifier 
: statement case constant-expression 
statement : default 

expression-statement: 
expressionopt; 

compound-statement: 
statement-listopt } { declaration-listopt 

 
statement-list: 
statement 
statement statement-list 

selection-statement: 
statement (expression) if 
statement (expression) else statement if 
statement (expression) switch 

iteration-statement: 
statement (expression) while 
while (expression); do statement 
expressionopt; (expressionopt; expressionopt) statement for 

jump-statement: 
identifier; goto 
continue; 
break; 
expressionopt; return 

expression: 
assignment-expression 
assignment-expression , expression 

assignment-expression: 
conditional-expression 
assignment-expression assignment-operator unary-expression 

of one assignment-operator: 
&= *= >>= ^= |= /= += %= -= <<= = 

conditional-expression: 
logical-OR-expression 
expression ? : conditional-expression logical-OR-expression 

constant-expression: 
conditional-expression 

logical-OR-expression: 
logical-AND-expression 
logical-AND-expression || logical-OR-expression 

logical-AND-expression: 
inclusive-OR-expression 
inclusive-OR-expression && logical-AND-expression 

inclusive-OR-expression: 
exclusive-OR-expression 
exclusive-OR-expression | inclusive-OR-expression 

 
exclusive-OR-expression: 
AND-expression 
AND-expression ^ exclusive-OR-expression 

AND-expression: 
equality-expression 
equality-expression & AND-expression 

equality-expression: 
relational-expression 
relational-expression == equality-expression 
relational-expression != equality-expression 

relational-expression: 
shift-expression 
shift-expression < relational-expression 
shift-expression > relational-expression 
shift-expression <= relational-expression 
shift-expression >= relational-expression 

shift-expression: 
additive-expression 
additive-expression << shift-expression 
additive-expression >> shift-expression 

additive-expression: 
multiplicative-expression 
multiplicative-expression + additive-expression 
multiplicative-expression - additive-expression 

multiplicative-expression: 
cast-expression * multiplicative-expression 
cast-expression / multiplicative-expression 
cast-expression % multiplicative-expression 

cast-expression: 
expression unary 
cast-expression (type-name) 

unary-expression: 
expression postfix 
expression ++unary 
expression --unary 
cast-expression unary-operator 
unary-expression sizeof 
(type-name) sizeof 

one of unary operator: 
~ ! - & + * 

postfix-expression: 
primary-expression 

 
postfix-expression[expression] 
postfix-expression(argument-expression-listopt) 
postfix-expression.identifier 
postfix-expression->+identifier 
postfix-expression++ 
postfix-expression-- 

primary-expression: 
identifier 
constant 
string 
(expression) 

argument-expression-list: 
assignment-expression 
assignment-expression , assignment-expression-list 

grammar for is the preprocessor but the lines, control summarizes The structure following of 
text, parsing. includes not suitable the mechanized means ordinary which It symbol for 
complete lines, or preprocessor program text, preprocessor non-conditional control 
instructions. conditional 

control-line: 
identifier token-sequence # define 
, ... token-sequence define identifier) identifier(identifier, # 
identifier undef # 
<filename> include # 
"filename" include # 
constant "filename" # line 
constant line # 
token-sequenceopt error # 
token-sequenceopt pragma # 
# 
preprocessor-conditional 

preprocessor-conditional: 
elif-parts text else-partopt #endif if-line 

if-line: 
constant-expression if # 
identifier ifdef # 
identifier ifndef # 

elif-parts: 
text elif-line 
elif-partsopt 

 
elif-line: 
constant-expression elif # 

else-part: 
text else-line 

 


- B Standard Library Appendix 

The library the standard by standard. library defined appendix This of summary a is the ANSI 
C of will that standard language not the C part provide but environment an proper, supports is 
omitted and of have We the function type and library. macro this definitions a declarations 
have are easily we others; few functions of limited from utility synthesized or omitted that 
and we that have omitted properties of is, that discussion multi-byte locale characters; issues; 
nationality, language, culture. on or local depend 



<math.h> <float.h> <stdarg.h> <stdlib.h> <assert.h> 

<setjmp.h> <limits.h> <stddef.h> <string.h> <ctype.h> 

<signal.h> <locale.h> <stdio.h> <time.h> <errno.h> 

accessed by be A can header 

<header> #include 

must included be times. header order may in any be included any of number and A Headers 
it and use declares. any anything A before of outside or declaration external any definition of 
a be file. need source not header 

as begin are by library, underscore identifiers with an that all reserved use for are the External 
that begin underscore. with an another and or letter underscore other an identifiers upper-case 

and Input Output: <stdio.h> B.1 

and output one functions, types, nearly macros represent <stdio.h> and The defined input in 
the library. third of 

may a be other is A of that or disk source a stream destination or associated data with 
although text and peripheral. The binary supports some systems, on streams streams, library 
sequence are of or these notably stream a A has identical. line UNIX, text zero lines; is each 
a An need text may convert stream environment characters more by terminated is and '\n'. to 
and some mapping return carriage to or other representation to (such '\n' as linefeed). from 
with unprocessed record the that data, property bytes binary A sequence a is stream of internal 
will back same compare the it equal. on if that then written, is it read system, 

opening connected it; closing is A or by a broken to is stream file by the device connection 
which a records of FILE, a stream. file returns Opening whatever to object an pointer type the 
necessary to ``stream'' control the and We pointer'' ``file stream. information will is use 
no ambiguity. is interchangeably there when 

program begins already execution, the are streams stderr and three When stdin, a stdout, 
open. 

Operations File B.1.1 

 
functions deal unsigned with operations the files. is size_t on The The following type 
the by operator. type sizeof produced integral 

const *filename, *mode) *fopen(const char char FILE 

attempt a NULL fails. or the Legal stream, opens fopen and file, named the returns if 
mode include: values for 

"r" 

file text for reading open 

"w" 

previous text for create if contents writing; file any discard 

"a" 

or end of text open writing at append; create for file file 

"r+" 

and (i.e., reading writing) open text for file update 

"w+" 

previous text for create if contents update, file any discard 

"a+" 

writing open update, at end or text create file for append; 

fflush and the Update mode same reading a file-positioning or writing file; permits 
the called mode vice If read must between a be includes a or write and versa. function 
file. initial Filenames indicates binary in after letter, as the are or that "w+b", "rb" a b 
be At FOPEN_MAX limited to files characters. at once. open most may FILENAME_MAX 

FILE char *mode, *stream) FILE *freopen(const *filename, char const 

it. file and with stream freopen opens with the the specified associates mode It the 
change NULL freopen to used returns stream, if an normally error is occurs. the or 
stdout, stdin, stderr. associated or with files 

*stream) fflush(FILE int 

written; stream, but be to On an fflush causes data any unwritten buffered on output 
error, It for and EOF write zero returns input an is effect the stream, undefined. a 
output streams. all otherwise. flushes fflush(NULL) 

*stream) fclose(FILE int 

any unread buffered data flushes discards any fclose unwritten stream, input, for 
automatically allocated any buffer, then if the EOF returns closes frees stream. any It 
and occurred, zero otherwise. errors 

char *filename) int remove(const 

will a to fail. attempt it It subsequent removes remove so file, named the that open 
attempt fails. the returns if non-zero 

the name fails. of a attempt it the if file; rename returns changes non-zero 

*tmpfile(void) FILE 

will file mode tmpfile creates "wb+" temporary automatically removed be of that a 
returns the terminates when closed normally. when stream, or a program tmpfile or 
create if the not NULL it file. could 

s[L_tmpnam]) *tmpnam(char char 

and the an returns of file, a name creates tmpnam(NULL) is that string a not existing 
well stores in as string as returning the to pointer array. static internal an tmpnam(s) s 
characters. function room L_tmpnam least it as value; s at must for have tmpnam the 
names name called; different TMP_MAX generates a each time most it at is are different 
execution of a the program. not that name, a Note guaranteed tmpnam during creates 
file. 

size_t int mode, size) int setvbuf(FILE char *stream, *buf, 

buffering for or the stream; writing must reading, before it setvbuf be controls called 
operation. A of mode of buffering causes line _IOLBF _IOFBF any full other buffering, 
NULL, _IONBF it buffer, and text buf not buffering. as no used files, If the will is be 
buffer be size otherwise a determines will setvbuf returns size. allocated. the buffer 
any error. non-zero for 

*stream, setbuf(FILE char *buf) void 

 
is NULL, for setbuf Otherwise, If buf buffering is stream. turned the off equivalent is 
_IOFBF, BUFSIZ). buf, to setvbuf(stream, (void) 

Output Formatted B.1.2 

formatted provide conversion. printf output functions The 



char const ...) fprintf(FILE *format, *stream, int 

return writes the The format. fprintf converts output to of stream control under value and 
number an error characters the negative if is of or occurred. written, 

to contains ordinary copied are The format two types which of characters, objects: the string 
conversion specifications, of output stream, which conversion printing of and each causes and 
successive begins with to next conversion specification the argument Each the fprintf. 
conversion ends Between the and character % with a % conversion the character. character and 
be, may in order: there 

the which modify specification:  Flags any (in order), 

argument left of o -, the specifies its field. in adjustment converted which 

which specifies sign. that the a will with printed number o always +, be 

be the a will space o space: first character a is sign, not prefixed. if 

field conversions, padding o 0: to numeric with leading width specifies the for 
zeros. 

will specifies For digit first o #, an alternate the output o, form. become which 
will 0x or non-zero e, E, or For X, prefixed f, a For zero. to x g, result. 0X be 
G, a for trailing point; and zeros decimal G, and always will output the have g 
be removed. will not 

number specifying printed a minimum be width. will argument field  The A converted 
converted and necessary. argument if the has wider a in this least at field wide, If 
right, the if the (or it characters field width than left be on padded will left fewer 
been requested) is to make character the padding The up adjustment field has width. 
but flag is 0 space, zero padding normally is the present. if 

from A width the precision. period, separates which the field  

number, the be precision, that to the characters of specifies  maximum A number 
decimal string, point printed the number from or the a for digits be to of after printed 
digits f for the or e, number significant or conversion, conversions, G E, the or g of or 
0s to will the digits number an (leading printed make be to of for up be integer added 
width). necessary 

the ell), ``h'' corresponding L. that argument or A  l h, modifier length (letter indicates 
argument printed is indicates the short to as a be a unsigned ``l'' short; or that is 
is ``L'' that long or the long, long double. a indicates argument unsigned 

in or which by precision Width specified *, may is both value or be computed case as the 
must the be which converting next int. argument(s), 

character and in the If The conversion their meanings B.1. are Table shown after characters 
behavior % the is undefined. is a not conversion character, the 

Printf Conversions Table B.1 

Character 

Printed As Argument type; 

 
d,i 

decimal notation. int; signed 

o 

a unsigned leading (without int; octal zero). notation 

x,X 

0x int; leading or 0X), unsigned notation hexadecimal (without a unsigned 
ABCDEF abcdef for or using for 0X. 0x 

u 

decimal notation. int; unsigned 

c 

to single unsigned conversion int; character, char after 

s 

or printed '\0' until a reached the until *; char string the from characters are is 
precision of indicated number been have by characters printed. the 

f 

number the [-]mmm.ddd, double; decimal where of d's is of form the notation 
suppresses precision. 6; 0 of given by The default precision precision a is the the 
point. decimal 

e,E 

or form [-]m.dddddde+/-xx [-]m.ddddddE+/- double; decimal of notation the 
precision number by default The xx, where of d's precision. is the specified is the 
decimal suppresses the point. 6; a of precision 0 

g,G 

or used or if %e less to than equal than the double; is or is %E exponent greater -4 
otherwise %f are is used. point zeros decimal trailing Trailing the and precision; a 
printed. not 

p 

pointer *; (implementation-dependent a void print representation). as 

n 

printf so this is by to written far *; int characters of number the written call 
argument No converted. the is argument. into 

% 

print converted; % argument a is no 

char printf(const *format, ...) int 

fprintf(stdout, ...). to printf(...) equivalent is 

char const ...) sprintf(char *format, *s, int 

the that is string output into s, the is sprintf printf as same the except written 
return enough the count hold The does to with terminated be must s '\0'. big result. 
the '\0'. not include 

va_list arg) *format, int char vprintf(const 
*format, vfprintf(FILE va_list char int *stream, arg) const 
*format, vsprintf(char va_list char int *s, arg) const 

to functions equivalent the corresponding vprintf, and vfprintf, vsprintf are The 
except that has the variable which list arg, by argument printf is functions, replaced 
calls. va_start and been initialized perhaps the the discussion See macro va_arg by 
in <stdarg.h> Section B.7. of 

Input Formatted B.1.3 

formatted scanf input with The function conversion. deals 



char const ...) fscanf(FILE *format, *stream, int 

assigns under of fscanf reads format, stream values through converted control and from 
is of pointer. format when subsequent arguments, which must returns be It a exhausted. each 
otherwise if it before conversion; file returns end of EOF returns an occurs error or any fscanf 
converted number and items the of assigned. input 

string used to contains format which are The usually specifications, direct conversion 
string of may format interpretation input. contain: The 

are Blanks not which  or ignored. tabs, 

 
characters (not space %), which non-white expected next the are  to Ordinary match 
the of input stream. character 

optional Conversion an assignment suppression specifications, of consisting a %,  
l, optional field h, optional character *, number specifying an a width, maximum or an 
a indicating and conversion character. the of width the target, L 

input the of A conversion the determines Normally the field. conversion next specification 
placed in assignment the variable If to argument. corresponding pointed result by is the 
simply %*s, input skipped; the is no however, is suppression as *, by indicated in field 
space defined string characters; a non-white it as is assignment field input An made. is of 
if character the specified, until width, is or either extends white next the to space field 
input, that line its find exhausted. This scanf will to read boundaries across since implies 
tab, (White characters newlines are are space. carriage return, newline, space blank, white 
and formfeed.) vertical tab, 

character field. The the conversion the input The indicates of corresponding interpretation 
be a B.2. pointer. The Table conversion in shown legal argument characters must are 

and n, o, by the argument d, if i, may is preceded conversion The be characters a h u, x 
l int, or argument pointer to rather a than ell) long. the to pointer if short The is by (letter 
l f, if than e, conversion be by g double and to characters may rather a preceded pointer 
a by a long if to double. L is float list, argument the in and pointer 

Scanf Conversions Table B.2 

Character 

Argument type Input Data; 

d 

int* integer; decimal 

i 

The integer 0x may be (leading octal hexadecimal or in integer; (leading int*. 0) 
0X). or 

o 

int leading zero); *. octal integer or (with without 

u 

int *. unsigned unsigned integer; decimal 

x 

0x integer or hexadecimal 0X); or without (with int*. leading 

c 

the input are characters; char*. placed next array, up indicated characters in The 
is given added. 1. '\0' width the by the number The the is default field; No to 
the white in read to normal skip space characters case; is this suppressed next over 
character, space use %1s. non-white 

s 

non-white space of characters (not array char an to quoted); string *, of pointing 
enough to be hold the will and that '\0' string characters a large terminating 
added. 

e,f,g 

is The format floating-point number; for *. optional sign, an input float's float 
and possibly a a string decimal numbers optional exponent an containing point, of 
an possibly signed or containing by a field E followed integer. e 

p 

printf("%p");, value void by pointer as *. printed 

n 

call; characters far int so this *. read into writes number the argument the of by 
is input count not incremented. is The read. converted item No 

[...] 

longest the set string the characters from matches non-empty input between of 
] '\0' added. brackets; char []...] A the set. in is includes *. 

 
[^...] 

from string input matches the characters non-empty set between the of not longest 
] '\0' added. brackets; char [^]...] A the set. in is includes *. 

% 

is made. assignment literal no %; 

char scanf(const *format, ...) int 

fscanf(stdin, ...). to scanf(...) identical is 

char sscanf(const *format, const int char ...) *s, 

is input characters to ...) that the sscanf(s, equivalent except are scanf(...) 
the from string s. taken 

Output Functions and B.1.4 Input Character 

*stream) fgetc(FILE int 

the next an character of to as (converted char stream fgetc an returns unsigned 
file or if int), error or end EOF occurs. of 

n, int *stream) *fgets(char FILE *s, char 

a most newline s, if n-1 reads the next at is into array the characters stopping fgets 
newline is fgets included in '\0'. array, by terminated the encountered; which the is 
or s, file error occurs. or if NULL end of returns 

c, fputc(int FILE *stream) int 

the character returns c (converted It an stream. on to fputc unsigend writes char) 
EOF or error. character for written, the 

FILE *stream) *s, int char fputs(const 

returns string contain it stream; fputs writes s (which on need \n) not non- the 
an error. for negative, EOF or 

*stream) getc(FILE int 

evaluate to stream macro, may that is fgetc except equivalent more it a is if it getc 
once. than 

getchar(void) int 

equivalent is to getc(stdin). getchar 

*s) *gets(char char 

terminating the it newline s; the with array reads gets line input next the into replaces 
file or if '\0'. It end s, error occurs. or NULL of returns 

c, putc(int FILE *stream) int 

evaluate to stream macro, may that is fputc except equivalent more it a is if it putc 
once. than 

c) putchar(int int 

equivalent is to putc(c,stdout). putchar(c) 

char *s) int puts(const 

an string error returns if a writes s and the occurs, to It stdout. newline EOF puts 
otherwise. non-negative 

c, ungetc(int FILE *stream) int 

will (converted back it where ungetc pushes to an stream, unsigned onto char) be c 
the next guaranteed. read. Only is character stream per one returned of on pushback 
EOF be the or back, EOF may pushed back. pushed ungetc character returns for not 
error. 

Output Functions and B.1.5 Input Direct 

size ptr nobj size. most of fread at reads fread the into stream from array objects 
requested. of be number the returns the objects read; than this less may feof number 
to ferror determine used and must status. be 

size_t fwrite(const *ptr, size_t FILE nobj, size_t void *stream) size, 

 
It objects size returns size stream. the of writes, fwrite ptr, array the from nobj on 
nobj of than on error. objects which written, is less number 

Positioning Functions B.1.6 File 

offset, long origin) fseek(FILE int *stream, int 

access file subsequent will write fseek sets position for or stream; read a data the 
to new file, set is beginning at position. For position a the binary offset the 
SEEK_SET from which characters SEEK_CUR (beginning), may origin, (current be 
or (end a must zero, For or of file). SEEK_END value text offset stream, a be position), 
SEEK_SET). which origin returned by must (in returns non-zero fseek case be ftell 
error. on 

*stream) ftell(FILE long 

the -1 on file returns stream, or ftell current for error. position 

*stream) rewind(FILE void 

0L, is SEEK_SET); fseek(fp, rewind(fp) equivalent clearerr(fp). to 

*stream, fgetpos(FILE fpos_t *ptr) int 

for position stream fgetpos records in current use by subsequent in *ptr, the 
values. is for fsetpos. The recording fpos_t returns non- fgetpos suitable such type 
error. on zero 

fpos_t *ptr) const int *stream, fsetpos(FILE 

stream in *ptr. the positions by fgetpos fsetpos at recorded fsetpos position 
on error. returns non-zero 

Functions Error B.1.7 

when functions error These the Many set indicators the file in of of library occur. or status end 
be set (declared and tested errno In expression integer explicitly. indicators addition, may the 
may contain most an error the that about information number in gives <errno.h>) further 
error. recent 

*stream) clearerr(FILE void 

indicators clears error for stream. the of end file and clearerr 

*stream) feof(FILE int 

for the of feof returns file if is set. stream end indicator non-zero 

*stream) ferror(FILE int 

stream returns for is set. non-zero the if error indicator ferror 

char *s) void perror(const 

error prints and perror(s) corresponding message an s to implementation-defined 
as errno, by integer if in the 

"error message"); s, fprintf(stderr, %s\n", "%s: 

in strerror Section B.3. See 

Class Character Tests: <ctype.h> B.2 

<ctype.h> each function, functions header characters. For The declares testing the for 
unsigned an char, representable an value list int, whose is and be or EOF must as argument 
c is satisfies if argument The return an int. value the return (true) non-zero functions the the 
if not. zero condition and described, 

isalnum(c) 

isdigit(c) or is true isalpha(c) 

isalpha(c) 

islower(c) or is true isupper(c) 

 
iscntrl(c) 

character control 

isdigit(c) 

digit decimal 

isgraph(c) 

except space printing character 

islower(c) 

letter lower-case 

isprint(c) 

including space printing character 

ispunct(c) 

letter character or or printing except digit space 

isspace(c) 

tab, formfeed, vertical return, space, newline, tab carriage 

isupper(c) 

letter upper-case 

isxdigit(c) 

digit hexadecimal 

to printing 0x20 0x7E are ') ('-'); characters the In set, character ASCII seven-bit the (' 
characters and 0x7F 0 control 0x1F (US), the are to (DEL). NUL 

there case of two addition, convert the In are that letters: functions 

tolower(c) int 

to c lower case convert 

toupper(c) int 

to c upper case convert 

is corresponding lower-case upper-case c returns the If an tolower(c) letter, letter, 
otherwise returns corresponding toupper(c) returns it upper-case the c. letter; 

Functions: <string.h> B.3 String 

first groups in The <string.h>. There are of string header functions the defined have two 
with str; memmove, the second for names Except mem. have names beginning beginning with 
is overlapping objects. if behavior place between the undefined takes Comparison copying 
unsigned as arrays. treat char arguments functions 

are s and cs are of table, ct variables type type *; the In char following const and t of 
to is c converted int char *; of type an size_t; is and char. n 

*strcpy(s,ct) char 

including string to copy return '\0'; string ct s. s, 

char 
*strncpy(s,ct,n) 

with n to Pad s. copy at characters of return string s; ct '\0''s most 
than fewer characters. ct n has if 

*strcat(s,ct) char 

string string to concatenate return s; end ct s. of 

char 
*strncat(s,ct,n) 

string characters string concatenate at ct n terminate s s, of to most 
return s. with '\0'; 

strcmp(cs,ct) int 

or to if cs==ct, if compare string string ct, 0 return cs<ct, <0 >0 cs 
cs>ct. if 

int 
strncmp(cs,ct,n) 

most n if characters of <0 cs return ct; string compare to at string 
>0 0 if or cs<ct, if cs>ct. cs==ct, 

*strchr(cs,c) char 

to first present. occurrence of not in if NULL c return cs pointer or 

*strrchr(cs,c) char 

to last present. occurrence of not in if NULL c return cs pointer or 

size_t 
strspn(cs,ct) 

characters length of in ct. of of prefix cs consisting return 

 
size_t 
strcspn(cs,ct) 

of not in of length of characters return prefix consisting ct. cs 

char 
*strpbrk(cs,ct) 

to any character occurrence pointer cs of return first string string in 
not present. if ct, NULL or 

to first not occurrence of if ct NULL or string return in pointer cs, 
present. 

strlen(cs) size_t 

of cs. return length 

*strerror(n) char 

string implementation-defined to pointer corresponding to return 
n. error 

*strtok(s,ct) char 

from searches characters ct; see s tokens for delimited by strtok 
below. 

a s each character tokens, by from into sequence A strtok(s,ct) of calls of splits delimited 
a a sequence the in s call token in s, consisting finds The ct. it first of first has non-NULL 
with ct; '\0' character s that not it terminates in and overwriting next the by of characters 
by to a the pointer returns subsequent indicated token. s, the of a Each returns NULL call, value 
strtok the the returns of one. NULL end such next just from searching token, past previous 
each token ct on different when no is found. be The may string call. further 

is are as intent the The mem... meant for arrays; manipulating character objects an functions 
type the cs following to t ct *; and are table, interface In efficient and routines. s void of 
of *; n is converted to const int void size_t; an c of are and type unsigned an is type 
char. 

void 
*memcpy(s,ct,n) 

s, n from copy return and ct characters s. to 

void 
*memmove(s,ct,n) 

memcpy the objects that as even if same except works overlap. it 

memcmp(cs,ct,n) int 

return characters cs compare the with n with strcmp. as of ct; first 

void 
*memchr(cs,c,n) 

to first not occurrence of if c NULL or character return in pointer cs, 
n characters. first present the among 

*memset(s,c,n) void 

s, character of return s. c first into n characters place 

Functions: <math.h> B.4 Mathematical 

functions header and mathematical The <math.h> macros. declares 

EDOM and are ERANGE (found that <errno.h>) constants integral in The are macros non-zero 
positive domain the a is used to and range HUGE_VAL errors functions; for double signal 
the error function domain which an A occurs if domain is is the outside argument over value. 
is domain to value return defined. On error, errno the is EDOM; set implementation-defined. a 
cannot occurs be the error A of function the double. if a range result If represented the as 
set function right is errno result overflows, returns HUGE_VAL and with sign, the to the 
to returns errno ERANGE whether set is zero; If ERANGE. the underflows, result the function is 
implementation-defined. 

an and all y the double, return and functions n are In x following type table, of int, is 
in are expressed radians. double. Angles trigonometric for functions 

 
x [-pi/2,pi/2], [-1,1]. in in range sin-1(x) 

is error not x<0 y x=0 A occurs if domain an y<=0, if or and and xy. 
integer. 

x*2n 

x [0,pi], [-1,1]. in in range cos-1(x) 

range [-pi/2,pi/2]. tan-1(x) in 

range [-pi,pi]. tan-1(y/x) in 

ex function exponential 

logarithm 10 log10(x), x>0. base 



sin(x) 

x of sine 

cos(x) 

x of cosine 

tan(x) 

x of tangent 

asin(x) 

acos(x) 

atan2(y,x) 

sinh(x) 

of x hyperbolic sine 

cosh(x) 

of x hyperbolic cosine 

tanh(x) 

of x hyperbolic tangent 

exp(x) 

log(x) 

ln(x), x>0. natural logarithm 

log10(x) 

pow(x,y) 

sqrt(x) 

of root x, x>=0. sqare 

ceil(x) 

a x, as double. smallest integer less not than 

floor(x) 

a x, as double. largest integer greater not than 

fabs(x) 

|x| value absolute 

ldexp(x,n) 

int frexp(x, 
*ip) 

[1/2,1) normalized in splits x the a is returned, which fraction interval into 
If of x the power and stored *exp. which parts 2, both a is of is in zero, 
zero. are result 

modf(x, 
*ip) double 

x. integral with as sign splits x and fractional same parts, the each It into 
the the returns fractional part. integral in part *ip, and stores 

fmod(x,y) 

zero, x/y, as is y floating-point remainder with the If same x. sign the of 
implementation-defined. is result 

Functions: <stdlib.h> B.5 Utility 

storage header conversion, allocation, and <stdlib.h> functions declares for number The 
char *s) atof(const similar double tasks. 

to converts equivalent strtod(s, (char**)NULL). s double; to it is atof 

char *s) int atoi(const 

(int)strtol(s, s to (char**)NULL, 10). to it int; is equivalent converts 

char *s) long atol(const 

strtol(s, s to (char**)NULL, 10). to it long; is equivalent converts 

char **endp) *s, double char strtod(const 

stores prefix ignoring it space; strtod converts of s white to leading double, a the 
answer unconverted endp the If pointer to suffix in NULL. *endp is unless would any 
the with proper overflow, HUGE_VAL sign; returned would underflow, answer the if is 
set is is to ERANGE. returned. either In case errno zero 

**endp, strtol(const int char long char base) *s, 

stores prefix ignoring it space; strtol converts of s white to leading long, a the 
is unless NULL. between is base 2 endp to pointer in suffix unconverted any *endp If 

 
If is base in base. that 36, done assuming conversion is input written is the that and 
0x is or octal leading or the 8, 10, base 0X leading implies 0 16; and zero, 
0x either 10 leading a hexadecimal. Letters case represent base-1; digits to from or in 
LONG_MIN in answer or LONG_MAX 0X is base 16. overflow, If would the is permitted 
on the ERANGE. sign of to result, set is the returned, and depending errno 

int char **endp, base) unsigned long char strtoul(const *s, 

and that is the result long error the is strtoul strtol as same the except unsigned 
ULONG_MAX. is value 

rand(void) int 

at pseudo-random 0 is which rand returns integer in RAND_MAX, the to range least a 
32767. 

int seed) void srand(unsigned 

seed as The the seed numbers. a pseudo-random of for srand new uses sequence 
is 1. initial seed 

nobj, *calloc(size_t size_t size) void 

size pointer size, objects, of for returns to space a or array nobj of an each calloc 
the request bytes. cannot be zero The to initialized satisfied. NULL space if is 

size) *malloc(size_t void 

if pointer the size, NULL for returns to space a request object size of an or malloc 
space The uninitialized. be is satisfied. cannot 

*p, *realloc(void size_t size) void 

contents size will to The object changes of the the be to p by pointed size. realloc 
sizes. the If the to unchanged old new of is minimum size up the larger, the and new 
NULL pointer new if the or the to space new returns realloc uninitialized. is a space, 
case cannot satisfied, request is *p in be unchanged. which 

*p) free(void void 

is to must by deallocates nothing a p be if p; free pointed the does space it NULL. p 
calloc, to previously pointer or malloc, allocated space realloc. by 

abort(void) void 

if causes as by raise(SIGABRT). the to program terminate abnormally, abort 

status) exit(int void 

normal in reverse termination. causes are called exit program functions order atexit 
open files returned are flushed, is streams control and open of are registration, closed, 
environment. environment is status the to the to How returned implementation- is 
zero values EXIT_SUCCESS taken but termination. The dependent, is successful and as 
also may be used. EXIT_FAILURE 

(*fcn)(void)) atexit(void int 

the fcn be atexit registers called function terminates normally; program to when the 
be registration cannot made. it returns if non-zero the 

char *s) int system(const 

NULL, string for is s system passes s to If the execution. environment system the 
return there value not the command non-zero is a if is If is s processor. NULL, returns 
implementation-dependent. 

char *name) char *getenv(const 

NULL string with getenv returns name, environment no string if associated or the 
are implementation-dependent. exists. Details 



const *key, *base, *bsearch(const void void void 

size_t size, size_t n, 

const *keyval, *datum)) (*cmp)(const void void int 

*key. searches matches The function base[0]...base[n-1] an for item that bsearch 
its negative second is than first must if its return (a (the key) search argument less cmp 
must if be the base positive entry), equal, and zero in greater. in Items if array table 
none returns matching if NULL ascending order. a pointer or to item, a exists. bsearch 

 


n, size_t size, qsort(void size_t *base, void 

const *, *)) (*cmp)(const void void int 

into objects of order sorts base[0]...base[n-1] of qsort ascending array size an 
in is as bsearch. size. The function comparison cmp 

n) abs(int int 

int of its argument. abs returns absolute the value 

n) labs(long long 

long of its argument. labs returns absolute the value 

num, div(int int denom) div_t 

the quotient the and remainder in num/denom. stored are of div The computes results 
of members structure type div_t. quot rem and of a int 

num, ldiv(long long denom) ldiv_t 

the quotient the and remainder in num/denom. stored are of ldiv The computes results 
of members structure type ldiv_t. quot rem and of a long 

<assert.h> Diagnostics: B.6 

add assert is The to diagnostics used macro programs: to 

expression) assert(int void 

is expression zero when If 

assert(expression) 

a macro print is executed, on assert such as message, will stderr the 

filename, file nnn failed: line expression, Assertion 

come abort source number line It then to terminate and execution. filename The from calls 
and __LINE__. __FILE__ the macros preprocessor 

is defined is macro assert If NDEBUG at the the time included, <assert.h> ignored. is 

Argument Variable Lists: <stdarg.h> B.7 

list facilities stepping The header through provides function arguments of for a <stdarg.h> 
number unknown and type. of 



ap; va_list 

be initialized is once with argument macro unnamed any the ap va_start must before 
accessed: 

lastarg); ap, va_start(va_list 

 
the will value type a has and produce each Thereafter, macro the of execution va_arg that 
use next of so next and of unnamed argument, the va_arg also ap modify will the value 
next argument: returns the 

ap, type); type va_arg(va_list 

macro The 



ap); va_end(va_list void 

is once been f before must be after the but arguments processed have exited. called 

Jumps: <setjmp.h> B.8 Non-local 

and <setjmp.h> avoid call function The declarations provide a normal way the to return in 
deeply an return sequence, typically from permit function call. nested immediate a to 

env) setjmp(jmp_buf int 

return saves for The longjmp. The macro state information by in use env is setjmp 
of and a longjmp. from call A non-zero from zero of call direct a setjmp, subsequent 
if, certain the switch, basically of and contexts, to call occur only can setjmp in test 
simple in expressions. and relational only loops, 



== 0) if (setjmp(env) 

direct on */ get call here /* 

else 

calling by */ get longjmp here /* 

env, longjmp(jmp_buf int val) void 

the state the saved by using most setjmp, to the longjmp recent restores call 
in env, just and execution had as function setjmp resumes information if saved the 
returned containing the non-zero and The function executed the val. setjmp value 
have terminated. time Accessible objects the the at had have must values not they 
in was variables the function called, that except non-volatile automatic longjmp 
become the setjmp if setjmp changed after calling undefined were call. they 

<signal.h> Signals: B.9 

conditions header exceptional that arise <signal.h> facilities provides for handling The 
error from source in external an execution. an execution, during interrupt an as such signal or 



sig, (*signal(int void (*handler)(int)))(int) void 

handler signals be signal determines handled. subsequent SIG_DFL, the is will If how 
the used, it implementation-defined default is is is ignored; signal if SIG_IGN, behavior 
the pointed type the of handler the to by function of be with called, will argument otherwise, 
signals include signal. Valid 

SIGABRT 

e.g., termination, from abort abnormal 

SIGFPE 

divide zero overflow error, or e.g., arithmetic 

SIGILL 

illegal instruction e.g., illegal image, function 

e.g., interrupt interactive attention, 

SIGSEGV 

outside storage memory access illegal access, limits e.g., 

SIGTERM 

this program to termination sent request 



 






if for signal, an specific SIG_ERR error the returns signal of value previous the handler or 
occurs. 

behavior; signal to then restored default the is a When occurs, subsequently sig signal the its 
the as by signal-handler function (*handler)(sig). called, returns, execution handler if If is 
signal when the occurred. will resume it where was 

signals of implementation-defined. initial is state The 



sig) raise(int int 

returns sig the raise sends program; signal if unsuccessful. non-zero to it the 

Functions: <time.h> Time B.10 and Date 

date types functions The header for declares time. Some and and manipulating <time.h> 
local time, of which may because from example for differ functions calendar process time, 
clock_t and holds time_t are tm types struct and arithmetic time representing zone. times, 
calendar time: a the of components 

tm_sec; int 

the after minute (0,61) seconds 

tm_min; int 

the after hour (0,59) minutes 

tm_hour; int 

midnight (0,23) hours since 

tm_mday; int 

the of month (1,31) day 

tm_mon; int 

January (0,11) months since 

tm_year; int 

1900 since years 

tm_wday; int 

Sunday (0,6) days since 

tm_yday; int 

January since 1 (0,365) days 

tm_isdst; int 

Time flag Daylight Saving 



negative if if if and Time is Daylight Saving positive the in zero effect, is not, tm_isdst 
not available. information is 

clock(void) clock_t 

since time by clock returns the processor beginning of the used program the 
time or a in seconds. -1 unavailable. if clock()/CLK_PER_SEC is execution, 

*tp) time(time_t time_t 

time current is not the time -1 the time tp calendar If returns or is not if available. 
to also assigned *tp. NULL, the value return is 

time2, difftime(time_t time_t time1) double 

in seconds. expressed difftime time2-time1 returns 

tm *tp) time_t mktime(struct 

the local *tp in time mktime converts time in calendar the into structure same the 
in The will representation used have time. ranges shown. the components values by 
the cannot be time returns if it mktime calendar -1 represented. or 

by static may other that overwritten calls. objects next The pointers return functions four to be 

struct *asctime(const tm *tp) char 

 
the a string in converts *tp into asctime</tt< time structure of the 
form the 



3 Jan 15:14:13 1988\n\0 Sun 

time_t *tp) char *ctime(const 

the it is time converts local time; ctime calendar to equivalent *tp 
to 



asctime(localtime(tp)) 

*gmtime(const tm time_t *tp) struct 

into converts calendar gmtime Universal Coordinated time the Time *tp 
The if is (UTC). It not NULL gmtime has name UTC available. returns 
significance. historical 

*localtime(const tm time_t *tp) struct 

local *tp into time. localtime converts calendar the time 

*s, struct tm smax, strftime(char *fmt, const size_t size_t char *tp) const 

into formats *tp s according date time and information from strftime 
format. fmt, printf Ordinary characters which analogous is to a to 
Each the s. %c is terminating are '\0') copied into (including 
appropriate as below, replaced the for using described local values 
into No placed s. strftime more smax than characters are environment. 
number zero if characters, the '\0', or returns of the more excluding 
characters smax were produced. than 

%a 

name. weekday abbreviated 

%A 

name. weekday full 

%b 

name. month abbreviated 

%B 

name. month full 

%c 

and date time representation. local 

%d 

the of month (01-31). day 

%H 

clock) (00-23). hour (24-hour 

%I 

clock) (01-12). hour (12-hour 

%j 

the of year (001-366). day 

%m 

(01-12). month 

%M 

(00-59). minute 

%p 

or PM. AM local of equivalent 

%S 

(00-61). second 

%U 

of of week) year number 1st day week the as (00-53). (Sunday 

%w 

Sunday (0-6, is 0). weekday 

%W 

of of week) year number 1st day week the as (00-53). (Monday 

%x 

representation. date local 

%X 

representation. time local 

%y 

century (00-99). year without 

%Y 

century. with year 

%Z 

name, zone if any. time 

%% 

% 



Limits: Implementation-defined B.11 
<float.h> and <limits.h> 

 
of header sizes integral types. <limits.h> constants defines for the The 
values values larger may be below acceptable are minimum magnitudes; The 
used. 

CHAR_BIT 

8 

a char bits in 

CHAR_MAX 

SCHAR_MAX or UCHAR_MAX 

of char maximum value 

CHAR_MIN 

SCHAR_MIN or 0 

of char maximum value 

INT_MAX 

32767 

of int maximum value 

INT_MIN 

-32767 

of int minimum value 

LONG_MAX 

2147483647 

of long maximum value 

LONG_MIN 

-2147483647 

of long minimum value 

SCHAR_MAX 

+127 

of value signed char maximum 

SCHAR_MIN 

-127 

of value signed char minimum 

SHRT_MAX 

+32767 

of short maximum value 

SHRT_MIN 

-32767 

of short minimum value 

UCHAR_MAX 

255 

of value unsigned char maximum 

UINT_MAX 

65535 

of value unsigned int maximum 

ULONG_MAX 

4294967295 

of value unsigned long maximum 

USHRT_MAX 

65535 

of value unsigned short maximum 



<float.h>, table a The names subset the constants related are below, of in 
it floating-point given, represents the arithmetic. a When value is to 
quantity. magnitude Each corresponding minimum for implementation the 
values. appropriate defines 

FLT_RADIX 

2 

e.g., representation, 16 of 2, exponent, radix 

FLT_ROUNDS 



mode rounding for addition floating-point 

FLT_DIG 

6 

of precision decimal digits 

FLT_EPSILON 

1E-5 

1.0+x number != that smallest x 1.0 such 

FLT_MANT_DIG 



in mantissa FLT_RADIX number base of 

FLT_MAX 

1E+37 

number floating-point maximum 

FLT_MAX_EXP 

FLT_RADIXn-1 that representable n is such maximum 

FLT_MIN 

1E-37 

floating-point number minimum normalized 

FLT_MIN_EXP 

normalized is a number minimum n that such 10n 

DBL_DIG 

10 

of precision decimal digits 

DBL_EPSILON 

1E-9 

1.0+x number != that smallest x 1.0 such 

DBL_MANT_DIG 



in mantissa FLT_RADIX number base of 

DBL_MAX 

1E+37 

floating-point number maximum double 

DBL_MAX_EXP 

FLT_RADIXn-1 that representable n is such maximum 

DBL_MIN 

1E-37 

double normalized floating-point number minimum 

DBL_MIN_EXP 

normalized is a number minimum n that such 10n 





 


of Changes Summary Appendix - C 

C of language definition the edition the the first publication has this the book, of of Since 
language, were of undergone changes. the all were carefully and extensions original Almost 
remain ambiguities in with to some repaired designed compatible practice; the existing 
and practice. Many represent description; change existing original some that of modifications 
facilities compilers available announced new documents accompanying the were the from in 
of been by AT&T, and other subsequently compilers. More C adopted suppliers have 
ANSI of the standardizing the incorporated most recently, committee language changes, the 
in significant Their and also report other participated by part modifications. was introduced 
formal commercial the C standard. compilers before even issuance of some 

by differences the This Appendix language the first edition the between defined summarizes 
the and final language book, of be by expected only that treats this to the standard. defined It 
the environment are of part itself, not and library; important although an these standard, its 
to the did prescribe edition attempt an first is there with, compare to little because not 
library. or environment 

edition, the in and than first is Standard Preprocessing  defined carefully more is in the 
operators token there extended: it are explicitly concatenation of for based; new is 
#elif creation are like lines tokens (##), of strings control (#); new there and and 
of is explicitly by redeclaration token sequence #pragma; macros same permitted; the 
strings are permitted no longer is Splicing \ by replaced. parameters of inside lines 
macro not in everywhere, See definitions. strings just Par.A.12. and 
sequences characters lacking by Trigraph representation of  introduced allow in ?? 
sets. Par.A.12.1. Observe for character defined, see some Escapes are that #\^[]{}|~ 
of strings containing may introduction meaning of the trigraphs the the change 
??. sequence 
and for within  New character sequences, literals, are string use constants escape 
approved of character an of defined. The following \ part by not a escape effect 
undefined. is See Par.A.2.5.2. sequence 
of of make constants to type explicit: suffixes The  larger a introduces standard set the 
for F or the the type for for integers, It of refines or U also L unsiffixed rules L floating. 
(Par.A.2.5). constants 
and notation wide-character  There string a constants; see character for literals is 
Par.A.2.6. 


significance 31 characters; all minimum increased to The of identifiers the internal 
external mandated of smallest remains linkage identifiers significance 6 with 
provide more.) implementations monocase (Many letters. 

enum) keywords const, New introduced. are volatile, (void, The signed, 
keyword entry is withdrawn. stillborn 

not favorite are octal digits. trivial 8 change: and 9 Everyone's 

literals string are concatenated. Adjacent 

declared well to a as  may explicitly other to as not Characters types, carry, carry, be or 
using the a keywords signed as unsigned. float long or sign The by locution 
an is may declare to synonym for withdrawn, but used long be double extra- double 
quantity. floating precision 

some time, the type unsigned introduces has standard The char  been For available. 
to other integral signedness keyword char and signed make for objects. explicit 

 
Standard adopts const from C++ example notion for qualifier, the  of The type 
(Par.A.8.2). 
from The essentially ``for integers, ``usual conversions'' arithmetic are changed,  
to floating always unsigned always use for to the ``promote point, double'' wins; 
type.'' capacious-enough See Par.A.6.5. smallest 
an to explicit function without may A a function pointer * used a as be designator  
Par.A.7.3.2. See operator. 
type in first  The edition, operator, subsequently, many int; the yielded sizeof 
makes made unsigned. implementations type its The it explicitly Standard 
requires in a type, but be defined implementation-dependent, the to standard size_t, 
A (ptrdiff_t) of change (<stddef.h>). the type header similar in the occurs 
Par.A.7.4.8 See Par.A.7.7. between and pointers. difference 
right that left operand the the can't of type The expression shift a of is operand; 
result. the See Par.A.7.8. promote 
an pointer the array, beyond of and just Standard The of creation the legalizes a end 
it; arithmetic see on allows and Par.A.7.7. relations 
of (borrowing C++)  The the introduces function prototype a from notion Standard 
incorporates includes an types that parameters, and declaration the the explicit of 
of together an recognition of approved functions with them. dealing with way variadic 
still B.7. older See Pars. style A.8.6.3, with restrictions. accepted, The is A.7.3.2, 


void type The has been years. in some for available  most The implementations 
type; use type pointer generic Standard introduces of the a void as * previously the 
against this time, enacted are char * role. At rules the explicit same mixing played 
the pointers different pointers and type, and of casts. use of without integers, 

Standard places and explicit minima types, the arithmetic the on  ranges The of 
the headers and mandates of characteristics <float.h>) (<limits.h> each giving 
implementation. particular 

edition are since Enumerations this of the new book. first 

placed modifiable, so Strings are may longer read-only memory. in and be no 

old assignment are operators like operators are assignment Also, =+  truly The gone. 
separated in were be could now single the first and edition, pairs, they by tokens; 
space. white 

operators A associative as computationally compiler's to license treat mathematically  
revoked. is associative 

with unary symmetry unary -. + is operator introduced for A 

may returned by assigned, Structures functions, and  be to functions. passed 

pointer operator and a is Applying the to arrays result is the permitted, to address-of 
array. the 

even & to register, declared The address-of may not object be an applied if operator 
in implementation object a register. chooses to not keep the the 

declarations, which structure, have no a and least at declarators  don't Empty declare 
enumeration, are declaration forbidden by a Standard. hand, other the union, On or the 
even structure if outer a with redeclares tag union in or declared just tag an it that was 
scope. 

(just without specifiers  External or declarations naked declarator) a any qualifiers data 
forbidden. are 

in presented an  Some extern when inner block, an with declaration implementations, 
clear declaration that Standard it rest export to the the the the The file. of makes would 
the is just block. scope of a such declaration 

compound is into The scope a parameters so that statement, injected function's of 
cannot top of variable declarations the the the parameters. hide level function at 

 
tags somewhat Standard in The all a different. The  identifiers of spaces name are puts 
space also a single name separate and labels; see for introduces name space, 
or are with Par.A.11.1. Also, the names of which union associated structure member 
a from some (This are common practice they part. been time.) has 


may the first initialized; Unions refers to  be initializer member. the 

structures, unions, way. and arrays restricted be a in may  initialized, Automatic albeit 

literal may by with initialized string exactly be Character  explicit an with arrays size a 
squeezed is quietly out). that many (the characters \0 

any expression, of have may  The and the switch case a labels, integral controlling 
type. 



 
